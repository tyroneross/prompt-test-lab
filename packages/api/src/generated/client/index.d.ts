
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model Prompt
 * 
 */
export type Prompt = $Result.DefaultSelection<Prisma.$PromptPayload>
/**
 * Model TestRun
 * 
 */
export type TestRun = $Result.DefaultSelection<Prisma.$TestRunPayload>
/**
 * Model TestResponse
 * 
 */
export type TestResponse = $Result.DefaultSelection<Prisma.$TestResponsePayload>
/**
 * Model TestMetric
 * 
 */
export type TestMetric = $Result.DefaultSelection<Prisma.$TestMetricPayload>
/**
 * Model EvaluationPlugin
 * 
 */
export type EvaluationPlugin = $Result.DefaultSelection<Prisma.$EvaluationPluginPayload>
/**
 * Model QueueJob
 * 
 */
export type QueueJob = $Result.DefaultSelection<Prisma.$QueueJobPayload>
/**
 * Model RecurringJob
 * 
 */
export type RecurringJob = $Result.DefaultSelection<Prisma.$RecurringJobPayload>
/**
 * Model SyncOperation
 * 
 */
export type SyncOperation = $Result.DefaultSelection<Prisma.$SyncOperationPayload>
/**
 * Model WebhookSubscription
 * 
 */
export type WebhookSubscription = $Result.DefaultSelection<Prisma.$WebhookSubscriptionPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Environment
 * 
 */
export type Environment = $Result.DefaultSelection<Prisma.$EnvironmentPayload>
/**
 * Model Deployment
 * 
 */
export type Deployment = $Result.DefaultSelection<Prisma.$DeploymentPayload>
/**
 * Model DeploymentHistory
 * 
 */
export type DeploymentHistory = $Result.DefaultSelection<Prisma.$DeploymentHistoryPayload>
/**
 * Model ImpactAnalysis
 * 
 */
export type ImpactAnalysis = $Result.DefaultSelection<Prisma.$ImpactAnalysisPayload>
/**
 * Model CostTracking
 * 
 */
export type CostTracking = $Result.DefaultSelection<Prisma.$CostTrackingPayload>
/**
 * Model UserBilling
 * 
 */
export type UserBilling = $Result.DefaultSelection<Prisma.$UserBillingPayload>
/**
 * Model AppIntegration
 * 
 */
export type AppIntegration = $Result.DefaultSelection<Prisma.$AppIntegrationPayload>
/**
 * Model TestPipeline
 * 
 */
export type TestPipeline = $Result.DefaultSelection<Prisma.$TestPipelinePayload>
/**
 * Model PipelineStage
 * 
 */
export type PipelineStage = $Result.DefaultSelection<Prisma.$PipelineStagePayload>
/**
 * Model PipelineExecution
 * 
 */
export type PipelineExecution = $Result.DefaultSelection<Prisma.$PipelineExecutionPayload>
/**
 * Model Dependency
 * 
 */
export type Dependency = $Result.DefaultSelection<Prisma.$DependencyPayload>
/**
 * Model UpdatePlan
 * 
 */
export type UpdatePlan = $Result.DefaultSelection<Prisma.$UpdatePlanPayload>
/**
 * Model DeploymentPlan
 * 
 */
export type DeploymentPlan = $Result.DefaultSelection<Prisma.$DeploymentPlanPayload>
/**
 * Model DeploymentExecution
 * 
 */
export type DeploymentExecution = $Result.DefaultSelection<Prisma.$DeploymentExecutionPayload>
/**
 * Model DeploymentApproval
 * 
 */
export type DeploymentApproval = $Result.DefaultSelection<Prisma.$DeploymentApprovalPayload>
/**
 * Model ApprovalRequest
 * 
 */
export type ApprovalRequest = $Result.DefaultSelection<Prisma.$ApprovalRequestPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs>;

  /**
   * `prisma.prompt`: Exposes CRUD operations for the **Prompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prompts
    * const prompts = await prisma.prompt.findMany()
    * ```
    */
  get prompt(): Prisma.PromptDelegate<ExtArgs>;

  /**
   * `prisma.testRun`: Exposes CRUD operations for the **TestRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestRuns
    * const testRuns = await prisma.testRun.findMany()
    * ```
    */
  get testRun(): Prisma.TestRunDelegate<ExtArgs>;

  /**
   * `prisma.testResponse`: Exposes CRUD operations for the **TestResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestResponses
    * const testResponses = await prisma.testResponse.findMany()
    * ```
    */
  get testResponse(): Prisma.TestResponseDelegate<ExtArgs>;

  /**
   * `prisma.testMetric`: Exposes CRUD operations for the **TestMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestMetrics
    * const testMetrics = await prisma.testMetric.findMany()
    * ```
    */
  get testMetric(): Prisma.TestMetricDelegate<ExtArgs>;

  /**
   * `prisma.evaluationPlugin`: Exposes CRUD operations for the **EvaluationPlugin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationPlugins
    * const evaluationPlugins = await prisma.evaluationPlugin.findMany()
    * ```
    */
  get evaluationPlugin(): Prisma.EvaluationPluginDelegate<ExtArgs>;

  /**
   * `prisma.queueJob`: Exposes CRUD operations for the **QueueJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueJobs
    * const queueJobs = await prisma.queueJob.findMany()
    * ```
    */
  get queueJob(): Prisma.QueueJobDelegate<ExtArgs>;

  /**
   * `prisma.recurringJob`: Exposes CRUD operations for the **RecurringJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringJobs
    * const recurringJobs = await prisma.recurringJob.findMany()
    * ```
    */
  get recurringJob(): Prisma.RecurringJobDelegate<ExtArgs>;

  /**
   * `prisma.syncOperation`: Exposes CRUD operations for the **SyncOperation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncOperations
    * const syncOperations = await prisma.syncOperation.findMany()
    * ```
    */
  get syncOperation(): Prisma.SyncOperationDelegate<ExtArgs>;

  /**
   * `prisma.webhookSubscription`: Exposes CRUD operations for the **WebhookSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookSubscriptions
    * const webhookSubscriptions = await prisma.webhookSubscription.findMany()
    * ```
    */
  get webhookSubscription(): Prisma.WebhookSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.environment`: Exposes CRUD operations for the **Environment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Environments
    * const environments = await prisma.environment.findMany()
    * ```
    */
  get environment(): Prisma.EnvironmentDelegate<ExtArgs>;

  /**
   * `prisma.deployment`: Exposes CRUD operations for the **Deployment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deployments
    * const deployments = await prisma.deployment.findMany()
    * ```
    */
  get deployment(): Prisma.DeploymentDelegate<ExtArgs>;

  /**
   * `prisma.deploymentHistory`: Exposes CRUD operations for the **DeploymentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeploymentHistories
    * const deploymentHistories = await prisma.deploymentHistory.findMany()
    * ```
    */
  get deploymentHistory(): Prisma.DeploymentHistoryDelegate<ExtArgs>;

  /**
   * `prisma.impactAnalysis`: Exposes CRUD operations for the **ImpactAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImpactAnalyses
    * const impactAnalyses = await prisma.impactAnalysis.findMany()
    * ```
    */
  get impactAnalysis(): Prisma.ImpactAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.costTracking`: Exposes CRUD operations for the **CostTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostTrackings
    * const costTrackings = await prisma.costTracking.findMany()
    * ```
    */
  get costTracking(): Prisma.CostTrackingDelegate<ExtArgs>;

  /**
   * `prisma.userBilling`: Exposes CRUD operations for the **UserBilling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBillings
    * const userBillings = await prisma.userBilling.findMany()
    * ```
    */
  get userBilling(): Prisma.UserBillingDelegate<ExtArgs>;

  /**
   * `prisma.appIntegration`: Exposes CRUD operations for the **AppIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppIntegrations
    * const appIntegrations = await prisma.appIntegration.findMany()
    * ```
    */
  get appIntegration(): Prisma.AppIntegrationDelegate<ExtArgs>;

  /**
   * `prisma.testPipeline`: Exposes CRUD operations for the **TestPipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestPipelines
    * const testPipelines = await prisma.testPipeline.findMany()
    * ```
    */
  get testPipeline(): Prisma.TestPipelineDelegate<ExtArgs>;

  /**
   * `prisma.pipelineStage`: Exposes CRUD operations for the **PipelineStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PipelineStages
    * const pipelineStages = await prisma.pipelineStage.findMany()
    * ```
    */
  get pipelineStage(): Prisma.PipelineStageDelegate<ExtArgs>;

  /**
   * `prisma.pipelineExecution`: Exposes CRUD operations for the **PipelineExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PipelineExecutions
    * const pipelineExecutions = await prisma.pipelineExecution.findMany()
    * ```
    */
  get pipelineExecution(): Prisma.PipelineExecutionDelegate<ExtArgs>;

  /**
   * `prisma.dependency`: Exposes CRUD operations for the **Dependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dependencies
    * const dependencies = await prisma.dependency.findMany()
    * ```
    */
  get dependency(): Prisma.DependencyDelegate<ExtArgs>;

  /**
   * `prisma.updatePlan`: Exposes CRUD operations for the **UpdatePlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UpdatePlans
    * const updatePlans = await prisma.updatePlan.findMany()
    * ```
    */
  get updatePlan(): Prisma.UpdatePlanDelegate<ExtArgs>;

  /**
   * `prisma.deploymentPlan`: Exposes CRUD operations for the **DeploymentPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeploymentPlans
    * const deploymentPlans = await prisma.deploymentPlan.findMany()
    * ```
    */
  get deploymentPlan(): Prisma.DeploymentPlanDelegate<ExtArgs>;

  /**
   * `prisma.deploymentExecution`: Exposes CRUD operations for the **DeploymentExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeploymentExecutions
    * const deploymentExecutions = await prisma.deploymentExecution.findMany()
    * ```
    */
  get deploymentExecution(): Prisma.DeploymentExecutionDelegate<ExtArgs>;

  /**
   * `prisma.deploymentApproval`: Exposes CRUD operations for the **DeploymentApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeploymentApprovals
    * const deploymentApprovals = await prisma.deploymentApproval.findMany()
    * ```
    */
  get deploymentApproval(): Prisma.DeploymentApprovalDelegate<ExtArgs>;

  /**
   * `prisma.approvalRequest`: Exposes CRUD operations for the **ApprovalRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalRequests
    * const approvalRequests = await prisma.approvalRequest.findMany()
    * ```
    */
  get approvalRequest(): Prisma.ApprovalRequestDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    Prompt: 'Prompt',
    TestRun: 'TestRun',
    TestResponse: 'TestResponse',
    TestMetric: 'TestMetric',
    EvaluationPlugin: 'EvaluationPlugin',
    QueueJob: 'QueueJob',
    RecurringJob: 'RecurringJob',
    SyncOperation: 'SyncOperation',
    WebhookSubscription: 'WebhookSubscription',
    WebhookDelivery: 'WebhookDelivery',
    ApiKey: 'ApiKey',
    Environment: 'Environment',
    Deployment: 'Deployment',
    DeploymentHistory: 'DeploymentHistory',
    ImpactAnalysis: 'ImpactAnalysis',
    CostTracking: 'CostTracking',
    UserBilling: 'UserBilling',
    AppIntegration: 'AppIntegration',
    TestPipeline: 'TestPipeline',
    PipelineStage: 'PipelineStage',
    PipelineExecution: 'PipelineExecution',
    Dependency: 'Dependency',
    UpdatePlan: 'UpdatePlan',
    DeploymentPlan: 'DeploymentPlan',
    DeploymentExecution: 'DeploymentExecution',
    DeploymentApproval: 'DeploymentApproval',
    ApprovalRequest: 'ApprovalRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "project" | "projectMember" | "prompt" | "testRun" | "testResponse" | "testMetric" | "evaluationPlugin" | "queueJob" | "recurringJob" | "syncOperation" | "webhookSubscription" | "webhookDelivery" | "apiKey" | "environment" | "deployment" | "deploymentHistory" | "impactAnalysis" | "costTracking" | "userBilling" | "appIntegration" | "testPipeline" | "pipelineStage" | "pipelineExecution" | "dependency" | "updatePlan" | "deploymentPlan" | "deploymentExecution" | "deploymentApproval" | "approvalRequest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      Prompt: {
        payload: Prisma.$PromptPayload<ExtArgs>
        fields: Prisma.PromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findFirst: {
            args: Prisma.PromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findMany: {
            args: Prisma.PromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          create: {
            args: Prisma.PromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          createMany: {
            args: Prisma.PromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          delete: {
            args: Prisma.PromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          update: {
            args: Prisma.PromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          deleteMany: {
            args: Prisma.PromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          aggregate: {
            args: Prisma.PromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrompt>
          }
          groupBy: {
            args: Prisma.PromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptCountArgs<ExtArgs>
            result: $Utils.Optional<PromptCountAggregateOutputType> | number
          }
        }
      }
      TestRun: {
        payload: Prisma.$TestRunPayload<ExtArgs>
        fields: Prisma.TestRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>
          }
          findFirst: {
            args: Prisma.TestRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>
          }
          findMany: {
            args: Prisma.TestRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>[]
          }
          create: {
            args: Prisma.TestRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>
          }
          createMany: {
            args: Prisma.TestRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>[]
          }
          delete: {
            args: Prisma.TestRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>
          }
          update: {
            args: Prisma.TestRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>
          }
          deleteMany: {
            args: Prisma.TestRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestRunPayload>
          }
          aggregate: {
            args: Prisma.TestRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestRun>
          }
          groupBy: {
            args: Prisma.TestRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestRunCountArgs<ExtArgs>
            result: $Utils.Optional<TestRunCountAggregateOutputType> | number
          }
        }
      }
      TestResponse: {
        payload: Prisma.$TestResponsePayload<ExtArgs>
        fields: Prisma.TestResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>
          }
          findFirst: {
            args: Prisma.TestResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>
          }
          findMany: {
            args: Prisma.TestResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>[]
          }
          create: {
            args: Prisma.TestResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>
          }
          createMany: {
            args: Prisma.TestResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>[]
          }
          delete: {
            args: Prisma.TestResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>
          }
          update: {
            args: Prisma.TestResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>
          }
          deleteMany: {
            args: Prisma.TestResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResponsePayload>
          }
          aggregate: {
            args: Prisma.TestResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestResponse>
          }
          groupBy: {
            args: Prisma.TestResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestResponseCountArgs<ExtArgs>
            result: $Utils.Optional<TestResponseCountAggregateOutputType> | number
          }
        }
      }
      TestMetric: {
        payload: Prisma.$TestMetricPayload<ExtArgs>
        fields: Prisma.TestMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>
          }
          findFirst: {
            args: Prisma.TestMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>
          }
          findMany: {
            args: Prisma.TestMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>[]
          }
          create: {
            args: Prisma.TestMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>
          }
          createMany: {
            args: Prisma.TestMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>[]
          }
          delete: {
            args: Prisma.TestMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>
          }
          update: {
            args: Prisma.TestMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>
          }
          deleteMany: {
            args: Prisma.TestMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestMetricPayload>
          }
          aggregate: {
            args: Prisma.TestMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestMetric>
          }
          groupBy: {
            args: Prisma.TestMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestMetricCountArgs<ExtArgs>
            result: $Utils.Optional<TestMetricCountAggregateOutputType> | number
          }
        }
      }
      EvaluationPlugin: {
        payload: Prisma.$EvaluationPluginPayload<ExtArgs>
        fields: Prisma.EvaluationPluginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationPluginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationPluginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>
          }
          findFirst: {
            args: Prisma.EvaluationPluginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationPluginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>
          }
          findMany: {
            args: Prisma.EvaluationPluginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>[]
          }
          create: {
            args: Prisma.EvaluationPluginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>
          }
          createMany: {
            args: Prisma.EvaluationPluginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationPluginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>[]
          }
          delete: {
            args: Prisma.EvaluationPluginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>
          }
          update: {
            args: Prisma.EvaluationPluginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationPluginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationPluginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationPluginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPluginPayload>
          }
          aggregate: {
            args: Prisma.EvaluationPluginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationPlugin>
          }
          groupBy: {
            args: Prisma.EvaluationPluginGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationPluginGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationPluginCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationPluginCountAggregateOutputType> | number
          }
        }
      }
      QueueJob: {
        payload: Prisma.$QueueJobPayload<ExtArgs>
        fields: Prisma.QueueJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>
          }
          findFirst: {
            args: Prisma.QueueJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>
          }
          findMany: {
            args: Prisma.QueueJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>[]
          }
          create: {
            args: Prisma.QueueJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>
          }
          createMany: {
            args: Prisma.QueueJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>[]
          }
          delete: {
            args: Prisma.QueueJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>
          }
          update: {
            args: Prisma.QueueJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>
          }
          deleteMany: {
            args: Prisma.QueueJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QueueJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueJobPayload>
          }
          aggregate: {
            args: Prisma.QueueJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueJob>
          }
          groupBy: {
            args: Prisma.QueueJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueJobCountArgs<ExtArgs>
            result: $Utils.Optional<QueueJobCountAggregateOutputType> | number
          }
        }
      }
      RecurringJob: {
        payload: Prisma.$RecurringJobPayload<ExtArgs>
        fields: Prisma.RecurringJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>
          }
          findFirst: {
            args: Prisma.RecurringJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>
          }
          findMany: {
            args: Prisma.RecurringJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>[]
          }
          create: {
            args: Prisma.RecurringJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>
          }
          createMany: {
            args: Prisma.RecurringJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>[]
          }
          delete: {
            args: Prisma.RecurringJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>
          }
          update: {
            args: Prisma.RecurringJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>
          }
          deleteMany: {
            args: Prisma.RecurringJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurringJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringJobPayload>
          }
          aggregate: {
            args: Prisma.RecurringJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringJob>
          }
          groupBy: {
            args: Prisma.RecurringJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringJobCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringJobCountAggregateOutputType> | number
          }
        }
      }
      SyncOperation: {
        payload: Prisma.$SyncOperationPayload<ExtArgs>
        fields: Prisma.SyncOperationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncOperationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncOperationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>
          }
          findFirst: {
            args: Prisma.SyncOperationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncOperationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>
          }
          findMany: {
            args: Prisma.SyncOperationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>[]
          }
          create: {
            args: Prisma.SyncOperationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>
          }
          createMany: {
            args: Prisma.SyncOperationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncOperationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>[]
          }
          delete: {
            args: Prisma.SyncOperationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>
          }
          update: {
            args: Prisma.SyncOperationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>
          }
          deleteMany: {
            args: Prisma.SyncOperationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncOperationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncOperationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>
          }
          aggregate: {
            args: Prisma.SyncOperationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncOperation>
          }
          groupBy: {
            args: Prisma.SyncOperationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncOperationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncOperationCountArgs<ExtArgs>
            result: $Utils.Optional<SyncOperationCountAggregateOutputType> | number
          }
        }
      }
      WebhookSubscription: {
        payload: Prisma.$WebhookSubscriptionPayload<ExtArgs>
        fields: Prisma.WebhookSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.WebhookSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          findMany: {
            args: Prisma.WebhookSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
          }
          create: {
            args: Prisma.WebhookSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          createMany: {
            args: Prisma.WebhookSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.WebhookSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          update: {
            args: Prisma.WebhookSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.WebhookSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.WebhookSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookSubscription>
          }
          groupBy: {
            args: Prisma.WebhookSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Environment: {
        payload: Prisma.$EnvironmentPayload<ExtArgs>
        fields: Prisma.EnvironmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvironmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvironmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          findFirst: {
            args: Prisma.EnvironmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvironmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          findMany: {
            args: Prisma.EnvironmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
          }
          create: {
            args: Prisma.EnvironmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          createMany: {
            args: Prisma.EnvironmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnvironmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>[]
          }
          delete: {
            args: Prisma.EnvironmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          update: {
            args: Prisma.EnvironmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          deleteMany: {
            args: Prisma.EnvironmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnvironmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnvironmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnvironmentPayload>
          }
          aggregate: {
            args: Prisma.EnvironmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnvironment>
          }
          groupBy: {
            args: Prisma.EnvironmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvironmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnvironmentCountAggregateOutputType> | number
          }
        }
      }
      Deployment: {
        payload: Prisma.$DeploymentPayload<ExtArgs>
        fields: Prisma.DeploymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          findFirst: {
            args: Prisma.DeploymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          findMany: {
            args: Prisma.DeploymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>[]
          }
          create: {
            args: Prisma.DeploymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          createMany: {
            args: Prisma.DeploymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>[]
          }
          delete: {
            args: Prisma.DeploymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          update: {
            args: Prisma.DeploymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPayload>
          }
          aggregate: {
            args: Prisma.DeploymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeployment>
          }
          groupBy: {
            args: Prisma.DeploymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentCountAggregateOutputType> | number
          }
        }
      }
      DeploymentHistory: {
        payload: Prisma.$DeploymentHistoryPayload<ExtArgs>
        fields: Prisma.DeploymentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>
          }
          findFirst: {
            args: Prisma.DeploymentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>
          }
          findMany: {
            args: Prisma.DeploymentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>[]
          }
          create: {
            args: Prisma.DeploymentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>
          }
          createMany: {
            args: Prisma.DeploymentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>[]
          }
          delete: {
            args: Prisma.DeploymentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>
          }
          update: {
            args: Prisma.DeploymentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentHistoryPayload>
          }
          aggregate: {
            args: Prisma.DeploymentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeploymentHistory>
          }
          groupBy: {
            args: Prisma.DeploymentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentHistoryCountAggregateOutputType> | number
          }
        }
      }
      ImpactAnalysis: {
        payload: Prisma.$ImpactAnalysisPayload<ExtArgs>
        fields: Prisma.ImpactAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImpactAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImpactAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>
          }
          findFirst: {
            args: Prisma.ImpactAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImpactAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>
          }
          findMany: {
            args: Prisma.ImpactAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>[]
          }
          create: {
            args: Prisma.ImpactAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>
          }
          createMany: {
            args: Prisma.ImpactAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImpactAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>[]
          }
          delete: {
            args: Prisma.ImpactAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>
          }
          update: {
            args: Prisma.ImpactAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.ImpactAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImpactAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImpactAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpactAnalysisPayload>
          }
          aggregate: {
            args: Prisma.ImpactAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpactAnalysis>
          }
          groupBy: {
            args: Prisma.ImpactAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImpactAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImpactAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<ImpactAnalysisCountAggregateOutputType> | number
          }
        }
      }
      CostTracking: {
        payload: Prisma.$CostTrackingPayload<ExtArgs>
        fields: Prisma.CostTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>
          }
          findFirst: {
            args: Prisma.CostTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>
          }
          findMany: {
            args: Prisma.CostTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>[]
          }
          create: {
            args: Prisma.CostTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>
          }
          createMany: {
            args: Prisma.CostTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>[]
          }
          delete: {
            args: Prisma.CostTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>
          }
          update: {
            args: Prisma.CostTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>
          }
          deleteMany: {
            args: Prisma.CostTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostTrackingPayload>
          }
          aggregate: {
            args: Prisma.CostTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostTracking>
          }
          groupBy: {
            args: Prisma.CostTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<CostTrackingCountAggregateOutputType> | number
          }
        }
      }
      UserBilling: {
        payload: Prisma.$UserBillingPayload<ExtArgs>
        fields: Prisma.UserBillingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBillingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBillingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>
          }
          findFirst: {
            args: Prisma.UserBillingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBillingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>
          }
          findMany: {
            args: Prisma.UserBillingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>[]
          }
          create: {
            args: Prisma.UserBillingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>
          }
          createMany: {
            args: Prisma.UserBillingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBillingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>[]
          }
          delete: {
            args: Prisma.UserBillingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>
          }
          update: {
            args: Prisma.UserBillingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>
          }
          deleteMany: {
            args: Prisma.UserBillingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBillingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBillingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBillingPayload>
          }
          aggregate: {
            args: Prisma.UserBillingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBilling>
          }
          groupBy: {
            args: Prisma.UserBillingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBillingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBillingCountArgs<ExtArgs>
            result: $Utils.Optional<UserBillingCountAggregateOutputType> | number
          }
        }
      }
      AppIntegration: {
        payload: Prisma.$AppIntegrationPayload<ExtArgs>
        fields: Prisma.AppIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>
          }
          findFirst: {
            args: Prisma.AppIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>
          }
          findMany: {
            args: Prisma.AppIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>[]
          }
          create: {
            args: Prisma.AppIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>
          }
          createMany: {
            args: Prisma.AppIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>[]
          }
          delete: {
            args: Prisma.AppIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>
          }
          update: {
            args: Prisma.AppIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.AppIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIntegrationPayload>
          }
          aggregate: {
            args: Prisma.AppIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppIntegration>
          }
          groupBy: {
            args: Prisma.AppIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<AppIntegrationCountAggregateOutputType> | number
          }
        }
      }
      TestPipeline: {
        payload: Prisma.$TestPipelinePayload<ExtArgs>
        fields: Prisma.TestPipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestPipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestPipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>
          }
          findFirst: {
            args: Prisma.TestPipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestPipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>
          }
          findMany: {
            args: Prisma.TestPipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>[]
          }
          create: {
            args: Prisma.TestPipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>
          }
          createMany: {
            args: Prisma.TestPipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestPipelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>[]
          }
          delete: {
            args: Prisma.TestPipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>
          }
          update: {
            args: Prisma.TestPipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>
          }
          deleteMany: {
            args: Prisma.TestPipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestPipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestPipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestPipelinePayload>
          }
          aggregate: {
            args: Prisma.TestPipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestPipeline>
          }
          groupBy: {
            args: Prisma.TestPipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestPipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestPipelineCountArgs<ExtArgs>
            result: $Utils.Optional<TestPipelineCountAggregateOutputType> | number
          }
        }
      }
      PipelineStage: {
        payload: Prisma.$PipelineStagePayload<ExtArgs>
        fields: Prisma.PipelineStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          findFirst: {
            args: Prisma.PipelineStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          findMany: {
            args: Prisma.PipelineStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>[]
          }
          create: {
            args: Prisma.PipelineStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          createMany: {
            args: Prisma.PipelineStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>[]
          }
          delete: {
            args: Prisma.PipelineStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          update: {
            args: Prisma.PipelineStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          deleteMany: {
            args: Prisma.PipelineStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PipelineStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineStagePayload>
          }
          aggregate: {
            args: Prisma.PipelineStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipelineStage>
          }
          groupBy: {
            args: Prisma.PipelineStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineStageCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineStageCountAggregateOutputType> | number
          }
        }
      }
      PipelineExecution: {
        payload: Prisma.$PipelineExecutionPayload<ExtArgs>
        fields: Prisma.PipelineExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>
          }
          findFirst: {
            args: Prisma.PipelineExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>
          }
          findMany: {
            args: Prisma.PipelineExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>[]
          }
          create: {
            args: Prisma.PipelineExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>
          }
          createMany: {
            args: Prisma.PipelineExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>[]
          }
          delete: {
            args: Prisma.PipelineExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>
          }
          update: {
            args: Prisma.PipelineExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>
          }
          deleteMany: {
            args: Prisma.PipelineExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PipelineExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelineExecutionPayload>
          }
          aggregate: {
            args: Prisma.PipelineExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipelineExecution>
          }
          groupBy: {
            args: Prisma.PipelineExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineExecutionCountAggregateOutputType> | number
          }
        }
      }
      Dependency: {
        payload: Prisma.$DependencyPayload<ExtArgs>
        fields: Prisma.DependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          findFirst: {
            args: Prisma.DependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          findMany: {
            args: Prisma.DependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          create: {
            args: Prisma.DependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          createMany: {
            args: Prisma.DependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DependencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          delete: {
            args: Prisma.DependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          update: {
            args: Prisma.DependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          deleteMany: {
            args: Prisma.DependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          aggregate: {
            args: Prisma.DependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDependency>
          }
          groupBy: {
            args: Prisma.DependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DependencyCountArgs<ExtArgs>
            result: $Utils.Optional<DependencyCountAggregateOutputType> | number
          }
        }
      }
      UpdatePlan: {
        payload: Prisma.$UpdatePlanPayload<ExtArgs>
        fields: Prisma.UpdatePlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpdatePlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpdatePlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>
          }
          findFirst: {
            args: Prisma.UpdatePlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpdatePlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>
          }
          findMany: {
            args: Prisma.UpdatePlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>[]
          }
          create: {
            args: Prisma.UpdatePlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>
          }
          createMany: {
            args: Prisma.UpdatePlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UpdatePlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>[]
          }
          delete: {
            args: Prisma.UpdatePlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>
          }
          update: {
            args: Prisma.UpdatePlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>
          }
          deleteMany: {
            args: Prisma.UpdatePlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpdatePlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UpdatePlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePlanPayload>
          }
          aggregate: {
            args: Prisma.UpdatePlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpdatePlan>
          }
          groupBy: {
            args: Prisma.UpdatePlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpdatePlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpdatePlanCountArgs<ExtArgs>
            result: $Utils.Optional<UpdatePlanCountAggregateOutputType> | number
          }
        }
      }
      DeploymentPlan: {
        payload: Prisma.$DeploymentPlanPayload<ExtArgs>
        fields: Prisma.DeploymentPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>
          }
          findFirst: {
            args: Prisma.DeploymentPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>
          }
          findMany: {
            args: Prisma.DeploymentPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>[]
          }
          create: {
            args: Prisma.DeploymentPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>
          }
          createMany: {
            args: Prisma.DeploymentPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>[]
          }
          delete: {
            args: Prisma.DeploymentPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>
          }
          update: {
            args: Prisma.DeploymentPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentPlanPayload>
          }
          aggregate: {
            args: Prisma.DeploymentPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeploymentPlan>
          }
          groupBy: {
            args: Prisma.DeploymentPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentPlanCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentPlanCountAggregateOutputType> | number
          }
        }
      }
      DeploymentExecution: {
        payload: Prisma.$DeploymentExecutionPayload<ExtArgs>
        fields: Prisma.DeploymentExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>
          }
          findFirst: {
            args: Prisma.DeploymentExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>
          }
          findMany: {
            args: Prisma.DeploymentExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>[]
          }
          create: {
            args: Prisma.DeploymentExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>
          }
          createMany: {
            args: Prisma.DeploymentExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>[]
          }
          delete: {
            args: Prisma.DeploymentExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>
          }
          update: {
            args: Prisma.DeploymentExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentExecutionPayload>
          }
          aggregate: {
            args: Prisma.DeploymentExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeploymentExecution>
          }
          groupBy: {
            args: Prisma.DeploymentExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentExecutionCountAggregateOutputType> | number
          }
        }
      }
      DeploymentApproval: {
        payload: Prisma.$DeploymentApprovalPayload<ExtArgs>
        fields: Prisma.DeploymentApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeploymentApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeploymentApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>
          }
          findFirst: {
            args: Prisma.DeploymentApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeploymentApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>
          }
          findMany: {
            args: Prisma.DeploymentApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>[]
          }
          create: {
            args: Prisma.DeploymentApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>
          }
          createMany: {
            args: Prisma.DeploymentApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeploymentApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>[]
          }
          delete: {
            args: Prisma.DeploymentApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>
          }
          update: {
            args: Prisma.DeploymentApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>
          }
          deleteMany: {
            args: Prisma.DeploymentApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeploymentApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeploymentApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeploymentApprovalPayload>
          }
          aggregate: {
            args: Prisma.DeploymentApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeploymentApproval>
          }
          groupBy: {
            args: Prisma.DeploymentApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeploymentApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeploymentApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<DeploymentApprovalCountAggregateOutputType> | number
          }
        }
      }
      ApprovalRequest: {
        payload: Prisma.$ApprovalRequestPayload<ExtArgs>
        fields: Prisma.ApprovalRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          findFirst: {
            args: Prisma.ApprovalRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          findMany: {
            args: Prisma.ApprovalRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
          }
          create: {
            args: Prisma.ApprovalRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          createMany: {
            args: Prisma.ApprovalRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
          }
          delete: {
            args: Prisma.ApprovalRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          update: {
            args: Prisma.ApprovalRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          aggregate: {
            args: Prisma.ApprovalRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalRequest>
          }
          groupBy: {
            args: Prisma.ApprovalRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalRequestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projectMemberships: number
    ownedProjects: number
    testRuns: number
    deployments: number
    deploymentActions: number
    costTracking: number
    createdIntegrations: number
    createdPipelines: number
    executedPipelines: number
    createdDependencies: number
    createdUpdatePlans: number
    executedUpdatePlans: number
    createdDeploymentPlans: number
    executedDeployments: number
    deploymentApprovals: number
    requestedApprovals: number
    initiatedSyncs: number
    createdWebhooks: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectMemberships?: boolean | UserCountOutputTypeCountProjectMembershipsArgs
    ownedProjects?: boolean | UserCountOutputTypeCountOwnedProjectsArgs
    testRuns?: boolean | UserCountOutputTypeCountTestRunsArgs
    deployments?: boolean | UserCountOutputTypeCountDeploymentsArgs
    deploymentActions?: boolean | UserCountOutputTypeCountDeploymentActionsArgs
    costTracking?: boolean | UserCountOutputTypeCountCostTrackingArgs
    createdIntegrations?: boolean | UserCountOutputTypeCountCreatedIntegrationsArgs
    createdPipelines?: boolean | UserCountOutputTypeCountCreatedPipelinesArgs
    executedPipelines?: boolean | UserCountOutputTypeCountExecutedPipelinesArgs
    createdDependencies?: boolean | UserCountOutputTypeCountCreatedDependenciesArgs
    createdUpdatePlans?: boolean | UserCountOutputTypeCountCreatedUpdatePlansArgs
    executedUpdatePlans?: boolean | UserCountOutputTypeCountExecutedUpdatePlansArgs
    createdDeploymentPlans?: boolean | UserCountOutputTypeCountCreatedDeploymentPlansArgs
    executedDeployments?: boolean | UserCountOutputTypeCountExecutedDeploymentsArgs
    deploymentApprovals?: boolean | UserCountOutputTypeCountDeploymentApprovalsArgs
    requestedApprovals?: boolean | UserCountOutputTypeCountRequestedApprovalsArgs
    initiatedSyncs?: boolean | UserCountOutputTypeCountInitiatedSyncsArgs
    createdWebhooks?: boolean | UserCountOutputTypeCountCreatedWebhooksArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeploymentActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCostTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppIntegrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestPipelineWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExecutedPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUpdatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdatePlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExecutedUpdatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdatePlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDeploymentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExecutedDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentExecutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeploymentApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequestedApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInitiatedSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncOperationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookSubscriptionWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    prompts: number
    testRuns: number
    ApiKey: number
    environments: number
    costTracking: number
    appIntegrations: number
    testPipelines: number
    dependencies: number
    updatePlans: number
    deploymentPlans: number
    approvalRequests: number
    syncOperations: number
    webhookDeliveries: number
    webhookSubscriptions: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    prompts?: boolean | ProjectCountOutputTypeCountPromptsArgs
    testRuns?: boolean | ProjectCountOutputTypeCountTestRunsArgs
    ApiKey?: boolean | ProjectCountOutputTypeCountApiKeyArgs
    environments?: boolean | ProjectCountOutputTypeCountEnvironmentsArgs
    costTracking?: boolean | ProjectCountOutputTypeCountCostTrackingArgs
    appIntegrations?: boolean | ProjectCountOutputTypeCountAppIntegrationsArgs
    testPipelines?: boolean | ProjectCountOutputTypeCountTestPipelinesArgs
    dependencies?: boolean | ProjectCountOutputTypeCountDependenciesArgs
    updatePlans?: boolean | ProjectCountOutputTypeCountUpdatePlansArgs
    deploymentPlans?: boolean | ProjectCountOutputTypeCountDeploymentPlansArgs
    approvalRequests?: boolean | ProjectCountOutputTypeCountApprovalRequestsArgs
    syncOperations?: boolean | ProjectCountOutputTypeCountSyncOperationsArgs
    webhookDeliveries?: boolean | ProjectCountOutputTypeCountWebhookDeliveriesArgs
    webhookSubscriptions?: boolean | ProjectCountOutputTypeCountWebhookSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPromptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTestRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestRunWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountEnvironmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvironmentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCostTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostTrackingWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAppIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppIntegrationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTestPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestPipelineWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUpdatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdatePlanWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDeploymentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentPlanWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApprovalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSyncOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncOperationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWebhookDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWebhookSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookSubscriptionWhereInput
  }


  /**
   * Count Type PromptCountOutputType
   */

  export type PromptCountOutputType = {
    versions: number
    testRuns: number
    deployments: number
    impactAnalysis: number
    pipelineExecutions: number
    baselinePipelineExecutions: number
    deploymentPlans: number
    approvalRequests: number
  }

  export type PromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | PromptCountOutputTypeCountVersionsArgs
    testRuns?: boolean | PromptCountOutputTypeCountTestRunsArgs
    deployments?: boolean | PromptCountOutputTypeCountDeploymentsArgs
    impactAnalysis?: boolean | PromptCountOutputTypeCountImpactAnalysisArgs
    pipelineExecutions?: boolean | PromptCountOutputTypeCountPipelineExecutionsArgs
    baselinePipelineExecutions?: boolean | PromptCountOutputTypeCountBaselinePipelineExecutionsArgs
    deploymentPlans?: boolean | PromptCountOutputTypeCountDeploymentPlansArgs
    approvalRequests?: boolean | PromptCountOutputTypeCountApprovalRequestsArgs
  }

  // Custom InputTypes
  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCountOutputType
     */
    select?: PromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountTestRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestRunWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountImpactAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpactAnalysisWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountPipelineExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineExecutionWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountBaselinePipelineExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineExecutionWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountDeploymentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentPlanWhereInput
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountApprovalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }


  /**
   * Count Type TestRunCountOutputType
   */

  export type TestRunCountOutputType = {
    responses: number
    metrics: number
  }

  export type TestRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | TestRunCountOutputTypeCountResponsesArgs
    metrics?: boolean | TestRunCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * TestRunCountOutputType without action
   */
  export type TestRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRunCountOutputType
     */
    select?: TestRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestRunCountOutputType without action
   */
  export type TestRunCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResponseWhereInput
  }

  /**
   * TestRunCountOutputType without action
   */
  export type TestRunCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestMetricWhereInput
  }


  /**
   * Count Type WebhookSubscriptionCountOutputType
   */

  export type WebhookSubscriptionCountOutputType = {
    deliveries: number
    failedDeliveries: number
  }

  export type WebhookSubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookSubscriptionCountOutputTypeCountDeliveriesArgs
    failedDeliveries?: boolean | WebhookSubscriptionCountOutputTypeCountFailedDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookSubscriptionCountOutputType without action
   */
  export type WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscriptionCountOutputType
     */
    select?: WebhookSubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookSubscriptionCountOutputType without action
   */
  export type WebhookSubscriptionCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookSubscriptionCountOutputType without action
   */
  export type WebhookSubscriptionCountOutputTypeCountFailedDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Count Type EnvironmentCountOutputType
   */

  export type EnvironmentCountOutputType = {
    deployments: number
  }

  export type EnvironmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deployments?: boolean | EnvironmentCountOutputTypeCountDeploymentsArgs
  }

  // Custom InputTypes
  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentCountOutputType
     */
    select?: EnvironmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnvironmentCountOutputType without action
   */
  export type EnvironmentCountOutputTypeCountDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
  }


  /**
   * Count Type DeploymentCountOutputType
   */

  export type DeploymentCountOutputType = {
    history: number
    impactAnalysis: number
  }

  export type DeploymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | DeploymentCountOutputTypeCountHistoryArgs
    impactAnalysis?: boolean | DeploymentCountOutputTypeCountImpactAnalysisArgs
  }

  // Custom InputTypes
  /**
   * DeploymentCountOutputType without action
   */
  export type DeploymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentCountOutputType
     */
    select?: DeploymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeploymentCountOutputType without action
   */
  export type DeploymentCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentHistoryWhereInput
  }

  /**
   * DeploymentCountOutputType without action
   */
  export type DeploymentCountOutputTypeCountImpactAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpactAnalysisWhereInput
  }


  /**
   * Count Type ImpactAnalysisCountOutputType
   */

  export type ImpactAnalysisCountOutputType = {
    approvalRequests: number
  }

  export type ImpactAnalysisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvalRequests?: boolean | ImpactAnalysisCountOutputTypeCountApprovalRequestsArgs
  }

  // Custom InputTypes
  /**
   * ImpactAnalysisCountOutputType without action
   */
  export type ImpactAnalysisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysisCountOutputType
     */
    select?: ImpactAnalysisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImpactAnalysisCountOutputType without action
   */
  export type ImpactAnalysisCountOutputTypeCountApprovalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }


  /**
   * Count Type AppIntegrationCountOutputType
   */

  export type AppIntegrationCountOutputType = {
    syncOperations: number
  }

  export type AppIntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syncOperations?: boolean | AppIntegrationCountOutputTypeCountSyncOperationsArgs
  }

  // Custom InputTypes
  /**
   * AppIntegrationCountOutputType without action
   */
  export type AppIntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegrationCountOutputType
     */
    select?: AppIntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppIntegrationCountOutputType without action
   */
  export type AppIntegrationCountOutputTypeCountSyncOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncOperationWhereInput
  }


  /**
   * Count Type TestPipelineCountOutputType
   */

  export type TestPipelineCountOutputType = {
    stages: number
    executions: number
  }

  export type TestPipelineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | TestPipelineCountOutputTypeCountStagesArgs
    executions?: boolean | TestPipelineCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * TestPipelineCountOutputType without action
   */
  export type TestPipelineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipelineCountOutputType
     */
    select?: TestPipelineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestPipelineCountOutputType without action
   */
  export type TestPipelineCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineStageWhereInput
  }

  /**
   * TestPipelineCountOutputType without action
   */
  export type TestPipelineCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineExecutionWhereInput
  }


  /**
   * Count Type DeploymentPlanCountOutputType
   */

  export type DeploymentPlanCountOutputType = {
    executions: number
    approvals: number
  }

  export type DeploymentPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | DeploymentPlanCountOutputTypeCountExecutionsArgs
    approvals?: boolean | DeploymentPlanCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * DeploymentPlanCountOutputType without action
   */
  export type DeploymentPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlanCountOutputType
     */
    select?: DeploymentPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeploymentPlanCountOutputType without action
   */
  export type DeploymentPlanCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentExecutionWhereInput
  }

  /**
   * DeploymentPlanCountOutputType without action
   */
  export type DeploymentPlanCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentApprovalWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    avatar: string | null
    passwordHash: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    testRuns?: boolean | User$testRunsArgs<ExtArgs>
    deployments?: boolean | User$deploymentsArgs<ExtArgs>
    deploymentActions?: boolean | User$deploymentActionsArgs<ExtArgs>
    costTracking?: boolean | User$costTrackingArgs<ExtArgs>
    billing?: boolean | User$billingArgs<ExtArgs>
    createdIntegrations?: boolean | User$createdIntegrationsArgs<ExtArgs>
    createdPipelines?: boolean | User$createdPipelinesArgs<ExtArgs>
    executedPipelines?: boolean | User$executedPipelinesArgs<ExtArgs>
    createdDependencies?: boolean | User$createdDependenciesArgs<ExtArgs>
    createdUpdatePlans?: boolean | User$createdUpdatePlansArgs<ExtArgs>
    executedUpdatePlans?: boolean | User$executedUpdatePlansArgs<ExtArgs>
    createdDeploymentPlans?: boolean | User$createdDeploymentPlansArgs<ExtArgs>
    executedDeployments?: boolean | User$executedDeploymentsArgs<ExtArgs>
    deploymentApprovals?: boolean | User$deploymentApprovalsArgs<ExtArgs>
    requestedApprovals?: boolean | User$requestedApprovalsArgs<ExtArgs>
    initiatedSyncs?: boolean | User$initiatedSyncsArgs<ExtArgs>
    createdWebhooks?: boolean | User$createdWebhooksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    testRuns?: boolean | User$testRunsArgs<ExtArgs>
    deployments?: boolean | User$deploymentsArgs<ExtArgs>
    deploymentActions?: boolean | User$deploymentActionsArgs<ExtArgs>
    costTracking?: boolean | User$costTrackingArgs<ExtArgs>
    billing?: boolean | User$billingArgs<ExtArgs>
    createdIntegrations?: boolean | User$createdIntegrationsArgs<ExtArgs>
    createdPipelines?: boolean | User$createdPipelinesArgs<ExtArgs>
    executedPipelines?: boolean | User$executedPipelinesArgs<ExtArgs>
    createdDependencies?: boolean | User$createdDependenciesArgs<ExtArgs>
    createdUpdatePlans?: boolean | User$createdUpdatePlansArgs<ExtArgs>
    executedUpdatePlans?: boolean | User$executedUpdatePlansArgs<ExtArgs>
    createdDeploymentPlans?: boolean | User$createdDeploymentPlansArgs<ExtArgs>
    executedDeployments?: boolean | User$executedDeploymentsArgs<ExtArgs>
    deploymentApprovals?: boolean | User$deploymentApprovalsArgs<ExtArgs>
    requestedApprovals?: boolean | User$requestedApprovalsArgs<ExtArgs>
    initiatedSyncs?: boolean | User$initiatedSyncsArgs<ExtArgs>
    createdWebhooks?: boolean | User$createdWebhooksArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projectMemberships: Prisma.$ProjectMemberPayload<ExtArgs>[]
      ownedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      testRuns: Prisma.$TestRunPayload<ExtArgs>[]
      deployments: Prisma.$DeploymentPayload<ExtArgs>[]
      deploymentActions: Prisma.$DeploymentHistoryPayload<ExtArgs>[]
      costTracking: Prisma.$CostTrackingPayload<ExtArgs>[]
      billing: Prisma.$UserBillingPayload<ExtArgs> | null
      createdIntegrations: Prisma.$AppIntegrationPayload<ExtArgs>[]
      createdPipelines: Prisma.$TestPipelinePayload<ExtArgs>[]
      executedPipelines: Prisma.$PipelineExecutionPayload<ExtArgs>[]
      createdDependencies: Prisma.$DependencyPayload<ExtArgs>[]
      createdUpdatePlans: Prisma.$UpdatePlanPayload<ExtArgs>[]
      executedUpdatePlans: Prisma.$UpdatePlanPayload<ExtArgs>[]
      createdDeploymentPlans: Prisma.$DeploymentPlanPayload<ExtArgs>[]
      executedDeployments: Prisma.$DeploymentExecutionPayload<ExtArgs>[]
      deploymentApprovals: Prisma.$DeploymentApprovalPayload<ExtArgs>[]
      requestedApprovals: Prisma.$ApprovalRequestPayload<ExtArgs>[]
      initiatedSyncs: Prisma.$SyncOperationPayload<ExtArgs>[]
      createdWebhooks: Prisma.$WebhookSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      avatar: string | null
      passwordHash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectMemberships<T extends User$projectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany"> | Null>
    ownedProjects<T extends User$ownedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    testRuns<T extends User$testRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$testRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findMany"> | Null>
    deployments<T extends User$deploymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$deploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany"> | Null>
    deploymentActions<T extends User$deploymentActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$deploymentActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    costTracking<T extends User$costTrackingArgs<ExtArgs> = {}>(args?: Subset<T, User$costTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    billing<T extends User$billingArgs<ExtArgs> = {}>(args?: Subset<T, User$billingArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdIntegrations<T extends User$createdIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    createdPipelines<T extends User$createdPipelinesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findMany"> | Null>
    executedPipelines<T extends User$executedPipelinesArgs<ExtArgs> = {}>(args?: Subset<T, User$executedPipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    createdDependencies<T extends User$createdDependenciesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdDependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany"> | Null>
    createdUpdatePlans<T extends User$createdUpdatePlansArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUpdatePlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findMany"> | Null>
    executedUpdatePlans<T extends User$executedUpdatePlansArgs<ExtArgs> = {}>(args?: Subset<T, User$executedUpdatePlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findMany"> | Null>
    createdDeploymentPlans<T extends User$createdDeploymentPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$createdDeploymentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findMany"> | Null>
    executedDeployments<T extends User$executedDeploymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$executedDeploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    deploymentApprovals<T extends User$deploymentApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$deploymentApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    requestedApprovals<T extends User$requestedApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$requestedApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    initiatedSyncs<T extends User$initiatedSyncsArgs<ExtArgs> = {}>(args?: Subset<T, User$initiatedSyncsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findMany"> | Null>
    createdWebhooks<T extends User$createdWebhooksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdWebhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.projectMemberships
   */
  export type User$projectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.ownedProjects
   */
  export type User$ownedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.testRuns
   */
  export type User$testRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    where?: TestRunWhereInput
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    cursor?: TestRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestRunScalarFieldEnum | TestRunScalarFieldEnum[]
  }

  /**
   * User.deployments
   */
  export type User$deploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    cursor?: DeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * User.deploymentActions
   */
  export type User$deploymentActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    where?: DeploymentHistoryWhereInput
    orderBy?: DeploymentHistoryOrderByWithRelationInput | DeploymentHistoryOrderByWithRelationInput[]
    cursor?: DeploymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentHistoryScalarFieldEnum | DeploymentHistoryScalarFieldEnum[]
  }

  /**
   * User.costTracking
   */
  export type User$costTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    where?: CostTrackingWhereInput
    orderBy?: CostTrackingOrderByWithRelationInput | CostTrackingOrderByWithRelationInput[]
    cursor?: CostTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostTrackingScalarFieldEnum | CostTrackingScalarFieldEnum[]
  }

  /**
   * User.billing
   */
  export type User$billingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    where?: UserBillingWhereInput
  }

  /**
   * User.createdIntegrations
   */
  export type User$createdIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    where?: AppIntegrationWhereInput
    orderBy?: AppIntegrationOrderByWithRelationInput | AppIntegrationOrderByWithRelationInput[]
    cursor?: AppIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppIntegrationScalarFieldEnum | AppIntegrationScalarFieldEnum[]
  }

  /**
   * User.createdPipelines
   */
  export type User$createdPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    where?: TestPipelineWhereInput
    orderBy?: TestPipelineOrderByWithRelationInput | TestPipelineOrderByWithRelationInput[]
    cursor?: TestPipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestPipelineScalarFieldEnum | TestPipelineScalarFieldEnum[]
  }

  /**
   * User.executedPipelines
   */
  export type User$executedPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    where?: PipelineExecutionWhereInput
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    cursor?: PipelineExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * User.createdDependencies
   */
  export type User$createdDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    cursor?: DependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * User.createdUpdatePlans
   */
  export type User$createdUpdatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    where?: UpdatePlanWhereInput
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    cursor?: UpdatePlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdatePlanScalarFieldEnum | UpdatePlanScalarFieldEnum[]
  }

  /**
   * User.executedUpdatePlans
   */
  export type User$executedUpdatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    where?: UpdatePlanWhereInput
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    cursor?: UpdatePlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdatePlanScalarFieldEnum | UpdatePlanScalarFieldEnum[]
  }

  /**
   * User.createdDeploymentPlans
   */
  export type User$createdDeploymentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    where?: DeploymentPlanWhereInput
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    cursor?: DeploymentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentPlanScalarFieldEnum | DeploymentPlanScalarFieldEnum[]
  }

  /**
   * User.executedDeployments
   */
  export type User$executedDeploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    where?: DeploymentExecutionWhereInput
    orderBy?: DeploymentExecutionOrderByWithRelationInput | DeploymentExecutionOrderByWithRelationInput[]
    cursor?: DeploymentExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentExecutionScalarFieldEnum | DeploymentExecutionScalarFieldEnum[]
  }

  /**
   * User.deploymentApprovals
   */
  export type User$deploymentApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    where?: DeploymentApprovalWhereInput
    orderBy?: DeploymentApprovalOrderByWithRelationInput | DeploymentApprovalOrderByWithRelationInput[]
    cursor?: DeploymentApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentApprovalScalarFieldEnum | DeploymentApprovalScalarFieldEnum[]
  }

  /**
   * User.requestedApprovals
   */
  export type User$requestedApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * User.initiatedSyncs
   */
  export type User$initiatedSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    where?: SyncOperationWhereInput
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    cursor?: SyncOperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[]
  }

  /**
   * User.createdWebhooks
   */
  export type User$createdWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    where?: WebhookSubscriptionWhereInput
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    cursor?: WebhookSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    settings: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    settings: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    settings: number
    createdAt: number
    updatedAt: number
    ownerId: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    settings: string | null
    createdAt: Date
    updatedAt: Date
    ownerId: string
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    prompts?: boolean | Project$promptsArgs<ExtArgs>
    testRuns?: boolean | Project$testRunsArgs<ExtArgs>
    ApiKey?: boolean | Project$ApiKeyArgs<ExtArgs>
    environments?: boolean | Project$environmentsArgs<ExtArgs>
    costTracking?: boolean | Project$costTrackingArgs<ExtArgs>
    appIntegrations?: boolean | Project$appIntegrationsArgs<ExtArgs>
    testPipelines?: boolean | Project$testPipelinesArgs<ExtArgs>
    dependencies?: boolean | Project$dependenciesArgs<ExtArgs>
    updatePlans?: boolean | Project$updatePlansArgs<ExtArgs>
    deploymentPlans?: boolean | Project$deploymentPlansArgs<ExtArgs>
    approvalRequests?: boolean | Project$approvalRequestsArgs<ExtArgs>
    syncOperations?: boolean | Project$syncOperationsArgs<ExtArgs>
    webhookDeliveries?: boolean | Project$webhookDeliveriesArgs<ExtArgs>
    webhookSubscriptions?: boolean | Project$webhookSubscriptionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    prompts?: boolean | Project$promptsArgs<ExtArgs>
    testRuns?: boolean | Project$testRunsArgs<ExtArgs>
    ApiKey?: boolean | Project$ApiKeyArgs<ExtArgs>
    environments?: boolean | Project$environmentsArgs<ExtArgs>
    costTracking?: boolean | Project$costTrackingArgs<ExtArgs>
    appIntegrations?: boolean | Project$appIntegrationsArgs<ExtArgs>
    testPipelines?: boolean | Project$testPipelinesArgs<ExtArgs>
    dependencies?: boolean | Project$dependenciesArgs<ExtArgs>
    updatePlans?: boolean | Project$updatePlansArgs<ExtArgs>
    deploymentPlans?: boolean | Project$deploymentPlansArgs<ExtArgs>
    approvalRequests?: boolean | Project$approvalRequestsArgs<ExtArgs>
    syncOperations?: boolean | Project$syncOperationsArgs<ExtArgs>
    webhookDeliveries?: boolean | Project$webhookDeliveriesArgs<ExtArgs>
    webhookSubscriptions?: boolean | Project$webhookSubscriptionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      prompts: Prisma.$PromptPayload<ExtArgs>[]
      testRuns: Prisma.$TestRunPayload<ExtArgs>[]
      ApiKey: Prisma.$ApiKeyPayload<ExtArgs>[]
      environments: Prisma.$EnvironmentPayload<ExtArgs>[]
      costTracking: Prisma.$CostTrackingPayload<ExtArgs>[]
      appIntegrations: Prisma.$AppIntegrationPayload<ExtArgs>[]
      testPipelines: Prisma.$TestPipelinePayload<ExtArgs>[]
      dependencies: Prisma.$DependencyPayload<ExtArgs>[]
      updatePlans: Prisma.$UpdatePlanPayload<ExtArgs>[]
      deploymentPlans: Prisma.$DeploymentPlanPayload<ExtArgs>[]
      approvalRequests: Prisma.$ApprovalRequestPayload<ExtArgs>[]
      syncOperations: Prisma.$SyncOperationPayload<ExtArgs>[]
      webhookDeliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
      webhookSubscriptions: Prisma.$WebhookSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      settings: string | null
      createdAt: Date
      updatedAt: Date
      ownerId: string
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany"> | Null>
    prompts<T extends Project$promptsArgs<ExtArgs> = {}>(args?: Subset<T, Project$promptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany"> | Null>
    testRuns<T extends Project$testRunsArgs<ExtArgs> = {}>(args?: Subset<T, Project$testRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findMany"> | Null>
    ApiKey<T extends Project$ApiKeyArgs<ExtArgs> = {}>(args?: Subset<T, Project$ApiKeyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    environments<T extends Project$environmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$environmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findMany"> | Null>
    costTracking<T extends Project$costTrackingArgs<ExtArgs> = {}>(args?: Subset<T, Project$costTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findMany"> | Null>
    appIntegrations<T extends Project$appIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$appIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    testPipelines<T extends Project$testPipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Project$testPipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findMany"> | Null>
    dependencies<T extends Project$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Project$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany"> | Null>
    updatePlans<T extends Project$updatePlansArgs<ExtArgs> = {}>(args?: Subset<T, Project$updatePlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findMany"> | Null>
    deploymentPlans<T extends Project$deploymentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Project$deploymentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findMany"> | Null>
    approvalRequests<T extends Project$approvalRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Project$approvalRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    syncOperations<T extends Project$syncOperationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$syncOperationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findMany"> | Null>
    webhookDeliveries<T extends Project$webhookDeliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$webhookDeliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    webhookSubscriptions<T extends Project$webhookSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$webhookSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly settings: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly ownerId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.prompts
   */
  export type Project$promptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    cursor?: PromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Project.testRuns
   */
  export type Project$testRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    where?: TestRunWhereInput
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    cursor?: TestRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestRunScalarFieldEnum | TestRunScalarFieldEnum[]
  }

  /**
   * Project.ApiKey
   */
  export type Project$ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Project.environments
   */
  export type Project$environmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    where?: EnvironmentWhereInput
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    cursor?: EnvironmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Project.costTracking
   */
  export type Project$costTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    where?: CostTrackingWhereInput
    orderBy?: CostTrackingOrderByWithRelationInput | CostTrackingOrderByWithRelationInput[]
    cursor?: CostTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostTrackingScalarFieldEnum | CostTrackingScalarFieldEnum[]
  }

  /**
   * Project.appIntegrations
   */
  export type Project$appIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    where?: AppIntegrationWhereInput
    orderBy?: AppIntegrationOrderByWithRelationInput | AppIntegrationOrderByWithRelationInput[]
    cursor?: AppIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppIntegrationScalarFieldEnum | AppIntegrationScalarFieldEnum[]
  }

  /**
   * Project.testPipelines
   */
  export type Project$testPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    where?: TestPipelineWhereInput
    orderBy?: TestPipelineOrderByWithRelationInput | TestPipelineOrderByWithRelationInput[]
    cursor?: TestPipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestPipelineScalarFieldEnum | TestPipelineScalarFieldEnum[]
  }

  /**
   * Project.dependencies
   */
  export type Project$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    cursor?: DependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Project.updatePlans
   */
  export type Project$updatePlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    where?: UpdatePlanWhereInput
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    cursor?: UpdatePlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdatePlanScalarFieldEnum | UpdatePlanScalarFieldEnum[]
  }

  /**
   * Project.deploymentPlans
   */
  export type Project$deploymentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    where?: DeploymentPlanWhereInput
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    cursor?: DeploymentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentPlanScalarFieldEnum | DeploymentPlanScalarFieldEnum[]
  }

  /**
   * Project.approvalRequests
   */
  export type Project$approvalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * Project.syncOperations
   */
  export type Project$syncOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    where?: SyncOperationWhereInput
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    cursor?: SyncOperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[]
  }

  /**
   * Project.webhookDeliveries
   */
  export type Project$webhookDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Project.webhookSubscriptions
   */
  export type Project$webhookSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    where?: WebhookSubscriptionWhereInput
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    cursor?: WebhookSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    role: number
    createdAt: number
    updatedAt: number
    projectId: number
    userId: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    role: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    userId: string
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
  }

  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      userId: string
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */ 
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'String'>
    readonly createdAt: FieldRef<"ProjectMember", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMember", 'DateTime'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model Prompt
   */

  export type AggregatePrompt = {
    _count: PromptCountAggregateOutputType | null
    _avg: PromptAvgAggregateOutputType | null
    _sum: PromptSumAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  export type PromptAvgAggregateOutputType = {
    version: number | null
  }

  export type PromptSumAggregateOutputType = {
    version: number | null
  }

  export type PromptMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    content: string | null
    version: number | null
    isArchived: boolean | null
    tags: string | null
    metadata: string | null
    outputSchema: string | null
    outputFormat: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    parentId: string | null
  }

  export type PromptMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    content: string | null
    version: number | null
    isArchived: boolean | null
    tags: string | null
    metadata: string | null
    outputSchema: string | null
    outputFormat: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    parentId: string | null
  }

  export type PromptCountAggregateOutputType = {
    id: number
    name: number
    description: number
    content: number
    version: number
    isArchived: number
    tags: number
    metadata: number
    outputSchema: number
    outputFormat: number
    createdAt: number
    updatedAt: number
    projectId: number
    parentId: number
    _all: number
  }


  export type PromptAvgAggregateInputType = {
    version?: true
  }

  export type PromptSumAggregateInputType = {
    version?: true
  }

  export type PromptMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    version?: true
    isArchived?: true
    tags?: true
    metadata?: true
    outputSchema?: true
    outputFormat?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    parentId?: true
  }

  export type PromptMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    version?: true
    isArchived?: true
    tags?: true
    metadata?: true
    outputSchema?: true
    outputFormat?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    parentId?: true
  }

  export type PromptCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    version?: true
    isArchived?: true
    tags?: true
    metadata?: true
    outputSchema?: true
    outputFormat?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    parentId?: true
    _all?: true
  }

  export type PromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompt to aggregate.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prompts
    **/
    _count?: true | PromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptMaxAggregateInputType
  }

  export type GetPromptAggregateType<T extends PromptAggregateArgs> = {
        [P in keyof T & keyof AggregatePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrompt[P]>
      : GetScalarType<T[P], AggregatePrompt[P]>
  }




  export type PromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithAggregationInput | PromptOrderByWithAggregationInput[]
    by: PromptScalarFieldEnum[] | PromptScalarFieldEnum
    having?: PromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptCountAggregateInputType | true
    _avg?: PromptAvgAggregateInputType
    _sum?: PromptSumAggregateInputType
    _min?: PromptMinAggregateInputType
    _max?: PromptMaxAggregateInputType
  }

  export type PromptGroupByOutputType = {
    id: string
    name: string
    description: string | null
    content: string
    version: number
    isArchived: boolean
    tags: string
    metadata: string | null
    outputSchema: string | null
    outputFormat: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    parentId: string | null
    _count: PromptCountAggregateOutputType | null
    _avg: PromptAvgAggregateOutputType | null
    _sum: PromptSumAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  type GetPromptGroupByPayload<T extends PromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptGroupByOutputType[P]>
            : GetScalarType<T[P], PromptGroupByOutputType[P]>
        }
      >
    >


  export type PromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    version?: boolean
    isArchived?: boolean
    tags?: boolean
    metadata?: boolean
    outputSchema?: boolean
    outputFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    parentId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Prompt$parentArgs<ExtArgs>
    versions?: boolean | Prompt$versionsArgs<ExtArgs>
    testRuns?: boolean | Prompt$testRunsArgs<ExtArgs>
    deployments?: boolean | Prompt$deploymentsArgs<ExtArgs>
    impactAnalysis?: boolean | Prompt$impactAnalysisArgs<ExtArgs>
    pipelineExecutions?: boolean | Prompt$pipelineExecutionsArgs<ExtArgs>
    baselinePipelineExecutions?: boolean | Prompt$baselinePipelineExecutionsArgs<ExtArgs>
    deploymentPlans?: boolean | Prompt$deploymentPlansArgs<ExtArgs>
    approvalRequests?: boolean | Prompt$approvalRequestsArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    version?: boolean
    isArchived?: boolean
    tags?: boolean
    metadata?: boolean
    outputSchema?: boolean
    outputFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    parentId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Prompt$parentArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    version?: boolean
    isArchived?: boolean
    tags?: boolean
    metadata?: boolean
    outputSchema?: boolean
    outputFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    parentId?: boolean
  }

  export type PromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Prompt$parentArgs<ExtArgs>
    versions?: boolean | Prompt$versionsArgs<ExtArgs>
    testRuns?: boolean | Prompt$testRunsArgs<ExtArgs>
    deployments?: boolean | Prompt$deploymentsArgs<ExtArgs>
    impactAnalysis?: boolean | Prompt$impactAnalysisArgs<ExtArgs>
    pipelineExecutions?: boolean | Prompt$pipelineExecutionsArgs<ExtArgs>
    baselinePipelineExecutions?: boolean | Prompt$baselinePipelineExecutionsArgs<ExtArgs>
    deploymentPlans?: boolean | Prompt$deploymentPlansArgs<ExtArgs>
    approvalRequests?: boolean | Prompt$approvalRequestsArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Prompt$parentArgs<ExtArgs>
  }

  export type $PromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prompt"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      parent: Prisma.$PromptPayload<ExtArgs> | null
      versions: Prisma.$PromptPayload<ExtArgs>[]
      testRuns: Prisma.$TestRunPayload<ExtArgs>[]
      deployments: Prisma.$DeploymentPayload<ExtArgs>[]
      impactAnalysis: Prisma.$ImpactAnalysisPayload<ExtArgs>[]
      pipelineExecutions: Prisma.$PipelineExecutionPayload<ExtArgs>[]
      baselinePipelineExecutions: Prisma.$PipelineExecutionPayload<ExtArgs>[]
      deploymentPlans: Prisma.$DeploymentPlanPayload<ExtArgs>[]
      approvalRequests: Prisma.$ApprovalRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      content: string
      version: number
      isArchived: boolean
      tags: string
      metadata: string | null
      outputSchema: string | null
      outputFormat: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      parentId: string | null
    }, ExtArgs["result"]["prompt"]>
    composites: {}
  }

  type PromptGetPayload<S extends boolean | null | undefined | PromptDefaultArgs> = $Result.GetResult<Prisma.$PromptPayload, S>

  type PromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromptCountAggregateInputType | true
    }

  export interface PromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prompt'], meta: { name: 'Prompt' } }
    /**
     * Find zero or one Prompt that matches the filter.
     * @param {PromptFindUniqueArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptFindUniqueArgs>(args: SelectSubset<T, PromptFindUniqueArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromptFindUniqueOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptFindFirstArgs>(args?: SelectSubset<T, PromptFindFirstArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prompts
     * const prompts = await prisma.prompt.findMany()
     * 
     * // Get first 10 Prompts
     * const prompts = await prisma.prompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptWithIdOnly = await prisma.prompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptFindManyArgs>(args?: SelectSubset<T, PromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prompt.
     * @param {PromptCreateArgs} args - Arguments to create a Prompt.
     * @example
     * // Create one Prompt
     * const Prompt = await prisma.prompt.create({
     *   data: {
     *     // ... data to create a Prompt
     *   }
     * })
     * 
     */
    create<T extends PromptCreateArgs>(args: SelectSubset<T, PromptCreateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prompts.
     * @param {PromptCreateManyArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptCreateManyArgs>(args?: SelectSubset<T, PromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prompts and returns the data saved in the database.
     * @param {PromptCreateManyAndReturnArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prompts and only return the `id`
     * const promptWithIdOnly = await prisma.prompt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prompt.
     * @param {PromptDeleteArgs} args - Arguments to delete one Prompt.
     * @example
     * // Delete one Prompt
     * const Prompt = await prisma.prompt.delete({
     *   where: {
     *     // ... filter to delete one Prompt
     *   }
     * })
     * 
     */
    delete<T extends PromptDeleteArgs>(args: SelectSubset<T, PromptDeleteArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prompt.
     * @param {PromptUpdateArgs} args - Arguments to update one Prompt.
     * @example
     * // Update one Prompt
     * const prompt = await prisma.prompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptUpdateArgs>(args: SelectSubset<T, PromptUpdateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prompts.
     * @param {PromptDeleteManyArgs} args - Arguments to filter Prompts to delete.
     * @example
     * // Delete a few Prompts
     * const { count } = await prisma.prompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptDeleteManyArgs>(args?: SelectSubset<T, PromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prompts
     * const prompt = await prisma.prompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptUpdateManyArgs>(args: SelectSubset<T, PromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prompt.
     * @param {PromptUpsertArgs} args - Arguments to update or create a Prompt.
     * @example
     * // Update or create a Prompt
     * const prompt = await prisma.prompt.upsert({
     *   create: {
     *     // ... data to create a Prompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prompt we want to update
     *   }
     * })
     */
    upsert<T extends PromptUpsertArgs>(args: SelectSubset<T, PromptUpsertArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCountArgs} args - Arguments to filter Prompts to count.
     * @example
     * // Count the number of Prompts
     * const count = await prisma.prompt.count({
     *   where: {
     *     // ... the filter for the Prompts we want to count
     *   }
     * })
    **/
    count<T extends PromptCountArgs>(
      args?: Subset<T, PromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptAggregateArgs>(args: Subset<T, PromptAggregateArgs>): Prisma.PrismaPromise<GetPromptAggregateType<T>>

    /**
     * Group by Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptGroupByArgs['orderBy'] }
        : { orderBy?: PromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prompt model
   */
  readonly fields: PromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Prompt$parentArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$parentArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    versions<T extends Prompt$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany"> | Null>
    testRuns<T extends Prompt$testRunsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$testRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findMany"> | Null>
    deployments<T extends Prompt$deploymentsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$deploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany"> | Null>
    impactAnalysis<T extends Prompt$impactAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$impactAnalysisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    pipelineExecutions<T extends Prompt$pipelineExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$pipelineExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    baselinePipelineExecutions<T extends Prompt$baselinePipelineExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$baselinePipelineExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    deploymentPlans<T extends Prompt$deploymentPlansArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$deploymentPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findMany"> | Null>
    approvalRequests<T extends Prompt$approvalRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$approvalRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prompt model
   */ 
  interface PromptFieldRefs {
    readonly id: FieldRef<"Prompt", 'String'>
    readonly name: FieldRef<"Prompt", 'String'>
    readonly description: FieldRef<"Prompt", 'String'>
    readonly content: FieldRef<"Prompt", 'String'>
    readonly version: FieldRef<"Prompt", 'Int'>
    readonly isArchived: FieldRef<"Prompt", 'Boolean'>
    readonly tags: FieldRef<"Prompt", 'String'>
    readonly metadata: FieldRef<"Prompt", 'String'>
    readonly outputSchema: FieldRef<"Prompt", 'String'>
    readonly outputFormat: FieldRef<"Prompt", 'String'>
    readonly createdAt: FieldRef<"Prompt", 'DateTime'>
    readonly updatedAt: FieldRef<"Prompt", 'DateTime'>
    readonly projectId: FieldRef<"Prompt", 'String'>
    readonly parentId: FieldRef<"Prompt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prompt findUnique
   */
  export type PromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt findUniqueOrThrow
   */
  export type PromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt findFirst
   */
  export type PromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt findFirstOrThrow
   */
  export type PromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt findMany
   */
  export type PromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompts to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt create
   */
  export type PromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to create a Prompt.
     */
    data: XOR<PromptCreateInput, PromptUncheckedCreateInput>
  }

  /**
   * Prompt createMany
   */
  export type PromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
  }

  /**
   * Prompt createManyAndReturn
   */
  export type PromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prompt update
   */
  export type PromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to update a Prompt.
     */
    data: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    /**
     * Choose, which Prompt to update.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt updateMany
   */
  export type PromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prompts.
     */
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyInput>
    /**
     * Filter which Prompts to update
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt upsert
   */
  export type PromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The filter to search for the Prompt to update in case it exists.
     */
    where: PromptWhereUniqueInput
    /**
     * In case the Prompt found by the `where` argument doesn't exist, create a new Prompt with this data.
     */
    create: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    /**
     * In case the Prompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
  }

  /**
   * Prompt delete
   */
  export type PromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter which Prompt to delete.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt deleteMany
   */
  export type PromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompts to delete
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt.parent
   */
  export type Prompt$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
  }

  /**
   * Prompt.versions
   */
  export type Prompt$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    cursor?: PromptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt.testRuns
   */
  export type Prompt$testRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    where?: TestRunWhereInput
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    cursor?: TestRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestRunScalarFieldEnum | TestRunScalarFieldEnum[]
  }

  /**
   * Prompt.deployments
   */
  export type Prompt$deploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    cursor?: DeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Prompt.impactAnalysis
   */
  export type Prompt$impactAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    where?: ImpactAnalysisWhereInput
    orderBy?: ImpactAnalysisOrderByWithRelationInput | ImpactAnalysisOrderByWithRelationInput[]
    cursor?: ImpactAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImpactAnalysisScalarFieldEnum | ImpactAnalysisScalarFieldEnum[]
  }

  /**
   * Prompt.pipelineExecutions
   */
  export type Prompt$pipelineExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    where?: PipelineExecutionWhereInput
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    cursor?: PipelineExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * Prompt.baselinePipelineExecutions
   */
  export type Prompt$baselinePipelineExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    where?: PipelineExecutionWhereInput
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    cursor?: PipelineExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * Prompt.deploymentPlans
   */
  export type Prompt$deploymentPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    where?: DeploymentPlanWhereInput
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    cursor?: DeploymentPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentPlanScalarFieldEnum | DeploymentPlanScalarFieldEnum[]
  }

  /**
   * Prompt.approvalRequests
   */
  export type Prompt$approvalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * Prompt without action
   */
  export type PromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
  }


  /**
   * Model TestRun
   */

  export type AggregateTestRun = {
    _count: TestRunCountAggregateOutputType | null
    _min: TestRunMinAggregateOutputType | null
    _max: TestRunMaxAggregateOutputType | null
  }

  export type TestRunMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    config: string | null
    metadata: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
    promptId: string | null
  }

  export type TestRunMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    config: string | null
    metadata: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
    promptId: string | null
  }

  export type TestRunCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    config: number
    metadata: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    projectId: number
    userId: number
    promptId: number
    _all: number
  }


  export type TestRunMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    config?: true
    metadata?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    promptId?: true
  }

  export type TestRunMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    config?: true
    metadata?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    promptId?: true
  }

  export type TestRunCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    config?: true
    metadata?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    promptId?: true
    _all?: true
  }

  export type TestRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestRun to aggregate.
     */
    where?: TestRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestRuns to fetch.
     */
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestRuns
    **/
    _count?: true | TestRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestRunMaxAggregateInputType
  }

  export type GetTestRunAggregateType<T extends TestRunAggregateArgs> = {
        [P in keyof T & keyof AggregateTestRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestRun[P]>
      : GetScalarType<T[P], AggregateTestRun[P]>
  }




  export type TestRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestRunWhereInput
    orderBy?: TestRunOrderByWithAggregationInput | TestRunOrderByWithAggregationInput[]
    by: TestRunScalarFieldEnum[] | TestRunScalarFieldEnum
    having?: TestRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestRunCountAggregateInputType | true
    _min?: TestRunMinAggregateInputType
    _max?: TestRunMaxAggregateInputType
  }

  export type TestRunGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    config: string
    metadata: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    userId: string
    promptId: string
    _count: TestRunCountAggregateOutputType | null
    _min: TestRunMinAggregateOutputType | null
    _max: TestRunMaxAggregateOutputType | null
  }

  type GetTestRunGroupByPayload<T extends TestRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestRunGroupByOutputType[P]>
            : GetScalarType<T[P], TestRunGroupByOutputType[P]>
        }
      >
    >


  export type TestRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    config?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    promptId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    responses?: boolean | TestRun$responsesArgs<ExtArgs>
    metrics?: boolean | TestRun$metricsArgs<ExtArgs>
    _count?: boolean | TestRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testRun"]>

  export type TestRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    config?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    promptId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testRun"]>

  export type TestRunSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    config?: boolean
    metadata?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    promptId?: boolean
  }

  export type TestRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    responses?: boolean | TestRun$responsesArgs<ExtArgs>
    metrics?: boolean | TestRun$metricsArgs<ExtArgs>
    _count?: boolean | TestRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
  }

  export type $TestRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestRun"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      prompt: Prisma.$PromptPayload<ExtArgs>
      responses: Prisma.$TestResponsePayload<ExtArgs>[]
      metrics: Prisma.$TestMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      config: string
      metadata: string | null
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      userId: string
      promptId: string
    }, ExtArgs["result"]["testRun"]>
    composites: {}
  }

  type TestRunGetPayload<S extends boolean | null | undefined | TestRunDefaultArgs> = $Result.GetResult<Prisma.$TestRunPayload, S>

  type TestRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestRunCountAggregateInputType | true
    }

  export interface TestRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestRun'], meta: { name: 'TestRun' } }
    /**
     * Find zero or one TestRun that matches the filter.
     * @param {TestRunFindUniqueArgs} args - Arguments to find a TestRun
     * @example
     * // Get one TestRun
     * const testRun = await prisma.testRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestRunFindUniqueArgs>(args: SelectSubset<T, TestRunFindUniqueArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestRunFindUniqueOrThrowArgs} args - Arguments to find a TestRun
     * @example
     * // Get one TestRun
     * const testRun = await prisma.testRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestRunFindUniqueOrThrowArgs>(args: SelectSubset<T, TestRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunFindFirstArgs} args - Arguments to find a TestRun
     * @example
     * // Get one TestRun
     * const testRun = await prisma.testRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestRunFindFirstArgs>(args?: SelectSubset<T, TestRunFindFirstArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunFindFirstOrThrowArgs} args - Arguments to find a TestRun
     * @example
     * // Get one TestRun
     * const testRun = await prisma.testRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestRunFindFirstOrThrowArgs>(args?: SelectSubset<T, TestRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestRuns
     * const testRuns = await prisma.testRun.findMany()
     * 
     * // Get first 10 TestRuns
     * const testRuns = await prisma.testRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testRunWithIdOnly = await prisma.testRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestRunFindManyArgs>(args?: SelectSubset<T, TestRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestRun.
     * @param {TestRunCreateArgs} args - Arguments to create a TestRun.
     * @example
     * // Create one TestRun
     * const TestRun = await prisma.testRun.create({
     *   data: {
     *     // ... data to create a TestRun
     *   }
     * })
     * 
     */
    create<T extends TestRunCreateArgs>(args: SelectSubset<T, TestRunCreateArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestRuns.
     * @param {TestRunCreateManyArgs} args - Arguments to create many TestRuns.
     * @example
     * // Create many TestRuns
     * const testRun = await prisma.testRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestRunCreateManyArgs>(args?: SelectSubset<T, TestRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestRuns and returns the data saved in the database.
     * @param {TestRunCreateManyAndReturnArgs} args - Arguments to create many TestRuns.
     * @example
     * // Create many TestRuns
     * const testRun = await prisma.testRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestRuns and only return the `id`
     * const testRunWithIdOnly = await prisma.testRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestRunCreateManyAndReturnArgs>(args?: SelectSubset<T, TestRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestRun.
     * @param {TestRunDeleteArgs} args - Arguments to delete one TestRun.
     * @example
     * // Delete one TestRun
     * const TestRun = await prisma.testRun.delete({
     *   where: {
     *     // ... filter to delete one TestRun
     *   }
     * })
     * 
     */
    delete<T extends TestRunDeleteArgs>(args: SelectSubset<T, TestRunDeleteArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestRun.
     * @param {TestRunUpdateArgs} args - Arguments to update one TestRun.
     * @example
     * // Update one TestRun
     * const testRun = await prisma.testRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestRunUpdateArgs>(args: SelectSubset<T, TestRunUpdateArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestRuns.
     * @param {TestRunDeleteManyArgs} args - Arguments to filter TestRuns to delete.
     * @example
     * // Delete a few TestRuns
     * const { count } = await prisma.testRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestRunDeleteManyArgs>(args?: SelectSubset<T, TestRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestRuns
     * const testRun = await prisma.testRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestRunUpdateManyArgs>(args: SelectSubset<T, TestRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestRun.
     * @param {TestRunUpsertArgs} args - Arguments to update or create a TestRun.
     * @example
     * // Update or create a TestRun
     * const testRun = await prisma.testRun.upsert({
     *   create: {
     *     // ... data to create a TestRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestRun we want to update
     *   }
     * })
     */
    upsert<T extends TestRunUpsertArgs>(args: SelectSubset<T, TestRunUpsertArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunCountArgs} args - Arguments to filter TestRuns to count.
     * @example
     * // Count the number of TestRuns
     * const count = await prisma.testRun.count({
     *   where: {
     *     // ... the filter for the TestRuns we want to count
     *   }
     * })
    **/
    count<T extends TestRunCountArgs>(
      args?: Subset<T, TestRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestRunAggregateArgs>(args: Subset<T, TestRunAggregateArgs>): Prisma.PrismaPromise<GetTestRunAggregateType<T>>

    /**
     * Group by TestRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestRunGroupByArgs['orderBy'] }
        : { orderBy?: TestRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestRun model
   */
  readonly fields: TestRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prompt<T extends PromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromptDefaultArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends TestRun$responsesArgs<ExtArgs> = {}>(args?: Subset<T, TestRun$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "findMany"> | Null>
    metrics<T extends TestRun$metricsArgs<ExtArgs> = {}>(args?: Subset<T, TestRun$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestRun model
   */ 
  interface TestRunFieldRefs {
    readonly id: FieldRef<"TestRun", 'String'>
    readonly name: FieldRef<"TestRun", 'String'>
    readonly description: FieldRef<"TestRun", 'String'>
    readonly status: FieldRef<"TestRun", 'String'>
    readonly config: FieldRef<"TestRun", 'String'>
    readonly metadata: FieldRef<"TestRun", 'String'>
    readonly startedAt: FieldRef<"TestRun", 'DateTime'>
    readonly completedAt: FieldRef<"TestRun", 'DateTime'>
    readonly createdAt: FieldRef<"TestRun", 'DateTime'>
    readonly updatedAt: FieldRef<"TestRun", 'DateTime'>
    readonly projectId: FieldRef<"TestRun", 'String'>
    readonly userId: FieldRef<"TestRun", 'String'>
    readonly promptId: FieldRef<"TestRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestRun findUnique
   */
  export type TestRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * Filter, which TestRun to fetch.
     */
    where: TestRunWhereUniqueInput
  }

  /**
   * TestRun findUniqueOrThrow
   */
  export type TestRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * Filter, which TestRun to fetch.
     */
    where: TestRunWhereUniqueInput
  }

  /**
   * TestRun findFirst
   */
  export type TestRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * Filter, which TestRun to fetch.
     */
    where?: TestRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestRuns to fetch.
     */
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestRuns.
     */
    cursor?: TestRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestRuns.
     */
    distinct?: TestRunScalarFieldEnum | TestRunScalarFieldEnum[]
  }

  /**
   * TestRun findFirstOrThrow
   */
  export type TestRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * Filter, which TestRun to fetch.
     */
    where?: TestRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestRuns to fetch.
     */
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestRuns.
     */
    cursor?: TestRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestRuns.
     */
    distinct?: TestRunScalarFieldEnum | TestRunScalarFieldEnum[]
  }

  /**
   * TestRun findMany
   */
  export type TestRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * Filter, which TestRuns to fetch.
     */
    where?: TestRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestRuns to fetch.
     */
    orderBy?: TestRunOrderByWithRelationInput | TestRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestRuns.
     */
    cursor?: TestRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestRuns.
     */
    skip?: number
    distinct?: TestRunScalarFieldEnum | TestRunScalarFieldEnum[]
  }

  /**
   * TestRun create
   */
  export type TestRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * The data needed to create a TestRun.
     */
    data: XOR<TestRunCreateInput, TestRunUncheckedCreateInput>
  }

  /**
   * TestRun createMany
   */
  export type TestRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestRuns.
     */
    data: TestRunCreateManyInput | TestRunCreateManyInput[]
  }

  /**
   * TestRun createManyAndReturn
   */
  export type TestRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestRuns.
     */
    data: TestRunCreateManyInput | TestRunCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestRun update
   */
  export type TestRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * The data needed to update a TestRun.
     */
    data: XOR<TestRunUpdateInput, TestRunUncheckedUpdateInput>
    /**
     * Choose, which TestRun to update.
     */
    where: TestRunWhereUniqueInput
  }

  /**
   * TestRun updateMany
   */
  export type TestRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestRuns.
     */
    data: XOR<TestRunUpdateManyMutationInput, TestRunUncheckedUpdateManyInput>
    /**
     * Filter which TestRuns to update
     */
    where?: TestRunWhereInput
  }

  /**
   * TestRun upsert
   */
  export type TestRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * The filter to search for the TestRun to update in case it exists.
     */
    where: TestRunWhereUniqueInput
    /**
     * In case the TestRun found by the `where` argument doesn't exist, create a new TestRun with this data.
     */
    create: XOR<TestRunCreateInput, TestRunUncheckedCreateInput>
    /**
     * In case the TestRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestRunUpdateInput, TestRunUncheckedUpdateInput>
  }

  /**
   * TestRun delete
   */
  export type TestRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
    /**
     * Filter which TestRun to delete.
     */
    where: TestRunWhereUniqueInput
  }

  /**
   * TestRun deleteMany
   */
  export type TestRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestRuns to delete
     */
    where?: TestRunWhereInput
  }

  /**
   * TestRun.responses
   */
  export type TestRun$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    where?: TestResponseWhereInput
    orderBy?: TestResponseOrderByWithRelationInput | TestResponseOrderByWithRelationInput[]
    cursor?: TestResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestResponseScalarFieldEnum | TestResponseScalarFieldEnum[]
  }

  /**
   * TestRun.metrics
   */
  export type TestRun$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    where?: TestMetricWhereInput
    orderBy?: TestMetricOrderByWithRelationInput | TestMetricOrderByWithRelationInput[]
    cursor?: TestMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestMetricScalarFieldEnum | TestMetricScalarFieldEnum[]
  }

  /**
   * TestRun without action
   */
  export type TestRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestRun
     */
    select?: TestRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestRunInclude<ExtArgs> | null
  }


  /**
   * Model TestResponse
   */

  export type AggregateTestResponse = {
    _count: TestResponseCountAggregateOutputType | null
    _avg: TestResponseAvgAggregateOutputType | null
    _sum: TestResponseSumAggregateOutputType | null
    _min: TestResponseMinAggregateOutputType | null
    _max: TestResponseMaxAggregateOutputType | null
  }

  export type TestResponseAvgAggregateOutputType = {
    latencyMs: number | null
    cost: number | null
  }

  export type TestResponseSumAggregateOutputType = {
    latencyMs: number | null
    cost: number | null
  }

  export type TestResponseMinAggregateOutputType = {
    id: string | null
    modelProvider: string | null
    modelName: string | null
    input: string | null
    output: string | null
    parsedOutput: string | null
    outputStructure: string | null
    tokenUsage: string | null
    latencyMs: number | null
    cost: number | null
    error: string | null
    rawResponse: string | null
    evaluationData: string | null
    createdAt: Date | null
    testRunId: string | null
  }

  export type TestResponseMaxAggregateOutputType = {
    id: string | null
    modelProvider: string | null
    modelName: string | null
    input: string | null
    output: string | null
    parsedOutput: string | null
    outputStructure: string | null
    tokenUsage: string | null
    latencyMs: number | null
    cost: number | null
    error: string | null
    rawResponse: string | null
    evaluationData: string | null
    createdAt: Date | null
    testRunId: string | null
  }

  export type TestResponseCountAggregateOutputType = {
    id: number
    modelProvider: number
    modelName: number
    input: number
    output: number
    parsedOutput: number
    outputStructure: number
    tokenUsage: number
    latencyMs: number
    cost: number
    error: number
    rawResponse: number
    evaluationData: number
    createdAt: number
    testRunId: number
    _all: number
  }


  export type TestResponseAvgAggregateInputType = {
    latencyMs?: true
    cost?: true
  }

  export type TestResponseSumAggregateInputType = {
    latencyMs?: true
    cost?: true
  }

  export type TestResponseMinAggregateInputType = {
    id?: true
    modelProvider?: true
    modelName?: true
    input?: true
    output?: true
    parsedOutput?: true
    outputStructure?: true
    tokenUsage?: true
    latencyMs?: true
    cost?: true
    error?: true
    rawResponse?: true
    evaluationData?: true
    createdAt?: true
    testRunId?: true
  }

  export type TestResponseMaxAggregateInputType = {
    id?: true
    modelProvider?: true
    modelName?: true
    input?: true
    output?: true
    parsedOutput?: true
    outputStructure?: true
    tokenUsage?: true
    latencyMs?: true
    cost?: true
    error?: true
    rawResponse?: true
    evaluationData?: true
    createdAt?: true
    testRunId?: true
  }

  export type TestResponseCountAggregateInputType = {
    id?: true
    modelProvider?: true
    modelName?: true
    input?: true
    output?: true
    parsedOutput?: true
    outputStructure?: true
    tokenUsage?: true
    latencyMs?: true
    cost?: true
    error?: true
    rawResponse?: true
    evaluationData?: true
    createdAt?: true
    testRunId?: true
    _all?: true
  }

  export type TestResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResponse to aggregate.
     */
    where?: TestResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResponses to fetch.
     */
    orderBy?: TestResponseOrderByWithRelationInput | TestResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestResponses
    **/
    _count?: true | TestResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestResponseMaxAggregateInputType
  }

  export type GetTestResponseAggregateType<T extends TestResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateTestResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestResponse[P]>
      : GetScalarType<T[P], AggregateTestResponse[P]>
  }




  export type TestResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResponseWhereInput
    orderBy?: TestResponseOrderByWithAggregationInput | TestResponseOrderByWithAggregationInput[]
    by: TestResponseScalarFieldEnum[] | TestResponseScalarFieldEnum
    having?: TestResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestResponseCountAggregateInputType | true
    _avg?: TestResponseAvgAggregateInputType
    _sum?: TestResponseSumAggregateInputType
    _min?: TestResponseMinAggregateInputType
    _max?: TestResponseMaxAggregateInputType
  }

  export type TestResponseGroupByOutputType = {
    id: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput: string | null
    outputStructure: string | null
    tokenUsage: string | null
    latencyMs: number | null
    cost: number | null
    error: string | null
    rawResponse: string | null
    evaluationData: string | null
    createdAt: Date
    testRunId: string
    _count: TestResponseCountAggregateOutputType | null
    _avg: TestResponseAvgAggregateOutputType | null
    _sum: TestResponseSumAggregateOutputType | null
    _min: TestResponseMinAggregateOutputType | null
    _max: TestResponseMaxAggregateOutputType | null
  }

  type GetTestResponseGroupByPayload<T extends TestResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestResponseGroupByOutputType[P]>
            : GetScalarType<T[P], TestResponseGroupByOutputType[P]>
        }
      >
    >


  export type TestResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelProvider?: boolean
    modelName?: boolean
    input?: boolean
    output?: boolean
    parsedOutput?: boolean
    outputStructure?: boolean
    tokenUsage?: boolean
    latencyMs?: boolean
    cost?: boolean
    error?: boolean
    rawResponse?: boolean
    evaluationData?: boolean
    createdAt?: boolean
    testRunId?: boolean
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testResponse"]>

  export type TestResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelProvider?: boolean
    modelName?: boolean
    input?: boolean
    output?: boolean
    parsedOutput?: boolean
    outputStructure?: boolean
    tokenUsage?: boolean
    latencyMs?: boolean
    cost?: boolean
    error?: boolean
    rawResponse?: boolean
    evaluationData?: boolean
    createdAt?: boolean
    testRunId?: boolean
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testResponse"]>

  export type TestResponseSelectScalar = {
    id?: boolean
    modelProvider?: boolean
    modelName?: boolean
    input?: boolean
    output?: boolean
    parsedOutput?: boolean
    outputStructure?: boolean
    tokenUsage?: boolean
    latencyMs?: boolean
    cost?: boolean
    error?: boolean
    rawResponse?: boolean
    evaluationData?: boolean
    createdAt?: boolean
    testRunId?: boolean
  }

  export type TestResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }
  export type TestResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }

  export type $TestResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestResponse"
    objects: {
      testRun: Prisma.$TestRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelProvider: string
      modelName: string
      input: string
      output: string
      parsedOutput: string | null
      outputStructure: string | null
      tokenUsage: string | null
      latencyMs: number | null
      cost: number | null
      error: string | null
      rawResponse: string | null
      evaluationData: string | null
      createdAt: Date
      testRunId: string
    }, ExtArgs["result"]["testResponse"]>
    composites: {}
  }

  type TestResponseGetPayload<S extends boolean | null | undefined | TestResponseDefaultArgs> = $Result.GetResult<Prisma.$TestResponsePayload, S>

  type TestResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestResponseCountAggregateInputType | true
    }

  export interface TestResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestResponse'], meta: { name: 'TestResponse' } }
    /**
     * Find zero or one TestResponse that matches the filter.
     * @param {TestResponseFindUniqueArgs} args - Arguments to find a TestResponse
     * @example
     * // Get one TestResponse
     * const testResponse = await prisma.testResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestResponseFindUniqueArgs>(args: SelectSubset<T, TestResponseFindUniqueArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestResponseFindUniqueOrThrowArgs} args - Arguments to find a TestResponse
     * @example
     * // Get one TestResponse
     * const testResponse = await prisma.testResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, TestResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseFindFirstArgs} args - Arguments to find a TestResponse
     * @example
     * // Get one TestResponse
     * const testResponse = await prisma.testResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestResponseFindFirstArgs>(args?: SelectSubset<T, TestResponseFindFirstArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseFindFirstOrThrowArgs} args - Arguments to find a TestResponse
     * @example
     * // Get one TestResponse
     * const testResponse = await prisma.testResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, TestResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestResponses
     * const testResponses = await prisma.testResponse.findMany()
     * 
     * // Get first 10 TestResponses
     * const testResponses = await prisma.testResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testResponseWithIdOnly = await prisma.testResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestResponseFindManyArgs>(args?: SelectSubset<T, TestResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestResponse.
     * @param {TestResponseCreateArgs} args - Arguments to create a TestResponse.
     * @example
     * // Create one TestResponse
     * const TestResponse = await prisma.testResponse.create({
     *   data: {
     *     // ... data to create a TestResponse
     *   }
     * })
     * 
     */
    create<T extends TestResponseCreateArgs>(args: SelectSubset<T, TestResponseCreateArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestResponses.
     * @param {TestResponseCreateManyArgs} args - Arguments to create many TestResponses.
     * @example
     * // Create many TestResponses
     * const testResponse = await prisma.testResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestResponseCreateManyArgs>(args?: SelectSubset<T, TestResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestResponses and returns the data saved in the database.
     * @param {TestResponseCreateManyAndReturnArgs} args - Arguments to create many TestResponses.
     * @example
     * // Create many TestResponses
     * const testResponse = await prisma.testResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestResponses and only return the `id`
     * const testResponseWithIdOnly = await prisma.testResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, TestResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestResponse.
     * @param {TestResponseDeleteArgs} args - Arguments to delete one TestResponse.
     * @example
     * // Delete one TestResponse
     * const TestResponse = await prisma.testResponse.delete({
     *   where: {
     *     // ... filter to delete one TestResponse
     *   }
     * })
     * 
     */
    delete<T extends TestResponseDeleteArgs>(args: SelectSubset<T, TestResponseDeleteArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestResponse.
     * @param {TestResponseUpdateArgs} args - Arguments to update one TestResponse.
     * @example
     * // Update one TestResponse
     * const testResponse = await prisma.testResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestResponseUpdateArgs>(args: SelectSubset<T, TestResponseUpdateArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestResponses.
     * @param {TestResponseDeleteManyArgs} args - Arguments to filter TestResponses to delete.
     * @example
     * // Delete a few TestResponses
     * const { count } = await prisma.testResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestResponseDeleteManyArgs>(args?: SelectSubset<T, TestResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestResponses
     * const testResponse = await prisma.testResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestResponseUpdateManyArgs>(args: SelectSubset<T, TestResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestResponse.
     * @param {TestResponseUpsertArgs} args - Arguments to update or create a TestResponse.
     * @example
     * // Update or create a TestResponse
     * const testResponse = await prisma.testResponse.upsert({
     *   create: {
     *     // ... data to create a TestResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestResponse we want to update
     *   }
     * })
     */
    upsert<T extends TestResponseUpsertArgs>(args: SelectSubset<T, TestResponseUpsertArgs<ExtArgs>>): Prisma__TestResponseClient<$Result.GetResult<Prisma.$TestResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseCountArgs} args - Arguments to filter TestResponses to count.
     * @example
     * // Count the number of TestResponses
     * const count = await prisma.testResponse.count({
     *   where: {
     *     // ... the filter for the TestResponses we want to count
     *   }
     * })
    **/
    count<T extends TestResponseCountArgs>(
      args?: Subset<T, TestResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestResponseAggregateArgs>(args: Subset<T, TestResponseAggregateArgs>): Prisma.PrismaPromise<GetTestResponseAggregateType<T>>

    /**
     * Group by TestResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestResponseGroupByArgs['orderBy'] }
        : { orderBy?: TestResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestResponse model
   */
  readonly fields: TestResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testRun<T extends TestRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestRunDefaultArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestResponse model
   */ 
  interface TestResponseFieldRefs {
    readonly id: FieldRef<"TestResponse", 'String'>
    readonly modelProvider: FieldRef<"TestResponse", 'String'>
    readonly modelName: FieldRef<"TestResponse", 'String'>
    readonly input: FieldRef<"TestResponse", 'String'>
    readonly output: FieldRef<"TestResponse", 'String'>
    readonly parsedOutput: FieldRef<"TestResponse", 'String'>
    readonly outputStructure: FieldRef<"TestResponse", 'String'>
    readonly tokenUsage: FieldRef<"TestResponse", 'String'>
    readonly latencyMs: FieldRef<"TestResponse", 'Int'>
    readonly cost: FieldRef<"TestResponse", 'Float'>
    readonly error: FieldRef<"TestResponse", 'String'>
    readonly rawResponse: FieldRef<"TestResponse", 'String'>
    readonly evaluationData: FieldRef<"TestResponse", 'String'>
    readonly createdAt: FieldRef<"TestResponse", 'DateTime'>
    readonly testRunId: FieldRef<"TestResponse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestResponse findUnique
   */
  export type TestResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * Filter, which TestResponse to fetch.
     */
    where: TestResponseWhereUniqueInput
  }

  /**
   * TestResponse findUniqueOrThrow
   */
  export type TestResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * Filter, which TestResponse to fetch.
     */
    where: TestResponseWhereUniqueInput
  }

  /**
   * TestResponse findFirst
   */
  export type TestResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * Filter, which TestResponse to fetch.
     */
    where?: TestResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResponses to fetch.
     */
    orderBy?: TestResponseOrderByWithRelationInput | TestResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResponses.
     */
    cursor?: TestResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResponses.
     */
    distinct?: TestResponseScalarFieldEnum | TestResponseScalarFieldEnum[]
  }

  /**
   * TestResponse findFirstOrThrow
   */
  export type TestResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * Filter, which TestResponse to fetch.
     */
    where?: TestResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResponses to fetch.
     */
    orderBy?: TestResponseOrderByWithRelationInput | TestResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResponses.
     */
    cursor?: TestResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResponses.
     */
    distinct?: TestResponseScalarFieldEnum | TestResponseScalarFieldEnum[]
  }

  /**
   * TestResponse findMany
   */
  export type TestResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * Filter, which TestResponses to fetch.
     */
    where?: TestResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResponses to fetch.
     */
    orderBy?: TestResponseOrderByWithRelationInput | TestResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestResponses.
     */
    cursor?: TestResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResponses.
     */
    skip?: number
    distinct?: TestResponseScalarFieldEnum | TestResponseScalarFieldEnum[]
  }

  /**
   * TestResponse create
   */
  export type TestResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a TestResponse.
     */
    data: XOR<TestResponseCreateInput, TestResponseUncheckedCreateInput>
  }

  /**
   * TestResponse createMany
   */
  export type TestResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestResponses.
     */
    data: TestResponseCreateManyInput | TestResponseCreateManyInput[]
  }

  /**
   * TestResponse createManyAndReturn
   */
  export type TestResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestResponses.
     */
    data: TestResponseCreateManyInput | TestResponseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestResponse update
   */
  export type TestResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a TestResponse.
     */
    data: XOR<TestResponseUpdateInput, TestResponseUncheckedUpdateInput>
    /**
     * Choose, which TestResponse to update.
     */
    where: TestResponseWhereUniqueInput
  }

  /**
   * TestResponse updateMany
   */
  export type TestResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestResponses.
     */
    data: XOR<TestResponseUpdateManyMutationInput, TestResponseUncheckedUpdateManyInput>
    /**
     * Filter which TestResponses to update
     */
    where?: TestResponseWhereInput
  }

  /**
   * TestResponse upsert
   */
  export type TestResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the TestResponse to update in case it exists.
     */
    where: TestResponseWhereUniqueInput
    /**
     * In case the TestResponse found by the `where` argument doesn't exist, create a new TestResponse with this data.
     */
    create: XOR<TestResponseCreateInput, TestResponseUncheckedCreateInput>
    /**
     * In case the TestResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestResponseUpdateInput, TestResponseUncheckedUpdateInput>
  }

  /**
   * TestResponse delete
   */
  export type TestResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
    /**
     * Filter which TestResponse to delete.
     */
    where: TestResponseWhereUniqueInput
  }

  /**
   * TestResponse deleteMany
   */
  export type TestResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResponses to delete
     */
    where?: TestResponseWhereInput
  }

  /**
   * TestResponse without action
   */
  export type TestResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResponse
     */
    select?: TestResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResponseInclude<ExtArgs> | null
  }


  /**
   * Model TestMetric
   */

  export type AggregateTestMetric = {
    _count: TestMetricCountAggregateOutputType | null
    _avg: TestMetricAvgAggregateOutputType | null
    _sum: TestMetricSumAggregateOutputType | null
    _min: TestMetricMinAggregateOutputType | null
    _max: TestMetricMaxAggregateOutputType | null
  }

  export type TestMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type TestMetricSumAggregateOutputType = {
    value: number | null
  }

  export type TestMetricMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    unit: string | null
    metadata: string | null
    createdAt: Date | null
    testRunId: string | null
  }

  export type TestMetricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    unit: string | null
    metadata: string | null
    createdAt: Date | null
    testRunId: string | null
  }

  export type TestMetricCountAggregateOutputType = {
    id: number
    name: number
    value: number
    unit: number
    metadata: number
    createdAt: number
    testRunId: number
    _all: number
  }


  export type TestMetricAvgAggregateInputType = {
    value?: true
  }

  export type TestMetricSumAggregateInputType = {
    value?: true
  }

  export type TestMetricMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    unit?: true
    metadata?: true
    createdAt?: true
    testRunId?: true
  }

  export type TestMetricMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    unit?: true
    metadata?: true
    createdAt?: true
    testRunId?: true
  }

  export type TestMetricCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    unit?: true
    metadata?: true
    createdAt?: true
    testRunId?: true
    _all?: true
  }

  export type TestMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestMetric to aggregate.
     */
    where?: TestMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestMetrics to fetch.
     */
    orderBy?: TestMetricOrderByWithRelationInput | TestMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestMetrics
    **/
    _count?: true | TestMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMetricMaxAggregateInputType
  }

  export type GetTestMetricAggregateType<T extends TestMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateTestMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestMetric[P]>
      : GetScalarType<T[P], AggregateTestMetric[P]>
  }




  export type TestMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestMetricWhereInput
    orderBy?: TestMetricOrderByWithAggregationInput | TestMetricOrderByWithAggregationInput[]
    by: TestMetricScalarFieldEnum[] | TestMetricScalarFieldEnum
    having?: TestMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestMetricCountAggregateInputType | true
    _avg?: TestMetricAvgAggregateInputType
    _sum?: TestMetricSumAggregateInputType
    _min?: TestMetricMinAggregateInputType
    _max?: TestMetricMaxAggregateInputType
  }

  export type TestMetricGroupByOutputType = {
    id: string
    name: string
    value: number
    unit: string | null
    metadata: string | null
    createdAt: Date
    testRunId: string
    _count: TestMetricCountAggregateOutputType | null
    _avg: TestMetricAvgAggregateOutputType | null
    _sum: TestMetricSumAggregateOutputType | null
    _min: TestMetricMinAggregateOutputType | null
    _max: TestMetricMaxAggregateOutputType | null
  }

  type GetTestMetricGroupByPayload<T extends TestMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestMetricGroupByOutputType[P]>
            : GetScalarType<T[P], TestMetricGroupByOutputType[P]>
        }
      >
    >


  export type TestMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    unit?: boolean
    metadata?: boolean
    createdAt?: boolean
    testRunId?: boolean
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testMetric"]>

  export type TestMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    unit?: boolean
    metadata?: boolean
    createdAt?: boolean
    testRunId?: boolean
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testMetric"]>

  export type TestMetricSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    unit?: boolean
    metadata?: boolean
    createdAt?: boolean
    testRunId?: boolean
  }

  export type TestMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }
  export type TestMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testRun?: boolean | TestRunDefaultArgs<ExtArgs>
  }

  export type $TestMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestMetric"
    objects: {
      testRun: Prisma.$TestRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      value: number
      unit: string | null
      metadata: string | null
      createdAt: Date
      testRunId: string
    }, ExtArgs["result"]["testMetric"]>
    composites: {}
  }

  type TestMetricGetPayload<S extends boolean | null | undefined | TestMetricDefaultArgs> = $Result.GetResult<Prisma.$TestMetricPayload, S>

  type TestMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestMetricCountAggregateInputType | true
    }

  export interface TestMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestMetric'], meta: { name: 'TestMetric' } }
    /**
     * Find zero or one TestMetric that matches the filter.
     * @param {TestMetricFindUniqueArgs} args - Arguments to find a TestMetric
     * @example
     * // Get one TestMetric
     * const testMetric = await prisma.testMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestMetricFindUniqueArgs>(args: SelectSubset<T, TestMetricFindUniqueArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestMetricFindUniqueOrThrowArgs} args - Arguments to find a TestMetric
     * @example
     * // Get one TestMetric
     * const testMetric = await prisma.testMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, TestMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricFindFirstArgs} args - Arguments to find a TestMetric
     * @example
     * // Get one TestMetric
     * const testMetric = await prisma.testMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestMetricFindFirstArgs>(args?: SelectSubset<T, TestMetricFindFirstArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricFindFirstOrThrowArgs} args - Arguments to find a TestMetric
     * @example
     * // Get one TestMetric
     * const testMetric = await prisma.testMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, TestMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestMetrics
     * const testMetrics = await prisma.testMetric.findMany()
     * 
     * // Get first 10 TestMetrics
     * const testMetrics = await prisma.testMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testMetricWithIdOnly = await prisma.testMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestMetricFindManyArgs>(args?: SelectSubset<T, TestMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestMetric.
     * @param {TestMetricCreateArgs} args - Arguments to create a TestMetric.
     * @example
     * // Create one TestMetric
     * const TestMetric = await prisma.testMetric.create({
     *   data: {
     *     // ... data to create a TestMetric
     *   }
     * })
     * 
     */
    create<T extends TestMetricCreateArgs>(args: SelectSubset<T, TestMetricCreateArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestMetrics.
     * @param {TestMetricCreateManyArgs} args - Arguments to create many TestMetrics.
     * @example
     * // Create many TestMetrics
     * const testMetric = await prisma.testMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestMetricCreateManyArgs>(args?: SelectSubset<T, TestMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestMetrics and returns the data saved in the database.
     * @param {TestMetricCreateManyAndReturnArgs} args - Arguments to create many TestMetrics.
     * @example
     * // Create many TestMetrics
     * const testMetric = await prisma.testMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestMetrics and only return the `id`
     * const testMetricWithIdOnly = await prisma.testMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, TestMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestMetric.
     * @param {TestMetricDeleteArgs} args - Arguments to delete one TestMetric.
     * @example
     * // Delete one TestMetric
     * const TestMetric = await prisma.testMetric.delete({
     *   where: {
     *     // ... filter to delete one TestMetric
     *   }
     * })
     * 
     */
    delete<T extends TestMetricDeleteArgs>(args: SelectSubset<T, TestMetricDeleteArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestMetric.
     * @param {TestMetricUpdateArgs} args - Arguments to update one TestMetric.
     * @example
     * // Update one TestMetric
     * const testMetric = await prisma.testMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestMetricUpdateArgs>(args: SelectSubset<T, TestMetricUpdateArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestMetrics.
     * @param {TestMetricDeleteManyArgs} args - Arguments to filter TestMetrics to delete.
     * @example
     * // Delete a few TestMetrics
     * const { count } = await prisma.testMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestMetricDeleteManyArgs>(args?: SelectSubset<T, TestMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestMetrics
     * const testMetric = await prisma.testMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestMetricUpdateManyArgs>(args: SelectSubset<T, TestMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestMetric.
     * @param {TestMetricUpsertArgs} args - Arguments to update or create a TestMetric.
     * @example
     * // Update or create a TestMetric
     * const testMetric = await prisma.testMetric.upsert({
     *   create: {
     *     // ... data to create a TestMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestMetric we want to update
     *   }
     * })
     */
    upsert<T extends TestMetricUpsertArgs>(args: SelectSubset<T, TestMetricUpsertArgs<ExtArgs>>): Prisma__TestMetricClient<$Result.GetResult<Prisma.$TestMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricCountArgs} args - Arguments to filter TestMetrics to count.
     * @example
     * // Count the number of TestMetrics
     * const count = await prisma.testMetric.count({
     *   where: {
     *     // ... the filter for the TestMetrics we want to count
     *   }
     * })
    **/
    count<T extends TestMetricCountArgs>(
      args?: Subset<T, TestMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestMetricAggregateArgs>(args: Subset<T, TestMetricAggregateArgs>): Prisma.PrismaPromise<GetTestMetricAggregateType<T>>

    /**
     * Group by TestMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestMetricGroupByArgs['orderBy'] }
        : { orderBy?: TestMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestMetric model
   */
  readonly fields: TestMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testRun<T extends TestRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestRunDefaultArgs<ExtArgs>>): Prisma__TestRunClient<$Result.GetResult<Prisma.$TestRunPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestMetric model
   */ 
  interface TestMetricFieldRefs {
    readonly id: FieldRef<"TestMetric", 'String'>
    readonly name: FieldRef<"TestMetric", 'String'>
    readonly value: FieldRef<"TestMetric", 'Float'>
    readonly unit: FieldRef<"TestMetric", 'String'>
    readonly metadata: FieldRef<"TestMetric", 'String'>
    readonly createdAt: FieldRef<"TestMetric", 'DateTime'>
    readonly testRunId: FieldRef<"TestMetric", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestMetric findUnique
   */
  export type TestMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * Filter, which TestMetric to fetch.
     */
    where: TestMetricWhereUniqueInput
  }

  /**
   * TestMetric findUniqueOrThrow
   */
  export type TestMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * Filter, which TestMetric to fetch.
     */
    where: TestMetricWhereUniqueInput
  }

  /**
   * TestMetric findFirst
   */
  export type TestMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * Filter, which TestMetric to fetch.
     */
    where?: TestMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestMetrics to fetch.
     */
    orderBy?: TestMetricOrderByWithRelationInput | TestMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestMetrics.
     */
    cursor?: TestMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestMetrics.
     */
    distinct?: TestMetricScalarFieldEnum | TestMetricScalarFieldEnum[]
  }

  /**
   * TestMetric findFirstOrThrow
   */
  export type TestMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * Filter, which TestMetric to fetch.
     */
    where?: TestMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestMetrics to fetch.
     */
    orderBy?: TestMetricOrderByWithRelationInput | TestMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestMetrics.
     */
    cursor?: TestMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestMetrics.
     */
    distinct?: TestMetricScalarFieldEnum | TestMetricScalarFieldEnum[]
  }

  /**
   * TestMetric findMany
   */
  export type TestMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * Filter, which TestMetrics to fetch.
     */
    where?: TestMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestMetrics to fetch.
     */
    orderBy?: TestMetricOrderByWithRelationInput | TestMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestMetrics.
     */
    cursor?: TestMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestMetrics.
     */
    skip?: number
    distinct?: TestMetricScalarFieldEnum | TestMetricScalarFieldEnum[]
  }

  /**
   * TestMetric create
   */
  export type TestMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a TestMetric.
     */
    data: XOR<TestMetricCreateInput, TestMetricUncheckedCreateInput>
  }

  /**
   * TestMetric createMany
   */
  export type TestMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestMetrics.
     */
    data: TestMetricCreateManyInput | TestMetricCreateManyInput[]
  }

  /**
   * TestMetric createManyAndReturn
   */
  export type TestMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestMetrics.
     */
    data: TestMetricCreateManyInput | TestMetricCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestMetric update
   */
  export type TestMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a TestMetric.
     */
    data: XOR<TestMetricUpdateInput, TestMetricUncheckedUpdateInput>
    /**
     * Choose, which TestMetric to update.
     */
    where: TestMetricWhereUniqueInput
  }

  /**
   * TestMetric updateMany
   */
  export type TestMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestMetrics.
     */
    data: XOR<TestMetricUpdateManyMutationInput, TestMetricUncheckedUpdateManyInput>
    /**
     * Filter which TestMetrics to update
     */
    where?: TestMetricWhereInput
  }

  /**
   * TestMetric upsert
   */
  export type TestMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the TestMetric to update in case it exists.
     */
    where: TestMetricWhereUniqueInput
    /**
     * In case the TestMetric found by the `where` argument doesn't exist, create a new TestMetric with this data.
     */
    create: XOR<TestMetricCreateInput, TestMetricUncheckedCreateInput>
    /**
     * In case the TestMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestMetricUpdateInput, TestMetricUncheckedUpdateInput>
  }

  /**
   * TestMetric delete
   */
  export type TestMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
    /**
     * Filter which TestMetric to delete.
     */
    where: TestMetricWhereUniqueInput
  }

  /**
   * TestMetric deleteMany
   */
  export type TestMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestMetrics to delete
     */
    where?: TestMetricWhereInput
  }

  /**
   * TestMetric without action
   */
  export type TestMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestMetric
     */
    select?: TestMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestMetricInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationPlugin
   */

  export type AggregateEvaluationPlugin = {
    _count: EvaluationPluginCountAggregateOutputType | null
    _min: EvaluationPluginMinAggregateOutputType | null
    _max: EvaluationPluginMaxAggregateOutputType | null
  }

  export type EvaluationPluginMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    description: string | null
    config: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationPluginMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    description: string | null
    config: string | null
    code: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationPluginCountAggregateOutputType = {
    id: number
    name: number
    version: number
    description: number
    config: number
    code: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationPluginMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    config?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationPluginMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    config?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationPluginCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    config?: true
    code?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationPluginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationPlugin to aggregate.
     */
    where?: EvaluationPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPlugins to fetch.
     */
    orderBy?: EvaluationPluginOrderByWithRelationInput | EvaluationPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPlugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationPlugins
    **/
    _count?: true | EvaluationPluginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationPluginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationPluginMaxAggregateInputType
  }

  export type GetEvaluationPluginAggregateType<T extends EvaluationPluginAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationPlugin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationPlugin[P]>
      : GetScalarType<T[P], AggregateEvaluationPlugin[P]>
  }




  export type EvaluationPluginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationPluginWhereInput
    orderBy?: EvaluationPluginOrderByWithAggregationInput | EvaluationPluginOrderByWithAggregationInput[]
    by: EvaluationPluginScalarFieldEnum[] | EvaluationPluginScalarFieldEnum
    having?: EvaluationPluginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationPluginCountAggregateInputType | true
    _min?: EvaluationPluginMinAggregateInputType
    _max?: EvaluationPluginMaxAggregateInputType
  }

  export type EvaluationPluginGroupByOutputType = {
    id: string
    name: string
    version: string
    description: string | null
    config: string
    code: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EvaluationPluginCountAggregateOutputType | null
    _min: EvaluationPluginMinAggregateOutputType | null
    _max: EvaluationPluginMaxAggregateOutputType | null
  }

  type GetEvaluationPluginGroupByPayload<T extends EvaluationPluginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationPluginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationPluginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationPluginGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationPluginGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationPluginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    config?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["evaluationPlugin"]>

  export type EvaluationPluginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    config?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["evaluationPlugin"]>

  export type EvaluationPluginSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    config?: boolean
    code?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EvaluationPluginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationPlugin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      version: string
      description: string | null
      config: string
      code: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluationPlugin"]>
    composites: {}
  }

  type EvaluationPluginGetPayload<S extends boolean | null | undefined | EvaluationPluginDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPluginPayload, S>

  type EvaluationPluginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationPluginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationPluginCountAggregateInputType | true
    }

  export interface EvaluationPluginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationPlugin'], meta: { name: 'EvaluationPlugin' } }
    /**
     * Find zero or one EvaluationPlugin that matches the filter.
     * @param {EvaluationPluginFindUniqueArgs} args - Arguments to find a EvaluationPlugin
     * @example
     * // Get one EvaluationPlugin
     * const evaluationPlugin = await prisma.evaluationPlugin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationPluginFindUniqueArgs>(args: SelectSubset<T, EvaluationPluginFindUniqueArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationPlugin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationPluginFindUniqueOrThrowArgs} args - Arguments to find a EvaluationPlugin
     * @example
     * // Get one EvaluationPlugin
     * const evaluationPlugin = await prisma.evaluationPlugin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationPluginFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationPluginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationPlugin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginFindFirstArgs} args - Arguments to find a EvaluationPlugin
     * @example
     * // Get one EvaluationPlugin
     * const evaluationPlugin = await prisma.evaluationPlugin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationPluginFindFirstArgs>(args?: SelectSubset<T, EvaluationPluginFindFirstArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationPlugin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginFindFirstOrThrowArgs} args - Arguments to find a EvaluationPlugin
     * @example
     * // Get one EvaluationPlugin
     * const evaluationPlugin = await prisma.evaluationPlugin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationPluginFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationPluginFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationPlugins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationPlugins
     * const evaluationPlugins = await prisma.evaluationPlugin.findMany()
     * 
     * // Get first 10 EvaluationPlugins
     * const evaluationPlugins = await prisma.evaluationPlugin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationPluginWithIdOnly = await prisma.evaluationPlugin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationPluginFindManyArgs>(args?: SelectSubset<T, EvaluationPluginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationPlugin.
     * @param {EvaluationPluginCreateArgs} args - Arguments to create a EvaluationPlugin.
     * @example
     * // Create one EvaluationPlugin
     * const EvaluationPlugin = await prisma.evaluationPlugin.create({
     *   data: {
     *     // ... data to create a EvaluationPlugin
     *   }
     * })
     * 
     */
    create<T extends EvaluationPluginCreateArgs>(args: SelectSubset<T, EvaluationPluginCreateArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationPlugins.
     * @param {EvaluationPluginCreateManyArgs} args - Arguments to create many EvaluationPlugins.
     * @example
     * // Create many EvaluationPlugins
     * const evaluationPlugin = await prisma.evaluationPlugin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationPluginCreateManyArgs>(args?: SelectSubset<T, EvaluationPluginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationPlugins and returns the data saved in the database.
     * @param {EvaluationPluginCreateManyAndReturnArgs} args - Arguments to create many EvaluationPlugins.
     * @example
     * // Create many EvaluationPlugins
     * const evaluationPlugin = await prisma.evaluationPlugin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationPlugins and only return the `id`
     * const evaluationPluginWithIdOnly = await prisma.evaluationPlugin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationPluginCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationPluginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationPlugin.
     * @param {EvaluationPluginDeleteArgs} args - Arguments to delete one EvaluationPlugin.
     * @example
     * // Delete one EvaluationPlugin
     * const EvaluationPlugin = await prisma.evaluationPlugin.delete({
     *   where: {
     *     // ... filter to delete one EvaluationPlugin
     *   }
     * })
     * 
     */
    delete<T extends EvaluationPluginDeleteArgs>(args: SelectSubset<T, EvaluationPluginDeleteArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationPlugin.
     * @param {EvaluationPluginUpdateArgs} args - Arguments to update one EvaluationPlugin.
     * @example
     * // Update one EvaluationPlugin
     * const evaluationPlugin = await prisma.evaluationPlugin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationPluginUpdateArgs>(args: SelectSubset<T, EvaluationPluginUpdateArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationPlugins.
     * @param {EvaluationPluginDeleteManyArgs} args - Arguments to filter EvaluationPlugins to delete.
     * @example
     * // Delete a few EvaluationPlugins
     * const { count } = await prisma.evaluationPlugin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationPluginDeleteManyArgs>(args?: SelectSubset<T, EvaluationPluginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationPlugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationPlugins
     * const evaluationPlugin = await prisma.evaluationPlugin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationPluginUpdateManyArgs>(args: SelectSubset<T, EvaluationPluginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationPlugin.
     * @param {EvaluationPluginUpsertArgs} args - Arguments to update or create a EvaluationPlugin.
     * @example
     * // Update or create a EvaluationPlugin
     * const evaluationPlugin = await prisma.evaluationPlugin.upsert({
     *   create: {
     *     // ... data to create a EvaluationPlugin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationPlugin we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationPluginUpsertArgs>(args: SelectSubset<T, EvaluationPluginUpsertArgs<ExtArgs>>): Prisma__EvaluationPluginClient<$Result.GetResult<Prisma.$EvaluationPluginPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationPlugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginCountArgs} args - Arguments to filter EvaluationPlugins to count.
     * @example
     * // Count the number of EvaluationPlugins
     * const count = await prisma.evaluationPlugin.count({
     *   where: {
     *     // ... the filter for the EvaluationPlugins we want to count
     *   }
     * })
    **/
    count<T extends EvaluationPluginCountArgs>(
      args?: Subset<T, EvaluationPluginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationPluginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationPlugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationPluginAggregateArgs>(args: Subset<T, EvaluationPluginAggregateArgs>): Prisma.PrismaPromise<GetEvaluationPluginAggregateType<T>>

    /**
     * Group by EvaluationPlugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationPluginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationPluginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationPluginGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationPluginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationPluginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationPluginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationPlugin model
   */
  readonly fields: EvaluationPluginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationPlugin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationPluginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationPlugin model
   */ 
  interface EvaluationPluginFieldRefs {
    readonly id: FieldRef<"EvaluationPlugin", 'String'>
    readonly name: FieldRef<"EvaluationPlugin", 'String'>
    readonly version: FieldRef<"EvaluationPlugin", 'String'>
    readonly description: FieldRef<"EvaluationPlugin", 'String'>
    readonly config: FieldRef<"EvaluationPlugin", 'String'>
    readonly code: FieldRef<"EvaluationPlugin", 'String'>
    readonly isActive: FieldRef<"EvaluationPlugin", 'Boolean'>
    readonly createdAt: FieldRef<"EvaluationPlugin", 'DateTime'>
    readonly updatedAt: FieldRef<"EvaluationPlugin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationPlugin findUnique
   */
  export type EvaluationPluginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * Filter, which EvaluationPlugin to fetch.
     */
    where: EvaluationPluginWhereUniqueInput
  }

  /**
   * EvaluationPlugin findUniqueOrThrow
   */
  export type EvaluationPluginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * Filter, which EvaluationPlugin to fetch.
     */
    where: EvaluationPluginWhereUniqueInput
  }

  /**
   * EvaluationPlugin findFirst
   */
  export type EvaluationPluginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * Filter, which EvaluationPlugin to fetch.
     */
    where?: EvaluationPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPlugins to fetch.
     */
    orderBy?: EvaluationPluginOrderByWithRelationInput | EvaluationPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationPlugins.
     */
    cursor?: EvaluationPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPlugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationPlugins.
     */
    distinct?: EvaluationPluginScalarFieldEnum | EvaluationPluginScalarFieldEnum[]
  }

  /**
   * EvaluationPlugin findFirstOrThrow
   */
  export type EvaluationPluginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * Filter, which EvaluationPlugin to fetch.
     */
    where?: EvaluationPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPlugins to fetch.
     */
    orderBy?: EvaluationPluginOrderByWithRelationInput | EvaluationPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationPlugins.
     */
    cursor?: EvaluationPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPlugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationPlugins.
     */
    distinct?: EvaluationPluginScalarFieldEnum | EvaluationPluginScalarFieldEnum[]
  }

  /**
   * EvaluationPlugin findMany
   */
  export type EvaluationPluginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * Filter, which EvaluationPlugins to fetch.
     */
    where?: EvaluationPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationPlugins to fetch.
     */
    orderBy?: EvaluationPluginOrderByWithRelationInput | EvaluationPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationPlugins.
     */
    cursor?: EvaluationPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationPlugins.
     */
    skip?: number
    distinct?: EvaluationPluginScalarFieldEnum | EvaluationPluginScalarFieldEnum[]
  }

  /**
   * EvaluationPlugin create
   */
  export type EvaluationPluginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * The data needed to create a EvaluationPlugin.
     */
    data: XOR<EvaluationPluginCreateInput, EvaluationPluginUncheckedCreateInput>
  }

  /**
   * EvaluationPlugin createMany
   */
  export type EvaluationPluginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationPlugins.
     */
    data: EvaluationPluginCreateManyInput | EvaluationPluginCreateManyInput[]
  }

  /**
   * EvaluationPlugin createManyAndReturn
   */
  export type EvaluationPluginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationPlugins.
     */
    data: EvaluationPluginCreateManyInput | EvaluationPluginCreateManyInput[]
  }

  /**
   * EvaluationPlugin update
   */
  export type EvaluationPluginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * The data needed to update a EvaluationPlugin.
     */
    data: XOR<EvaluationPluginUpdateInput, EvaluationPluginUncheckedUpdateInput>
    /**
     * Choose, which EvaluationPlugin to update.
     */
    where: EvaluationPluginWhereUniqueInput
  }

  /**
   * EvaluationPlugin updateMany
   */
  export type EvaluationPluginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationPlugins.
     */
    data: XOR<EvaluationPluginUpdateManyMutationInput, EvaluationPluginUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationPlugins to update
     */
    where?: EvaluationPluginWhereInput
  }

  /**
   * EvaluationPlugin upsert
   */
  export type EvaluationPluginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * The filter to search for the EvaluationPlugin to update in case it exists.
     */
    where: EvaluationPluginWhereUniqueInput
    /**
     * In case the EvaluationPlugin found by the `where` argument doesn't exist, create a new EvaluationPlugin with this data.
     */
    create: XOR<EvaluationPluginCreateInput, EvaluationPluginUncheckedCreateInput>
    /**
     * In case the EvaluationPlugin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationPluginUpdateInput, EvaluationPluginUncheckedUpdateInput>
  }

  /**
   * EvaluationPlugin delete
   */
  export type EvaluationPluginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
    /**
     * Filter which EvaluationPlugin to delete.
     */
    where: EvaluationPluginWhereUniqueInput
  }

  /**
   * EvaluationPlugin deleteMany
   */
  export type EvaluationPluginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationPlugins to delete
     */
    where?: EvaluationPluginWhereInput
  }

  /**
   * EvaluationPlugin without action
   */
  export type EvaluationPluginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationPlugin
     */
    select?: EvaluationPluginSelect<ExtArgs> | null
  }


  /**
   * Model QueueJob
   */

  export type AggregateQueueJob = {
    _count: QueueJobCountAggregateOutputType | null
    _avg: QueueJobAvgAggregateOutputType | null
    _sum: QueueJobSumAggregateOutputType | null
    _min: QueueJobMinAggregateOutputType | null
    _max: QueueJobMaxAggregateOutputType | null
  }

  export type QueueJobAvgAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type QueueJobSumAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type QueueJobMinAggregateOutputType = {
    id: string | null
    type: string | null
    data: string | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    status: string | null
    error: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
  }

  export type QueueJobMaxAggregateOutputType = {
    id: string | null
    type: string | null
    data: string | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    status: string | null
    error: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
  }

  export type QueueJobCountAggregateOutputType = {
    id: number
    type: number
    data: number
    priority: number
    attempts: number
    maxAttempts: number
    status: number
    error: number
    metadata: number
    createdAt: number
    updatedAt: number
    processedAt: number
    _all: number
  }


  export type QueueJobAvgAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type QueueJobSumAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type QueueJobMinAggregateInputType = {
    id?: true
    type?: true
    data?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    status?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
  }

  export type QueueJobMaxAggregateInputType = {
    id?: true
    type?: true
    data?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    status?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
  }

  export type QueueJobCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    status?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    _all?: true
  }

  export type QueueJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueJob to aggregate.
     */
    where?: QueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueJobs to fetch.
     */
    orderBy?: QueueJobOrderByWithRelationInput | QueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueJobs
    **/
    _count?: true | QueueJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueJobMaxAggregateInputType
  }

  export type GetQueueJobAggregateType<T extends QueueJobAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueJob[P]>
      : GetScalarType<T[P], AggregateQueueJob[P]>
  }




  export type QueueJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueJobWhereInput
    orderBy?: QueueJobOrderByWithAggregationInput | QueueJobOrderByWithAggregationInput[]
    by: QueueJobScalarFieldEnum[] | QueueJobScalarFieldEnum
    having?: QueueJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueJobCountAggregateInputType | true
    _avg?: QueueJobAvgAggregateInputType
    _sum?: QueueJobSumAggregateInputType
    _min?: QueueJobMinAggregateInputType
    _max?: QueueJobMaxAggregateInputType
  }

  export type QueueJobGroupByOutputType = {
    id: string
    type: string
    data: string
    priority: number
    attempts: number
    maxAttempts: number
    status: string
    error: string | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    processedAt: Date | null
    _count: QueueJobCountAggregateOutputType | null
    _avg: QueueJobAvgAggregateOutputType | null
    _sum: QueueJobSumAggregateOutputType | null
    _min: QueueJobMinAggregateOutputType | null
    _max: QueueJobMaxAggregateOutputType | null
  }

  type GetQueueJobGroupByPayload<T extends QueueJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueJobGroupByOutputType[P]>
            : GetScalarType<T[P], QueueJobGroupByOutputType[P]>
        }
      >
    >


  export type QueueJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    status?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["queueJob"]>

  export type QueueJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    status?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["queueJob"]>

  export type QueueJobSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    status?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
  }


  export type $QueueJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      data: string
      priority: number
      attempts: number
      maxAttempts: number
      status: string
      error: string | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["queueJob"]>
    composites: {}
  }

  type QueueJobGetPayload<S extends boolean | null | undefined | QueueJobDefaultArgs> = $Result.GetResult<Prisma.$QueueJobPayload, S>

  type QueueJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QueueJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QueueJobCountAggregateInputType | true
    }

  export interface QueueJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueJob'], meta: { name: 'QueueJob' } }
    /**
     * Find zero or one QueueJob that matches the filter.
     * @param {QueueJobFindUniqueArgs} args - Arguments to find a QueueJob
     * @example
     * // Get one QueueJob
     * const queueJob = await prisma.queueJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueJobFindUniqueArgs>(args: SelectSubset<T, QueueJobFindUniqueArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QueueJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QueueJobFindUniqueOrThrowArgs} args - Arguments to find a QueueJob
     * @example
     * // Get one QueueJob
     * const queueJob = await prisma.queueJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueJobFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QueueJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobFindFirstArgs} args - Arguments to find a QueueJob
     * @example
     * // Get one QueueJob
     * const queueJob = await prisma.queueJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueJobFindFirstArgs>(args?: SelectSubset<T, QueueJobFindFirstArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QueueJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobFindFirstOrThrowArgs} args - Arguments to find a QueueJob
     * @example
     * // Get one QueueJob
     * const queueJob = await prisma.queueJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueJobFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QueueJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueJobs
     * const queueJobs = await prisma.queueJob.findMany()
     * 
     * // Get first 10 QueueJobs
     * const queueJobs = await prisma.queueJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueJobWithIdOnly = await prisma.queueJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueJobFindManyArgs>(args?: SelectSubset<T, QueueJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QueueJob.
     * @param {QueueJobCreateArgs} args - Arguments to create a QueueJob.
     * @example
     * // Create one QueueJob
     * const QueueJob = await prisma.queueJob.create({
     *   data: {
     *     // ... data to create a QueueJob
     *   }
     * })
     * 
     */
    create<T extends QueueJobCreateArgs>(args: SelectSubset<T, QueueJobCreateArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QueueJobs.
     * @param {QueueJobCreateManyArgs} args - Arguments to create many QueueJobs.
     * @example
     * // Create many QueueJobs
     * const queueJob = await prisma.queueJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueJobCreateManyArgs>(args?: SelectSubset<T, QueueJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueueJobs and returns the data saved in the database.
     * @param {QueueJobCreateManyAndReturnArgs} args - Arguments to create many QueueJobs.
     * @example
     * // Create many QueueJobs
     * const queueJob = await prisma.queueJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueueJobs and only return the `id`
     * const queueJobWithIdOnly = await prisma.queueJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueJobCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QueueJob.
     * @param {QueueJobDeleteArgs} args - Arguments to delete one QueueJob.
     * @example
     * // Delete one QueueJob
     * const QueueJob = await prisma.queueJob.delete({
     *   where: {
     *     // ... filter to delete one QueueJob
     *   }
     * })
     * 
     */
    delete<T extends QueueJobDeleteArgs>(args: SelectSubset<T, QueueJobDeleteArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QueueJob.
     * @param {QueueJobUpdateArgs} args - Arguments to update one QueueJob.
     * @example
     * // Update one QueueJob
     * const queueJob = await prisma.queueJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueJobUpdateArgs>(args: SelectSubset<T, QueueJobUpdateArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QueueJobs.
     * @param {QueueJobDeleteManyArgs} args - Arguments to filter QueueJobs to delete.
     * @example
     * // Delete a few QueueJobs
     * const { count } = await prisma.queueJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueJobDeleteManyArgs>(args?: SelectSubset<T, QueueJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueJobs
     * const queueJob = await prisma.queueJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueJobUpdateManyArgs>(args: SelectSubset<T, QueueJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QueueJob.
     * @param {QueueJobUpsertArgs} args - Arguments to update or create a QueueJob.
     * @example
     * // Update or create a QueueJob
     * const queueJob = await prisma.queueJob.upsert({
     *   create: {
     *     // ... data to create a QueueJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueJob we want to update
     *   }
     * })
     */
    upsert<T extends QueueJobUpsertArgs>(args: SelectSubset<T, QueueJobUpsertArgs<ExtArgs>>): Prisma__QueueJobClient<$Result.GetResult<Prisma.$QueueJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QueueJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobCountArgs} args - Arguments to filter QueueJobs to count.
     * @example
     * // Count the number of QueueJobs
     * const count = await prisma.queueJob.count({
     *   where: {
     *     // ... the filter for the QueueJobs we want to count
     *   }
     * })
    **/
    count<T extends QueueJobCountArgs>(
      args?: Subset<T, QueueJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueJobAggregateArgs>(args: Subset<T, QueueJobAggregateArgs>): Prisma.PrismaPromise<GetQueueJobAggregateType<T>>

    /**
     * Group by QueueJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueJobGroupByArgs['orderBy'] }
        : { orderBy?: QueueJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueJob model
   */
  readonly fields: QueueJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueJob model
   */ 
  interface QueueJobFieldRefs {
    readonly id: FieldRef<"QueueJob", 'String'>
    readonly type: FieldRef<"QueueJob", 'String'>
    readonly data: FieldRef<"QueueJob", 'String'>
    readonly priority: FieldRef<"QueueJob", 'Int'>
    readonly attempts: FieldRef<"QueueJob", 'Int'>
    readonly maxAttempts: FieldRef<"QueueJob", 'Int'>
    readonly status: FieldRef<"QueueJob", 'String'>
    readonly error: FieldRef<"QueueJob", 'String'>
    readonly metadata: FieldRef<"QueueJob", 'String'>
    readonly createdAt: FieldRef<"QueueJob", 'DateTime'>
    readonly updatedAt: FieldRef<"QueueJob", 'DateTime'>
    readonly processedAt: FieldRef<"QueueJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueueJob findUnique
   */
  export type QueueJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * Filter, which QueueJob to fetch.
     */
    where: QueueJobWhereUniqueInput
  }

  /**
   * QueueJob findUniqueOrThrow
   */
  export type QueueJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * Filter, which QueueJob to fetch.
     */
    where: QueueJobWhereUniqueInput
  }

  /**
   * QueueJob findFirst
   */
  export type QueueJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * Filter, which QueueJob to fetch.
     */
    where?: QueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueJobs to fetch.
     */
    orderBy?: QueueJobOrderByWithRelationInput | QueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueJobs.
     */
    cursor?: QueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueJobs.
     */
    distinct?: QueueJobScalarFieldEnum | QueueJobScalarFieldEnum[]
  }

  /**
   * QueueJob findFirstOrThrow
   */
  export type QueueJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * Filter, which QueueJob to fetch.
     */
    where?: QueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueJobs to fetch.
     */
    orderBy?: QueueJobOrderByWithRelationInput | QueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueJobs.
     */
    cursor?: QueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueJobs.
     */
    distinct?: QueueJobScalarFieldEnum | QueueJobScalarFieldEnum[]
  }

  /**
   * QueueJob findMany
   */
  export type QueueJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * Filter, which QueueJobs to fetch.
     */
    where?: QueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueJobs to fetch.
     */
    orderBy?: QueueJobOrderByWithRelationInput | QueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueJobs.
     */
    cursor?: QueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueJobs.
     */
    skip?: number
    distinct?: QueueJobScalarFieldEnum | QueueJobScalarFieldEnum[]
  }

  /**
   * QueueJob create
   */
  export type QueueJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * The data needed to create a QueueJob.
     */
    data: XOR<QueueJobCreateInput, QueueJobUncheckedCreateInput>
  }

  /**
   * QueueJob createMany
   */
  export type QueueJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueJobs.
     */
    data: QueueJobCreateManyInput | QueueJobCreateManyInput[]
  }

  /**
   * QueueJob createManyAndReturn
   */
  export type QueueJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QueueJobs.
     */
    data: QueueJobCreateManyInput | QueueJobCreateManyInput[]
  }

  /**
   * QueueJob update
   */
  export type QueueJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * The data needed to update a QueueJob.
     */
    data: XOR<QueueJobUpdateInput, QueueJobUncheckedUpdateInput>
    /**
     * Choose, which QueueJob to update.
     */
    where: QueueJobWhereUniqueInput
  }

  /**
   * QueueJob updateMany
   */
  export type QueueJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueJobs.
     */
    data: XOR<QueueJobUpdateManyMutationInput, QueueJobUncheckedUpdateManyInput>
    /**
     * Filter which QueueJobs to update
     */
    where?: QueueJobWhereInput
  }

  /**
   * QueueJob upsert
   */
  export type QueueJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * The filter to search for the QueueJob to update in case it exists.
     */
    where: QueueJobWhereUniqueInput
    /**
     * In case the QueueJob found by the `where` argument doesn't exist, create a new QueueJob with this data.
     */
    create: XOR<QueueJobCreateInput, QueueJobUncheckedCreateInput>
    /**
     * In case the QueueJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueJobUpdateInput, QueueJobUncheckedUpdateInput>
  }

  /**
   * QueueJob delete
   */
  export type QueueJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
    /**
     * Filter which QueueJob to delete.
     */
    where: QueueJobWhereUniqueInput
  }

  /**
   * QueueJob deleteMany
   */
  export type QueueJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueJobs to delete
     */
    where?: QueueJobWhereInput
  }

  /**
   * QueueJob without action
   */
  export type QueueJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueJob
     */
    select?: QueueJobSelect<ExtArgs> | null
  }


  /**
   * Model RecurringJob
   */

  export type AggregateRecurringJob = {
    _count: RecurringJobCountAggregateOutputType | null
    _avg: RecurringJobAvgAggregateOutputType | null
    _sum: RecurringJobSumAggregateOutputType | null
    _min: RecurringJobMinAggregateOutputType | null
    _max: RecurringJobMaxAggregateOutputType | null
  }

  export type RecurringJobAvgAggregateOutputType = {
    interval: number | null
    priority: number | null
  }

  export type RecurringJobSumAggregateOutputType = {
    interval: number | null
    priority: number | null
  }

  export type RecurringJobMinAggregateOutputType = {
    id: string | null
    type: string | null
    data: string | null
    interval: number | null
    priority: number | null
    enabled: boolean | null
    nextRun: Date | null
    lastRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringJobMaxAggregateOutputType = {
    id: string | null
    type: string | null
    data: string | null
    interval: number | null
    priority: number | null
    enabled: boolean | null
    nextRun: Date | null
    lastRun: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringJobCountAggregateOutputType = {
    id: number
    type: number
    data: number
    interval: number
    priority: number
    enabled: number
    nextRun: number
    lastRun: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringJobAvgAggregateInputType = {
    interval?: true
    priority?: true
  }

  export type RecurringJobSumAggregateInputType = {
    interval?: true
    priority?: true
  }

  export type RecurringJobMinAggregateInputType = {
    id?: true
    type?: true
    data?: true
    interval?: true
    priority?: true
    enabled?: true
    nextRun?: true
    lastRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringJobMaxAggregateInputType = {
    id?: true
    type?: true
    data?: true
    interval?: true
    priority?: true
    enabled?: true
    nextRun?: true
    lastRun?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringJobCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    interval?: true
    priority?: true
    enabled?: true
    nextRun?: true
    lastRun?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringJob to aggregate.
     */
    where?: RecurringJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringJobs to fetch.
     */
    orderBy?: RecurringJobOrderByWithRelationInput | RecurringJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringJobs
    **/
    _count?: true | RecurringJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringJobMaxAggregateInputType
  }

  export type GetRecurringJobAggregateType<T extends RecurringJobAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringJob[P]>
      : GetScalarType<T[P], AggregateRecurringJob[P]>
  }




  export type RecurringJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringJobWhereInput
    orderBy?: RecurringJobOrderByWithAggregationInput | RecurringJobOrderByWithAggregationInput[]
    by: RecurringJobScalarFieldEnum[] | RecurringJobScalarFieldEnum
    having?: RecurringJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringJobCountAggregateInputType | true
    _avg?: RecurringJobAvgAggregateInputType
    _sum?: RecurringJobSumAggregateInputType
    _min?: RecurringJobMinAggregateInputType
    _max?: RecurringJobMaxAggregateInputType
  }

  export type RecurringJobGroupByOutputType = {
    id: string
    type: string
    data: string
    interval: number
    priority: number
    enabled: boolean
    nextRun: Date
    lastRun: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RecurringJobCountAggregateOutputType | null
    _avg: RecurringJobAvgAggregateOutputType | null
    _sum: RecurringJobSumAggregateOutputType | null
    _min: RecurringJobMinAggregateOutputType | null
    _max: RecurringJobMaxAggregateOutputType | null
  }

  type GetRecurringJobGroupByPayload<T extends RecurringJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringJobGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringJobGroupByOutputType[P]>
        }
      >
    >


  export type RecurringJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    interval?: boolean
    priority?: boolean
    enabled?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recurringJob"]>

  export type RecurringJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    interval?: boolean
    priority?: boolean
    enabled?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recurringJob"]>

  export type RecurringJobSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    interval?: boolean
    priority?: boolean
    enabled?: boolean
    nextRun?: boolean
    lastRun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RecurringJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      data: string
      interval: number
      priority: number
      enabled: boolean
      nextRun: Date
      lastRun: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringJob"]>
    composites: {}
  }

  type RecurringJobGetPayload<S extends boolean | null | undefined | RecurringJobDefaultArgs> = $Result.GetResult<Prisma.$RecurringJobPayload, S>

  type RecurringJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecurringJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecurringJobCountAggregateInputType | true
    }

  export interface RecurringJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringJob'], meta: { name: 'RecurringJob' } }
    /**
     * Find zero or one RecurringJob that matches the filter.
     * @param {RecurringJobFindUniqueArgs} args - Arguments to find a RecurringJob
     * @example
     * // Get one RecurringJob
     * const recurringJob = await prisma.recurringJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringJobFindUniqueArgs>(args: SelectSubset<T, RecurringJobFindUniqueArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecurringJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecurringJobFindUniqueOrThrowArgs} args - Arguments to find a RecurringJob
     * @example
     * // Get one RecurringJob
     * const recurringJob = await prisma.recurringJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringJobFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecurringJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobFindFirstArgs} args - Arguments to find a RecurringJob
     * @example
     * // Get one RecurringJob
     * const recurringJob = await prisma.recurringJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringJobFindFirstArgs>(args?: SelectSubset<T, RecurringJobFindFirstArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecurringJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobFindFirstOrThrowArgs} args - Arguments to find a RecurringJob
     * @example
     * // Get one RecurringJob
     * const recurringJob = await prisma.recurringJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringJobFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecurringJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringJobs
     * const recurringJobs = await prisma.recurringJob.findMany()
     * 
     * // Get first 10 RecurringJobs
     * const recurringJobs = await prisma.recurringJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringJobWithIdOnly = await prisma.recurringJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringJobFindManyArgs>(args?: SelectSubset<T, RecurringJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecurringJob.
     * @param {RecurringJobCreateArgs} args - Arguments to create a RecurringJob.
     * @example
     * // Create one RecurringJob
     * const RecurringJob = await prisma.recurringJob.create({
     *   data: {
     *     // ... data to create a RecurringJob
     *   }
     * })
     * 
     */
    create<T extends RecurringJobCreateArgs>(args: SelectSubset<T, RecurringJobCreateArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecurringJobs.
     * @param {RecurringJobCreateManyArgs} args - Arguments to create many RecurringJobs.
     * @example
     * // Create many RecurringJobs
     * const recurringJob = await prisma.recurringJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringJobCreateManyArgs>(args?: SelectSubset<T, RecurringJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringJobs and returns the data saved in the database.
     * @param {RecurringJobCreateManyAndReturnArgs} args - Arguments to create many RecurringJobs.
     * @example
     * // Create many RecurringJobs
     * const recurringJob = await prisma.recurringJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringJobs and only return the `id`
     * const recurringJobWithIdOnly = await prisma.recurringJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringJobCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecurringJob.
     * @param {RecurringJobDeleteArgs} args - Arguments to delete one RecurringJob.
     * @example
     * // Delete one RecurringJob
     * const RecurringJob = await prisma.recurringJob.delete({
     *   where: {
     *     // ... filter to delete one RecurringJob
     *   }
     * })
     * 
     */
    delete<T extends RecurringJobDeleteArgs>(args: SelectSubset<T, RecurringJobDeleteArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecurringJob.
     * @param {RecurringJobUpdateArgs} args - Arguments to update one RecurringJob.
     * @example
     * // Update one RecurringJob
     * const recurringJob = await prisma.recurringJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringJobUpdateArgs>(args: SelectSubset<T, RecurringJobUpdateArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecurringJobs.
     * @param {RecurringJobDeleteManyArgs} args - Arguments to filter RecurringJobs to delete.
     * @example
     * // Delete a few RecurringJobs
     * const { count } = await prisma.recurringJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringJobDeleteManyArgs>(args?: SelectSubset<T, RecurringJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringJobs
     * const recurringJob = await prisma.recurringJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringJobUpdateManyArgs>(args: SelectSubset<T, RecurringJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringJob.
     * @param {RecurringJobUpsertArgs} args - Arguments to update or create a RecurringJob.
     * @example
     * // Update or create a RecurringJob
     * const recurringJob = await prisma.recurringJob.upsert({
     *   create: {
     *     // ... data to create a RecurringJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringJob we want to update
     *   }
     * })
     */
    upsert<T extends RecurringJobUpsertArgs>(args: SelectSubset<T, RecurringJobUpsertArgs<ExtArgs>>): Prisma__RecurringJobClient<$Result.GetResult<Prisma.$RecurringJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecurringJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobCountArgs} args - Arguments to filter RecurringJobs to count.
     * @example
     * // Count the number of RecurringJobs
     * const count = await prisma.recurringJob.count({
     *   where: {
     *     // ... the filter for the RecurringJobs we want to count
     *   }
     * })
    **/
    count<T extends RecurringJobCountArgs>(
      args?: Subset<T, RecurringJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringJobAggregateArgs>(args: Subset<T, RecurringJobAggregateArgs>): Prisma.PrismaPromise<GetRecurringJobAggregateType<T>>

    /**
     * Group by RecurringJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringJobGroupByArgs['orderBy'] }
        : { orderBy?: RecurringJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringJob model
   */
  readonly fields: RecurringJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringJob model
   */ 
  interface RecurringJobFieldRefs {
    readonly id: FieldRef<"RecurringJob", 'String'>
    readonly type: FieldRef<"RecurringJob", 'String'>
    readonly data: FieldRef<"RecurringJob", 'String'>
    readonly interval: FieldRef<"RecurringJob", 'Int'>
    readonly priority: FieldRef<"RecurringJob", 'Int'>
    readonly enabled: FieldRef<"RecurringJob", 'Boolean'>
    readonly nextRun: FieldRef<"RecurringJob", 'DateTime'>
    readonly lastRun: FieldRef<"RecurringJob", 'DateTime'>
    readonly createdAt: FieldRef<"RecurringJob", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringJob findUnique
   */
  export type RecurringJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * Filter, which RecurringJob to fetch.
     */
    where: RecurringJobWhereUniqueInput
  }

  /**
   * RecurringJob findUniqueOrThrow
   */
  export type RecurringJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * Filter, which RecurringJob to fetch.
     */
    where: RecurringJobWhereUniqueInput
  }

  /**
   * RecurringJob findFirst
   */
  export type RecurringJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * Filter, which RecurringJob to fetch.
     */
    where?: RecurringJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringJobs to fetch.
     */
    orderBy?: RecurringJobOrderByWithRelationInput | RecurringJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringJobs.
     */
    cursor?: RecurringJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringJobs.
     */
    distinct?: RecurringJobScalarFieldEnum | RecurringJobScalarFieldEnum[]
  }

  /**
   * RecurringJob findFirstOrThrow
   */
  export type RecurringJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * Filter, which RecurringJob to fetch.
     */
    where?: RecurringJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringJobs to fetch.
     */
    orderBy?: RecurringJobOrderByWithRelationInput | RecurringJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringJobs.
     */
    cursor?: RecurringJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringJobs.
     */
    distinct?: RecurringJobScalarFieldEnum | RecurringJobScalarFieldEnum[]
  }

  /**
   * RecurringJob findMany
   */
  export type RecurringJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * Filter, which RecurringJobs to fetch.
     */
    where?: RecurringJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringJobs to fetch.
     */
    orderBy?: RecurringJobOrderByWithRelationInput | RecurringJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringJobs.
     */
    cursor?: RecurringJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringJobs.
     */
    skip?: number
    distinct?: RecurringJobScalarFieldEnum | RecurringJobScalarFieldEnum[]
  }

  /**
   * RecurringJob create
   */
  export type RecurringJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * The data needed to create a RecurringJob.
     */
    data: XOR<RecurringJobCreateInput, RecurringJobUncheckedCreateInput>
  }

  /**
   * RecurringJob createMany
   */
  export type RecurringJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringJobs.
     */
    data: RecurringJobCreateManyInput | RecurringJobCreateManyInput[]
  }

  /**
   * RecurringJob createManyAndReturn
   */
  export type RecurringJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecurringJobs.
     */
    data: RecurringJobCreateManyInput | RecurringJobCreateManyInput[]
  }

  /**
   * RecurringJob update
   */
  export type RecurringJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * The data needed to update a RecurringJob.
     */
    data: XOR<RecurringJobUpdateInput, RecurringJobUncheckedUpdateInput>
    /**
     * Choose, which RecurringJob to update.
     */
    where: RecurringJobWhereUniqueInput
  }

  /**
   * RecurringJob updateMany
   */
  export type RecurringJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringJobs.
     */
    data: XOR<RecurringJobUpdateManyMutationInput, RecurringJobUncheckedUpdateManyInput>
    /**
     * Filter which RecurringJobs to update
     */
    where?: RecurringJobWhereInput
  }

  /**
   * RecurringJob upsert
   */
  export type RecurringJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * The filter to search for the RecurringJob to update in case it exists.
     */
    where: RecurringJobWhereUniqueInput
    /**
     * In case the RecurringJob found by the `where` argument doesn't exist, create a new RecurringJob with this data.
     */
    create: XOR<RecurringJobCreateInput, RecurringJobUncheckedCreateInput>
    /**
     * In case the RecurringJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringJobUpdateInput, RecurringJobUncheckedUpdateInput>
  }

  /**
   * RecurringJob delete
   */
  export type RecurringJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
    /**
     * Filter which RecurringJob to delete.
     */
    where: RecurringJobWhereUniqueInput
  }

  /**
   * RecurringJob deleteMany
   */
  export type RecurringJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringJobs to delete
     */
    where?: RecurringJobWhereInput
  }

  /**
   * RecurringJob without action
   */
  export type RecurringJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringJob
     */
    select?: RecurringJobSelect<ExtArgs> | null
  }


  /**
   * Model SyncOperation
   */

  export type AggregateSyncOperation = {
    _count: SyncOperationCountAggregateOutputType | null
    _min: SyncOperationMinAggregateOutputType | null
    _max: SyncOperationMaxAggregateOutputType | null
  }

  export type SyncOperationMinAggregateOutputType = {
    id: string | null
    direction: string | null
    strategy: string | null
    status: string | null
    progress: string | null
    result: string | null
    error: string | null
    config: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    connectionId: string | null
    initiatedBy: string | null
  }

  export type SyncOperationMaxAggregateOutputType = {
    id: string | null
    direction: string | null
    strategy: string | null
    status: string | null
    progress: string | null
    result: string | null
    error: string | null
    config: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    connectionId: string | null
    initiatedBy: string | null
  }

  export type SyncOperationCountAggregateOutputType = {
    id: number
    direction: number
    strategy: number
    status: number
    progress: number
    result: number
    error: number
    config: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    projectId: number
    connectionId: number
    initiatedBy: number
    _all: number
  }


  export type SyncOperationMinAggregateInputType = {
    id?: true
    direction?: true
    strategy?: true
    status?: true
    progress?: true
    result?: true
    error?: true
    config?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    connectionId?: true
    initiatedBy?: true
  }

  export type SyncOperationMaxAggregateInputType = {
    id?: true
    direction?: true
    strategy?: true
    status?: true
    progress?: true
    result?: true
    error?: true
    config?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    connectionId?: true
    initiatedBy?: true
  }

  export type SyncOperationCountAggregateInputType = {
    id?: true
    direction?: true
    strategy?: true
    status?: true
    progress?: true
    result?: true
    error?: true
    config?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    connectionId?: true
    initiatedBy?: true
    _all?: true
  }

  export type SyncOperationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncOperation to aggregate.
     */
    where?: SyncOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncOperations to fetch.
     */
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncOperations
    **/
    _count?: true | SyncOperationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncOperationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncOperationMaxAggregateInputType
  }

  export type GetSyncOperationAggregateType<T extends SyncOperationAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncOperation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncOperation[P]>
      : GetScalarType<T[P], AggregateSyncOperation[P]>
  }




  export type SyncOperationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncOperationWhereInput
    orderBy?: SyncOperationOrderByWithAggregationInput | SyncOperationOrderByWithAggregationInput[]
    by: SyncOperationScalarFieldEnum[] | SyncOperationScalarFieldEnum
    having?: SyncOperationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncOperationCountAggregateInputType | true
    _min?: SyncOperationMinAggregateInputType
    _max?: SyncOperationMaxAggregateInputType
  }

  export type SyncOperationGroupByOutputType = {
    id: string
    direction: string
    strategy: string
    status: string
    progress: string
    result: string | null
    error: string | null
    config: string
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    connectionId: string
    initiatedBy: string
    _count: SyncOperationCountAggregateOutputType | null
    _min: SyncOperationMinAggregateOutputType | null
    _max: SyncOperationMaxAggregateOutputType | null
  }

  type GetSyncOperationGroupByPayload<T extends SyncOperationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncOperationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncOperationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncOperationGroupByOutputType[P]>
            : GetScalarType<T[P], SyncOperationGroupByOutputType[P]>
        }
      >
    >


  export type SyncOperationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    direction?: boolean
    strategy?: boolean
    status?: boolean
    progress?: boolean
    result?: boolean
    error?: boolean
    config?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    connectionId?: boolean
    initiatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    connection?: boolean | AppIntegrationDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncOperation"]>

  export type SyncOperationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    direction?: boolean
    strategy?: boolean
    status?: boolean
    progress?: boolean
    result?: boolean
    error?: boolean
    config?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    connectionId?: boolean
    initiatedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    connection?: boolean | AppIntegrationDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncOperation"]>

  export type SyncOperationSelectScalar = {
    id?: boolean
    direction?: boolean
    strategy?: boolean
    status?: boolean
    progress?: boolean
    result?: boolean
    error?: boolean
    config?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    connectionId?: boolean
    initiatedBy?: boolean
  }

  export type SyncOperationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    connection?: boolean | AppIntegrationDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SyncOperationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    connection?: boolean | AppIntegrationDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SyncOperationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncOperation"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      connection: Prisma.$AppIntegrationPayload<ExtArgs>
      initiator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      direction: string
      strategy: string
      status: string
      progress: string
      result: string | null
      error: string | null
      config: string
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      connectionId: string
      initiatedBy: string
    }, ExtArgs["result"]["syncOperation"]>
    composites: {}
  }

  type SyncOperationGetPayload<S extends boolean | null | undefined | SyncOperationDefaultArgs> = $Result.GetResult<Prisma.$SyncOperationPayload, S>

  type SyncOperationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncOperationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncOperationCountAggregateInputType | true
    }

  export interface SyncOperationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncOperation'], meta: { name: 'SyncOperation' } }
    /**
     * Find zero or one SyncOperation that matches the filter.
     * @param {SyncOperationFindUniqueArgs} args - Arguments to find a SyncOperation
     * @example
     * // Get one SyncOperation
     * const syncOperation = await prisma.syncOperation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncOperationFindUniqueArgs>(args: SelectSubset<T, SyncOperationFindUniqueArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncOperation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncOperationFindUniqueOrThrowArgs} args - Arguments to find a SyncOperation
     * @example
     * // Get one SyncOperation
     * const syncOperation = await prisma.syncOperation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncOperationFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncOperationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncOperation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationFindFirstArgs} args - Arguments to find a SyncOperation
     * @example
     * // Get one SyncOperation
     * const syncOperation = await prisma.syncOperation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncOperationFindFirstArgs>(args?: SelectSubset<T, SyncOperationFindFirstArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncOperation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationFindFirstOrThrowArgs} args - Arguments to find a SyncOperation
     * @example
     * // Get one SyncOperation
     * const syncOperation = await prisma.syncOperation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncOperationFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncOperationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncOperations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncOperations
     * const syncOperations = await prisma.syncOperation.findMany()
     * 
     * // Get first 10 SyncOperations
     * const syncOperations = await prisma.syncOperation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncOperationWithIdOnly = await prisma.syncOperation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncOperationFindManyArgs>(args?: SelectSubset<T, SyncOperationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncOperation.
     * @param {SyncOperationCreateArgs} args - Arguments to create a SyncOperation.
     * @example
     * // Create one SyncOperation
     * const SyncOperation = await prisma.syncOperation.create({
     *   data: {
     *     // ... data to create a SyncOperation
     *   }
     * })
     * 
     */
    create<T extends SyncOperationCreateArgs>(args: SelectSubset<T, SyncOperationCreateArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncOperations.
     * @param {SyncOperationCreateManyArgs} args - Arguments to create many SyncOperations.
     * @example
     * // Create many SyncOperations
     * const syncOperation = await prisma.syncOperation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncOperationCreateManyArgs>(args?: SelectSubset<T, SyncOperationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncOperations and returns the data saved in the database.
     * @param {SyncOperationCreateManyAndReturnArgs} args - Arguments to create many SyncOperations.
     * @example
     * // Create many SyncOperations
     * const syncOperation = await prisma.syncOperation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncOperations and only return the `id`
     * const syncOperationWithIdOnly = await prisma.syncOperation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncOperationCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncOperationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncOperation.
     * @param {SyncOperationDeleteArgs} args - Arguments to delete one SyncOperation.
     * @example
     * // Delete one SyncOperation
     * const SyncOperation = await prisma.syncOperation.delete({
     *   where: {
     *     // ... filter to delete one SyncOperation
     *   }
     * })
     * 
     */
    delete<T extends SyncOperationDeleteArgs>(args: SelectSubset<T, SyncOperationDeleteArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncOperation.
     * @param {SyncOperationUpdateArgs} args - Arguments to update one SyncOperation.
     * @example
     * // Update one SyncOperation
     * const syncOperation = await prisma.syncOperation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncOperationUpdateArgs>(args: SelectSubset<T, SyncOperationUpdateArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncOperations.
     * @param {SyncOperationDeleteManyArgs} args - Arguments to filter SyncOperations to delete.
     * @example
     * // Delete a few SyncOperations
     * const { count } = await prisma.syncOperation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncOperationDeleteManyArgs>(args?: SelectSubset<T, SyncOperationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncOperations
     * const syncOperation = await prisma.syncOperation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncOperationUpdateManyArgs>(args: SelectSubset<T, SyncOperationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncOperation.
     * @param {SyncOperationUpsertArgs} args - Arguments to update or create a SyncOperation.
     * @example
     * // Update or create a SyncOperation
     * const syncOperation = await prisma.syncOperation.upsert({
     *   create: {
     *     // ... data to create a SyncOperation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncOperation we want to update
     *   }
     * })
     */
    upsert<T extends SyncOperationUpsertArgs>(args: SelectSubset<T, SyncOperationUpsertArgs<ExtArgs>>): Prisma__SyncOperationClient<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncOperations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationCountArgs} args - Arguments to filter SyncOperations to count.
     * @example
     * // Count the number of SyncOperations
     * const count = await prisma.syncOperation.count({
     *   where: {
     *     // ... the filter for the SyncOperations we want to count
     *   }
     * })
    **/
    count<T extends SyncOperationCountArgs>(
      args?: Subset<T, SyncOperationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncOperationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncOperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncOperationAggregateArgs>(args: Subset<T, SyncOperationAggregateArgs>): Prisma.PrismaPromise<GetSyncOperationAggregateType<T>>

    /**
     * Group by SyncOperation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncOperationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncOperationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncOperationGroupByArgs['orderBy'] }
        : { orderBy?: SyncOperationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncOperationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncOperationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncOperation model
   */
  readonly fields: SyncOperationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncOperation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncOperationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    connection<T extends AppIntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppIntegrationDefaultArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    initiator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncOperation model
   */ 
  interface SyncOperationFieldRefs {
    readonly id: FieldRef<"SyncOperation", 'String'>
    readonly direction: FieldRef<"SyncOperation", 'String'>
    readonly strategy: FieldRef<"SyncOperation", 'String'>
    readonly status: FieldRef<"SyncOperation", 'String'>
    readonly progress: FieldRef<"SyncOperation", 'String'>
    readonly result: FieldRef<"SyncOperation", 'String'>
    readonly error: FieldRef<"SyncOperation", 'String'>
    readonly config: FieldRef<"SyncOperation", 'String'>
    readonly startedAt: FieldRef<"SyncOperation", 'DateTime'>
    readonly completedAt: FieldRef<"SyncOperation", 'DateTime'>
    readonly createdAt: FieldRef<"SyncOperation", 'DateTime'>
    readonly updatedAt: FieldRef<"SyncOperation", 'DateTime'>
    readonly projectId: FieldRef<"SyncOperation", 'String'>
    readonly connectionId: FieldRef<"SyncOperation", 'String'>
    readonly initiatedBy: FieldRef<"SyncOperation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncOperation findUnique
   */
  export type SyncOperationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * Filter, which SyncOperation to fetch.
     */
    where: SyncOperationWhereUniqueInput
  }

  /**
   * SyncOperation findUniqueOrThrow
   */
  export type SyncOperationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * Filter, which SyncOperation to fetch.
     */
    where: SyncOperationWhereUniqueInput
  }

  /**
   * SyncOperation findFirst
   */
  export type SyncOperationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * Filter, which SyncOperation to fetch.
     */
    where?: SyncOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncOperations to fetch.
     */
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncOperations.
     */
    cursor?: SyncOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncOperations.
     */
    distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[]
  }

  /**
   * SyncOperation findFirstOrThrow
   */
  export type SyncOperationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * Filter, which SyncOperation to fetch.
     */
    where?: SyncOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncOperations to fetch.
     */
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncOperations.
     */
    cursor?: SyncOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncOperations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncOperations.
     */
    distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[]
  }

  /**
   * SyncOperation findMany
   */
  export type SyncOperationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * Filter, which SyncOperations to fetch.
     */
    where?: SyncOperationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncOperations to fetch.
     */
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncOperations.
     */
    cursor?: SyncOperationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncOperations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncOperations.
     */
    skip?: number
    distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[]
  }

  /**
   * SyncOperation create
   */
  export type SyncOperationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * The data needed to create a SyncOperation.
     */
    data: XOR<SyncOperationCreateInput, SyncOperationUncheckedCreateInput>
  }

  /**
   * SyncOperation createMany
   */
  export type SyncOperationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncOperations.
     */
    data: SyncOperationCreateManyInput | SyncOperationCreateManyInput[]
  }

  /**
   * SyncOperation createManyAndReturn
   */
  export type SyncOperationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncOperations.
     */
    data: SyncOperationCreateManyInput | SyncOperationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncOperation update
   */
  export type SyncOperationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * The data needed to update a SyncOperation.
     */
    data: XOR<SyncOperationUpdateInput, SyncOperationUncheckedUpdateInput>
    /**
     * Choose, which SyncOperation to update.
     */
    where: SyncOperationWhereUniqueInput
  }

  /**
   * SyncOperation updateMany
   */
  export type SyncOperationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncOperations.
     */
    data: XOR<SyncOperationUpdateManyMutationInput, SyncOperationUncheckedUpdateManyInput>
    /**
     * Filter which SyncOperations to update
     */
    where?: SyncOperationWhereInput
  }

  /**
   * SyncOperation upsert
   */
  export type SyncOperationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * The filter to search for the SyncOperation to update in case it exists.
     */
    where: SyncOperationWhereUniqueInput
    /**
     * In case the SyncOperation found by the `where` argument doesn't exist, create a new SyncOperation with this data.
     */
    create: XOR<SyncOperationCreateInput, SyncOperationUncheckedCreateInput>
    /**
     * In case the SyncOperation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncOperationUpdateInput, SyncOperationUncheckedUpdateInput>
  }

  /**
   * SyncOperation delete
   */
  export type SyncOperationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    /**
     * Filter which SyncOperation to delete.
     */
    where: SyncOperationWhereUniqueInput
  }

  /**
   * SyncOperation deleteMany
   */
  export type SyncOperationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncOperations to delete
     */
    where?: SyncOperationWhereInput
  }

  /**
   * SyncOperation without action
   */
  export type SyncOperationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
  }


  /**
   * Model WebhookSubscription
   */

  export type AggregateWebhookSubscription = {
    _count: WebhookSubscriptionCountAggregateOutputType | null
    _avg: WebhookSubscriptionAvgAggregateOutputType | null
    _sum: WebhookSubscriptionSumAggregateOutputType | null
    _min: WebhookSubscriptionMinAggregateOutputType | null
    _max: WebhookSubscriptionMaxAggregateOutputType | null
  }

  export type WebhookSubscriptionAvgAggregateOutputType = {
    retryAttempts: number | null
  }

  export type WebhookSubscriptionSumAggregateOutputType = {
    retryAttempts: number | null
  }

  export type WebhookSubscriptionMinAggregateOutputType = {
    id: string | null
    url: string | null
    events: string | null
    headers: string | null
    secret: string | null
    enabled: boolean | null
    retryAttempts: number | null
    lastDelivery: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type WebhookSubscriptionMaxAggregateOutputType = {
    id: string | null
    url: string | null
    events: string | null
    headers: string | null
    secret: string | null
    enabled: boolean | null
    retryAttempts: number | null
    lastDelivery: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type WebhookSubscriptionCountAggregateOutputType = {
    id: number
    url: number
    events: number
    headers: number
    secret: number
    enabled: number
    retryAttempts: number
    lastDelivery: number
    createdAt: number
    updatedAt: number
    projectId: number
    createdBy: number
    _all: number
  }


  export type WebhookSubscriptionAvgAggregateInputType = {
    retryAttempts?: true
  }

  export type WebhookSubscriptionSumAggregateInputType = {
    retryAttempts?: true
  }

  export type WebhookSubscriptionMinAggregateInputType = {
    id?: true
    url?: true
    events?: true
    headers?: true
    secret?: true
    enabled?: true
    retryAttempts?: true
    lastDelivery?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type WebhookSubscriptionMaxAggregateInputType = {
    id?: true
    url?: true
    events?: true
    headers?: true
    secret?: true
    enabled?: true
    retryAttempts?: true
    lastDelivery?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type WebhookSubscriptionCountAggregateInputType = {
    id?: true
    url?: true
    events?: true
    headers?: true
    secret?: true
    enabled?: true
    retryAttempts?: true
    lastDelivery?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    _all?: true
  }

  export type WebhookSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookSubscription to aggregate.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookSubscriptions
    **/
    _count?: true | WebhookSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookSubscriptionMaxAggregateInputType
  }

  export type GetWebhookSubscriptionAggregateType<T extends WebhookSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookSubscription[P]>
      : GetScalarType<T[P], AggregateWebhookSubscription[P]>
  }




  export type WebhookSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookSubscriptionWhereInput
    orderBy?: WebhookSubscriptionOrderByWithAggregationInput | WebhookSubscriptionOrderByWithAggregationInput[]
    by: WebhookSubscriptionScalarFieldEnum[] | WebhookSubscriptionScalarFieldEnum
    having?: WebhookSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookSubscriptionCountAggregateInputType | true
    _avg?: WebhookSubscriptionAvgAggregateInputType
    _sum?: WebhookSubscriptionSumAggregateInputType
    _min?: WebhookSubscriptionMinAggregateInputType
    _max?: WebhookSubscriptionMaxAggregateInputType
  }

  export type WebhookSubscriptionGroupByOutputType = {
    id: string
    url: string
    events: string
    headers: string
    secret: string | null
    enabled: boolean
    retryAttempts: number
    lastDelivery: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string | null
    createdBy: string
    _count: WebhookSubscriptionCountAggregateOutputType | null
    _avg: WebhookSubscriptionAvgAggregateOutputType | null
    _sum: WebhookSubscriptionSumAggregateOutputType | null
    _min: WebhookSubscriptionMinAggregateOutputType | null
    _max: WebhookSubscriptionMaxAggregateOutputType | null
  }

  type GetWebhookSubscriptionGroupByPayload<T extends WebhookSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    events?: boolean
    headers?: boolean
    secret?: boolean
    enabled?: boolean
    retryAttempts?: boolean
    lastDelivery?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | WebhookSubscription$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    deliveries?: boolean | WebhookSubscription$deliveriesArgs<ExtArgs>
    failedDeliveries?: boolean | WebhookSubscription$failedDeliveriesArgs<ExtArgs>
    _count?: boolean | WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookSubscription"]>

  export type WebhookSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    events?: boolean
    headers?: boolean
    secret?: boolean
    enabled?: boolean
    retryAttempts?: boolean
    lastDelivery?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | WebhookSubscription$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookSubscription"]>

  export type WebhookSubscriptionSelectScalar = {
    id?: boolean
    url?: boolean
    events?: boolean
    headers?: boolean
    secret?: boolean
    enabled?: boolean
    retryAttempts?: boolean
    lastDelivery?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
  }

  export type WebhookSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | WebhookSubscription$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    deliveries?: boolean | WebhookSubscription$deliveriesArgs<ExtArgs>
    failedDeliveries?: boolean | WebhookSubscription$failedDeliveriesArgs<ExtArgs>
    _count?: boolean | WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | WebhookSubscription$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WebhookSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookSubscription"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
      failedDeliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      events: string
      headers: string
      secret: string | null
      enabled: boolean
      retryAttempts: number
      lastDelivery: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string | null
      createdBy: string
    }, ExtArgs["result"]["webhookSubscription"]>
    composites: {}
  }

  type WebhookSubscriptionGetPayload<S extends boolean | null | undefined | WebhookSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$WebhookSubscriptionPayload, S>

  type WebhookSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookSubscriptionCountAggregateInputType | true
    }

  export interface WebhookSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookSubscription'], meta: { name: 'WebhookSubscription' } }
    /**
     * Find zero or one WebhookSubscription that matches the filter.
     * @param {WebhookSubscriptionFindUniqueArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookSubscriptionFindUniqueArgs>(args: SelectSubset<T, WebhookSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionFindFirstArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookSubscriptionFindFirstArgs>(args?: SelectSubset<T, WebhookSubscriptionFindFirstArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionFindFirstOrThrowArgs} args - Arguments to find a WebhookSubscription
     * @example
     * // Get one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookSubscriptions
     * const webhookSubscriptions = await prisma.webhookSubscription.findMany()
     * 
     * // Get first 10 WebhookSubscriptions
     * const webhookSubscriptions = await prisma.webhookSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookSubscriptionWithIdOnly = await prisma.webhookSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookSubscriptionFindManyArgs>(args?: SelectSubset<T, WebhookSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookSubscription.
     * @param {WebhookSubscriptionCreateArgs} args - Arguments to create a WebhookSubscription.
     * @example
     * // Create one WebhookSubscription
     * const WebhookSubscription = await prisma.webhookSubscription.create({
     *   data: {
     *     // ... data to create a WebhookSubscription
     *   }
     * })
     * 
     */
    create<T extends WebhookSubscriptionCreateArgs>(args: SelectSubset<T, WebhookSubscriptionCreateArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookSubscriptions.
     * @param {WebhookSubscriptionCreateManyArgs} args - Arguments to create many WebhookSubscriptions.
     * @example
     * // Create many WebhookSubscriptions
     * const webhookSubscription = await prisma.webhookSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookSubscriptionCreateManyArgs>(args?: SelectSubset<T, WebhookSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookSubscriptions and returns the data saved in the database.
     * @param {WebhookSubscriptionCreateManyAndReturnArgs} args - Arguments to create many WebhookSubscriptions.
     * @example
     * // Create many WebhookSubscriptions
     * const webhookSubscription = await prisma.webhookSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookSubscriptions and only return the `id`
     * const webhookSubscriptionWithIdOnly = await prisma.webhookSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookSubscription.
     * @param {WebhookSubscriptionDeleteArgs} args - Arguments to delete one WebhookSubscription.
     * @example
     * // Delete one WebhookSubscription
     * const WebhookSubscription = await prisma.webhookSubscription.delete({
     *   where: {
     *     // ... filter to delete one WebhookSubscription
     *   }
     * })
     * 
     */
    delete<T extends WebhookSubscriptionDeleteArgs>(args: SelectSubset<T, WebhookSubscriptionDeleteArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookSubscription.
     * @param {WebhookSubscriptionUpdateArgs} args - Arguments to update one WebhookSubscription.
     * @example
     * // Update one WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookSubscriptionUpdateArgs>(args: SelectSubset<T, WebhookSubscriptionUpdateArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookSubscriptions.
     * @param {WebhookSubscriptionDeleteManyArgs} args - Arguments to filter WebhookSubscriptions to delete.
     * @example
     * // Delete a few WebhookSubscriptions
     * const { count } = await prisma.webhookSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookSubscriptionDeleteManyArgs>(args?: SelectSubset<T, WebhookSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookSubscriptions
     * const webhookSubscription = await prisma.webhookSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookSubscriptionUpdateManyArgs>(args: SelectSubset<T, WebhookSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookSubscription.
     * @param {WebhookSubscriptionUpsertArgs} args - Arguments to update or create a WebhookSubscription.
     * @example
     * // Update or create a WebhookSubscription
     * const webhookSubscription = await prisma.webhookSubscription.upsert({
     *   create: {
     *     // ... data to create a WebhookSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookSubscription we want to update
     *   }
     * })
     */
    upsert<T extends WebhookSubscriptionUpsertArgs>(args: SelectSubset<T, WebhookSubscriptionUpsertArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionCountArgs} args - Arguments to filter WebhookSubscriptions to count.
     * @example
     * // Count the number of WebhookSubscriptions
     * const count = await prisma.webhookSubscription.count({
     *   where: {
     *     // ... the filter for the WebhookSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends WebhookSubscriptionCountArgs>(
      args?: Subset<T, WebhookSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookSubscriptionAggregateArgs>(args: Subset<T, WebhookSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetWebhookSubscriptionAggregateType<T>>

    /**
     * Group by WebhookSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: WebhookSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookSubscription model
   */
  readonly fields: WebhookSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends WebhookSubscription$projectArgs<ExtArgs> = {}>(args?: Subset<T, WebhookSubscription$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deliveries<T extends WebhookSubscription$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, WebhookSubscription$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    failedDeliveries<T extends WebhookSubscription$failedDeliveriesArgs<ExtArgs> = {}>(args?: Subset<T, WebhookSubscription$failedDeliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookSubscription model
   */ 
  interface WebhookSubscriptionFieldRefs {
    readonly id: FieldRef<"WebhookSubscription", 'String'>
    readonly url: FieldRef<"WebhookSubscription", 'String'>
    readonly events: FieldRef<"WebhookSubscription", 'String'>
    readonly headers: FieldRef<"WebhookSubscription", 'String'>
    readonly secret: FieldRef<"WebhookSubscription", 'String'>
    readonly enabled: FieldRef<"WebhookSubscription", 'Boolean'>
    readonly retryAttempts: FieldRef<"WebhookSubscription", 'Int'>
    readonly lastDelivery: FieldRef<"WebhookSubscription", 'DateTime'>
    readonly createdAt: FieldRef<"WebhookSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookSubscription", 'DateTime'>
    readonly projectId: FieldRef<"WebhookSubscription", 'String'>
    readonly createdBy: FieldRef<"WebhookSubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WebhookSubscription findUnique
   */
  export type WebhookSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription findUniqueOrThrow
   */
  export type WebhookSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription findFirst
   */
  export type WebhookSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookSubscriptions.
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookSubscriptions.
     */
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * WebhookSubscription findFirstOrThrow
   */
  export type WebhookSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscription to fetch.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookSubscriptions.
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookSubscriptions.
     */
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * WebhookSubscription findMany
   */
  export type WebhookSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookSubscriptions to fetch.
     */
    where?: WebhookSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookSubscriptions to fetch.
     */
    orderBy?: WebhookSubscriptionOrderByWithRelationInput | WebhookSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookSubscriptions.
     */
    cursor?: WebhookSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookSubscriptions.
     */
    skip?: number
    distinct?: WebhookSubscriptionScalarFieldEnum | WebhookSubscriptionScalarFieldEnum[]
  }

  /**
   * WebhookSubscription create
   */
  export type WebhookSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookSubscription.
     */
    data: XOR<WebhookSubscriptionCreateInput, WebhookSubscriptionUncheckedCreateInput>
  }

  /**
   * WebhookSubscription createMany
   */
  export type WebhookSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookSubscriptions.
     */
    data: WebhookSubscriptionCreateManyInput | WebhookSubscriptionCreateManyInput[]
  }

  /**
   * WebhookSubscription createManyAndReturn
   */
  export type WebhookSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookSubscriptions.
     */
    data: WebhookSubscriptionCreateManyInput | WebhookSubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookSubscription update
   */
  export type WebhookSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookSubscription.
     */
    data: XOR<WebhookSubscriptionUpdateInput, WebhookSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which WebhookSubscription to update.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription updateMany
   */
  export type WebhookSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookSubscriptions.
     */
    data: XOR<WebhookSubscriptionUpdateManyMutationInput, WebhookSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which WebhookSubscriptions to update
     */
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * WebhookSubscription upsert
   */
  export type WebhookSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookSubscription to update in case it exists.
     */
    where: WebhookSubscriptionWhereUniqueInput
    /**
     * In case the WebhookSubscription found by the `where` argument doesn't exist, create a new WebhookSubscription with this data.
     */
    create: XOR<WebhookSubscriptionCreateInput, WebhookSubscriptionUncheckedCreateInput>
    /**
     * In case the WebhookSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookSubscriptionUpdateInput, WebhookSubscriptionUncheckedUpdateInput>
  }

  /**
   * WebhookSubscription delete
   */
  export type WebhookSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which WebhookSubscription to delete.
     */
    where: WebhookSubscriptionWhereUniqueInput
  }

  /**
   * WebhookSubscription deleteMany
   */
  export type WebhookSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookSubscriptions to delete
     */
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * WebhookSubscription.project
   */
  export type WebhookSubscription$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * WebhookSubscription.deliveries
   */
  export type WebhookSubscription$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookSubscription.failedDeliveries
   */
  export type WebhookSubscription$failedDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookSubscription without action
   */
  export type WebhookSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    attempts: number | null
    maxAttempts: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    attempts: number | null
    maxAttempts: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    url: string | null
    payload: string | null
    headers: string | null
    status: string | null
    attempts: number | null
    maxAttempts: number | null
    response: string | null
    error: string | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    eventType: string | null
    projectId: string | null
    webhookId: string | null
    failedWebhookId: string | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    url: string | null
    payload: string | null
    headers: string | null
    status: string | null
    attempts: number | null
    maxAttempts: number | null
    response: string | null
    error: string | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    eventType: string | null
    projectId: string | null
    webhookId: string | null
    failedWebhookId: string | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    url: number
    payload: number
    headers: number
    status: number
    attempts: number
    maxAttempts: number
    response: number
    error: number
    deliveredAt: number
    createdAt: number
    updatedAt: number
    eventType: number
    projectId: number
    webhookId: number
    failedWebhookId: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    attempts?: true
    maxAttempts?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    attempts?: true
    maxAttempts?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    url?: true
    payload?: true
    headers?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    response?: true
    error?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    eventType?: true
    projectId?: true
    webhookId?: true
    failedWebhookId?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    url?: true
    payload?: true
    headers?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    response?: true
    error?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    eventType?: true
    projectId?: true
    webhookId?: true
    failedWebhookId?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    url?: true
    payload?: true
    headers?: true
    status?: true
    attempts?: true
    maxAttempts?: true
    response?: true
    error?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    eventType?: true
    projectId?: true
    webhookId?: true
    failedWebhookId?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    url: string
    payload: string
    headers: string | null
    status: string
    attempts: number
    maxAttempts: number
    response: string | null
    error: string | null
    deliveredAt: Date | null
    createdAt: Date
    updatedAt: Date
    eventType: string
    projectId: string | null
    webhookId: string | null
    failedWebhookId: string | null
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    payload?: boolean
    headers?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    response?: boolean
    error?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventType?: boolean
    projectId?: boolean
    webhookId?: boolean
    failedWebhookId?: boolean
    project?: boolean | WebhookDelivery$projectArgs<ExtArgs>
    webhook?: boolean | WebhookDelivery$webhookArgs<ExtArgs>
    failedWebhook?: boolean | WebhookDelivery$failedWebhookArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    payload?: boolean
    headers?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    response?: boolean
    error?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventType?: boolean
    projectId?: boolean
    webhookId?: boolean
    failedWebhookId?: boolean
    project?: boolean | WebhookDelivery$projectArgs<ExtArgs>
    webhook?: boolean | WebhookDelivery$webhookArgs<ExtArgs>
    failedWebhook?: boolean | WebhookDelivery$failedWebhookArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    url?: boolean
    payload?: boolean
    headers?: boolean
    status?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    response?: boolean
    error?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eventType?: boolean
    projectId?: boolean
    webhookId?: boolean
    failedWebhookId?: boolean
  }

  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | WebhookDelivery$projectArgs<ExtArgs>
    webhook?: boolean | WebhookDelivery$webhookArgs<ExtArgs>
    failedWebhook?: boolean | WebhookDelivery$failedWebhookArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | WebhookDelivery$projectArgs<ExtArgs>
    webhook?: boolean | WebhookDelivery$webhookArgs<ExtArgs>
    failedWebhook?: boolean | WebhookDelivery$failedWebhookArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      webhook: Prisma.$WebhookSubscriptionPayload<ExtArgs> | null
      failedWebhook: Prisma.$WebhookSubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      payload: string
      headers: string | null
      status: string
      attempts: number
      maxAttempts: number
      response: string | null
      error: string | null
      deliveredAt: Date | null
      createdAt: Date
      updatedAt: Date
      eventType: string
      projectId: string | null
      webhookId: string | null
      failedWebhookId: string | null
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends WebhookDelivery$projectArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDelivery$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    webhook<T extends WebhookDelivery$webhookArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDelivery$webhookArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    failedWebhook<T extends WebhookDelivery$failedWebhookArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDelivery$failedWebhookArgs<ExtArgs>>): Prisma__WebhookSubscriptionClient<$Result.GetResult<Prisma.$WebhookSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */ 
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly url: FieldRef<"WebhookDelivery", 'String'>
    readonly payload: FieldRef<"WebhookDelivery", 'String'>
    readonly headers: FieldRef<"WebhookDelivery", 'String'>
    readonly status: FieldRef<"WebhookDelivery", 'String'>
    readonly attempts: FieldRef<"WebhookDelivery", 'Int'>
    readonly maxAttempts: FieldRef<"WebhookDelivery", 'Int'>
    readonly response: FieldRef<"WebhookDelivery", 'String'>
    readonly error: FieldRef<"WebhookDelivery", 'String'>
    readonly deliveredAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly createdAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly updatedAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly eventType: FieldRef<"WebhookDelivery", 'String'>
    readonly projectId: FieldRef<"WebhookDelivery", 'String'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly failedWebhookId: FieldRef<"WebhookDelivery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
  }

  /**
   * WebhookDelivery.project
   */
  export type WebhookDelivery$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * WebhookDelivery.webhook
   */
  export type WebhookDelivery$webhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * WebhookDelivery.failedWebhook
   */
  export type WebhookDelivery$failedWebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookSubscription
     */
    select?: WebhookSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookSubscriptionInclude<ExtArgs> | null
    where?: WebhookSubscriptionWhereInput
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    name: string | null
    provider: string | null
    keyHash: string | null
    isActive: boolean | null
    lastUsed: Date | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    provider: string | null
    keyHash: string | null
    isActive: boolean | null
    lastUsed: Date | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    name: number
    provider: number
    keyHash: number
    isActive: number
    lastUsed: number
    usageCount: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeySumAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    keyHash?: true
    isActive?: true
    lastUsed?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    keyHash?: true
    isActive?: true
    lastUsed?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    keyHash?: true
    isActive?: true
    lastUsed?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    name: string
    provider: string
    keyHash: string
    isActive: boolean
    lastUsed: Date | null
    usageCount: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    keyHash?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    keyHash?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    name?: boolean
    provider?: boolean
    keyHash?: boolean
    isActive?: boolean
    lastUsed?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      provider: string
      keyHash: string
      isActive: boolean
      lastUsed: Date | null
      usageCount: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly provider: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
    readonly lastUsed: FieldRef<"ApiKey", 'DateTime'>
    readonly usageCount: FieldRef<"ApiKey", 'Int'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly projectId: FieldRef<"ApiKey", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Environment
   */

  export type AggregateEnvironment = {
    _count: EnvironmentCountAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  export type EnvironmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    config: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type EnvironmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    config: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type EnvironmentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    config: number
    isActive: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type EnvironmentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    config?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type EnvironmentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    config?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type EnvironmentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    config?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type EnvironmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Environment to aggregate.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Environments
    **/
    _count?: true | EnvironmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvironmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvironmentMaxAggregateInputType
  }

  export type GetEnvironmentAggregateType<T extends EnvironmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvironment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvironment[P]>
      : GetScalarType<T[P], AggregateEnvironment[P]>
  }




  export type EnvironmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnvironmentWhereInput
    orderBy?: EnvironmentOrderByWithAggregationInput | EnvironmentOrderByWithAggregationInput[]
    by: EnvironmentScalarFieldEnum[] | EnvironmentScalarFieldEnum
    having?: EnvironmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvironmentCountAggregateInputType | true
    _min?: EnvironmentMinAggregateInputType
    _max?: EnvironmentMaxAggregateInputType
  }

  export type EnvironmentGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string | null
    config: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: EnvironmentCountAggregateOutputType | null
    _min: EnvironmentMinAggregateOutputType | null
    _max: EnvironmentMaxAggregateOutputType | null
  }

  type GetEnvironmentGroupByPayload<T extends EnvironmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvironmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvironmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnvironmentGroupByOutputType[P]>
        }
      >
    >


  export type EnvironmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    deployments?: boolean | Environment$deploymentsArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type EnvironmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["environment"]>

  export type EnvironmentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type EnvironmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    deployments?: boolean | Environment$deploymentsArgs<ExtArgs>
    _count?: boolean | EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnvironmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $EnvironmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Environment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      deployments: Prisma.$DeploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      description: string | null
      config: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["environment"]>
    composites: {}
  }

  type EnvironmentGetPayload<S extends boolean | null | undefined | EnvironmentDefaultArgs> = $Result.GetResult<Prisma.$EnvironmentPayload, S>

  type EnvironmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnvironmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnvironmentCountAggregateInputType | true
    }

  export interface EnvironmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Environment'], meta: { name: 'Environment' } }
    /**
     * Find zero or one Environment that matches the filter.
     * @param {EnvironmentFindUniqueArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnvironmentFindUniqueArgs>(args: SelectSubset<T, EnvironmentFindUniqueArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Environment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnvironmentFindUniqueOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnvironmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnvironmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Environment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindFirstArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnvironmentFindFirstArgs>(args?: SelectSubset<T, EnvironmentFindFirstArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Environment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindFirstOrThrowArgs} args - Arguments to find a Environment
     * @example
     * // Get one Environment
     * const environment = await prisma.environment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnvironmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnvironmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Environments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Environments
     * const environments = await prisma.environment.findMany()
     * 
     * // Get first 10 Environments
     * const environments = await prisma.environment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const environmentWithIdOnly = await prisma.environment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnvironmentFindManyArgs>(args?: SelectSubset<T, EnvironmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Environment.
     * @param {EnvironmentCreateArgs} args - Arguments to create a Environment.
     * @example
     * // Create one Environment
     * const Environment = await prisma.environment.create({
     *   data: {
     *     // ... data to create a Environment
     *   }
     * })
     * 
     */
    create<T extends EnvironmentCreateArgs>(args: SelectSubset<T, EnvironmentCreateArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Environments.
     * @param {EnvironmentCreateManyArgs} args - Arguments to create many Environments.
     * @example
     * // Create many Environments
     * const environment = await prisma.environment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnvironmentCreateManyArgs>(args?: SelectSubset<T, EnvironmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Environments and returns the data saved in the database.
     * @param {EnvironmentCreateManyAndReturnArgs} args - Arguments to create many Environments.
     * @example
     * // Create many Environments
     * const environment = await prisma.environment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Environments and only return the `id`
     * const environmentWithIdOnly = await prisma.environment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnvironmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnvironmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Environment.
     * @param {EnvironmentDeleteArgs} args - Arguments to delete one Environment.
     * @example
     * // Delete one Environment
     * const Environment = await prisma.environment.delete({
     *   where: {
     *     // ... filter to delete one Environment
     *   }
     * })
     * 
     */
    delete<T extends EnvironmentDeleteArgs>(args: SelectSubset<T, EnvironmentDeleteArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Environment.
     * @param {EnvironmentUpdateArgs} args - Arguments to update one Environment.
     * @example
     * // Update one Environment
     * const environment = await prisma.environment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnvironmentUpdateArgs>(args: SelectSubset<T, EnvironmentUpdateArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Environments.
     * @param {EnvironmentDeleteManyArgs} args - Arguments to filter Environments to delete.
     * @example
     * // Delete a few Environments
     * const { count } = await prisma.environment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnvironmentDeleteManyArgs>(args?: SelectSubset<T, EnvironmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Environments
     * const environment = await prisma.environment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnvironmentUpdateManyArgs>(args: SelectSubset<T, EnvironmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Environment.
     * @param {EnvironmentUpsertArgs} args - Arguments to update or create a Environment.
     * @example
     * // Update or create a Environment
     * const environment = await prisma.environment.upsert({
     *   create: {
     *     // ... data to create a Environment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Environment we want to update
     *   }
     * })
     */
    upsert<T extends EnvironmentUpsertArgs>(args: SelectSubset<T, EnvironmentUpsertArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Environments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentCountArgs} args - Arguments to filter Environments to count.
     * @example
     * // Count the number of Environments
     * const count = await prisma.environment.count({
     *   where: {
     *     // ... the filter for the Environments we want to count
     *   }
     * })
    **/
    count<T extends EnvironmentCountArgs>(
      args?: Subset<T, EnvironmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvironmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvironmentAggregateArgs>(args: Subset<T, EnvironmentAggregateArgs>): Prisma.PrismaPromise<GetEnvironmentAggregateType<T>>

    /**
     * Group by Environment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvironmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvironmentGroupByArgs['orderBy'] }
        : { orderBy?: EnvironmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvironmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Environment model
   */
  readonly fields: EnvironmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Environment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnvironmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deployments<T extends Environment$deploymentsArgs<ExtArgs> = {}>(args?: Subset<T, Environment$deploymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Environment model
   */ 
  interface EnvironmentFieldRefs {
    readonly id: FieldRef<"Environment", 'String'>
    readonly name: FieldRef<"Environment", 'String'>
    readonly type: FieldRef<"Environment", 'String'>
    readonly description: FieldRef<"Environment", 'String'>
    readonly config: FieldRef<"Environment", 'String'>
    readonly isActive: FieldRef<"Environment", 'Boolean'>
    readonly createdAt: FieldRef<"Environment", 'DateTime'>
    readonly updatedAt: FieldRef<"Environment", 'DateTime'>
    readonly projectId: FieldRef<"Environment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Environment findUnique
   */
  export type EnvironmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment findUniqueOrThrow
   */
  export type EnvironmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment findFirst
   */
  export type EnvironmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Environment findFirstOrThrow
   */
  export type EnvironmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environment to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Environments.
     */
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Environment findMany
   */
  export type EnvironmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter, which Environments to fetch.
     */
    where?: EnvironmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Environments to fetch.
     */
    orderBy?: EnvironmentOrderByWithRelationInput | EnvironmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Environments.
     */
    cursor?: EnvironmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Environments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Environments.
     */
    skip?: number
    distinct?: EnvironmentScalarFieldEnum | EnvironmentScalarFieldEnum[]
  }

  /**
   * Environment create
   */
  export type EnvironmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Environment.
     */
    data: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
  }

  /**
   * Environment createMany
   */
  export type EnvironmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Environments.
     */
    data: EnvironmentCreateManyInput | EnvironmentCreateManyInput[]
  }

  /**
   * Environment createManyAndReturn
   */
  export type EnvironmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Environments.
     */
    data: EnvironmentCreateManyInput | EnvironmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Environment update
   */
  export type EnvironmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Environment.
     */
    data: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
    /**
     * Choose, which Environment to update.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment updateMany
   */
  export type EnvironmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Environments.
     */
    data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyInput>
    /**
     * Filter which Environments to update
     */
    where?: EnvironmentWhereInput
  }

  /**
   * Environment upsert
   */
  export type EnvironmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Environment to update in case it exists.
     */
    where: EnvironmentWhereUniqueInput
    /**
     * In case the Environment found by the `where` argument doesn't exist, create a new Environment with this data.
     */
    create: XOR<EnvironmentCreateInput, EnvironmentUncheckedCreateInput>
    /**
     * In case the Environment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvironmentUpdateInput, EnvironmentUncheckedUpdateInput>
  }

  /**
   * Environment delete
   */
  export type EnvironmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
    /**
     * Filter which Environment to delete.
     */
    where: EnvironmentWhereUniqueInput
  }

  /**
   * Environment deleteMany
   */
  export type EnvironmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Environments to delete
     */
    where?: EnvironmentWhereInput
  }

  /**
   * Environment.deployments
   */
  export type Environment$deploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    cursor?: DeploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Environment without action
   */
  export type EnvironmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Environment
     */
    select?: EnvironmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnvironmentInclude<ExtArgs> | null
  }


  /**
   * Model Deployment
   */

  export type AggregateDeployment = {
    _count: DeploymentCountAggregateOutputType | null
    _min: DeploymentMinAggregateOutputType | null
    _max: DeploymentMaxAggregateOutputType | null
  }

  export type DeploymentMinAggregateOutputType = {
    id: string | null
    version: string | null
    status: string | null
    deployedUrl: string | null
    config: string | null
    metadata: string | null
    deployedAt: Date | null
    rollbackAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    promptId: string | null
    environmentId: string | null
    deployedBy: string | null
  }

  export type DeploymentMaxAggregateOutputType = {
    id: string | null
    version: string | null
    status: string | null
    deployedUrl: string | null
    config: string | null
    metadata: string | null
    deployedAt: Date | null
    rollbackAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    promptId: string | null
    environmentId: string | null
    deployedBy: string | null
  }

  export type DeploymentCountAggregateOutputType = {
    id: number
    version: number
    status: number
    deployedUrl: number
    config: number
    metadata: number
    deployedAt: number
    rollbackAt: number
    createdAt: number
    updatedAt: number
    promptId: number
    environmentId: number
    deployedBy: number
    _all: number
  }


  export type DeploymentMinAggregateInputType = {
    id?: true
    version?: true
    status?: true
    deployedUrl?: true
    config?: true
    metadata?: true
    deployedAt?: true
    rollbackAt?: true
    createdAt?: true
    updatedAt?: true
    promptId?: true
    environmentId?: true
    deployedBy?: true
  }

  export type DeploymentMaxAggregateInputType = {
    id?: true
    version?: true
    status?: true
    deployedUrl?: true
    config?: true
    metadata?: true
    deployedAt?: true
    rollbackAt?: true
    createdAt?: true
    updatedAt?: true
    promptId?: true
    environmentId?: true
    deployedBy?: true
  }

  export type DeploymentCountAggregateInputType = {
    id?: true
    version?: true
    status?: true
    deployedUrl?: true
    config?: true
    metadata?: true
    deployedAt?: true
    rollbackAt?: true
    createdAt?: true
    updatedAt?: true
    promptId?: true
    environmentId?: true
    deployedBy?: true
    _all?: true
  }

  export type DeploymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deployment to aggregate.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deployments
    **/
    _count?: true | DeploymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentMaxAggregateInputType
  }

  export type GetDeploymentAggregateType<T extends DeploymentAggregateArgs> = {
        [P in keyof T & keyof AggregateDeployment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeployment[P]>
      : GetScalarType<T[P], AggregateDeployment[P]>
  }




  export type DeploymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentWhereInput
    orderBy?: DeploymentOrderByWithAggregationInput | DeploymentOrderByWithAggregationInput[]
    by: DeploymentScalarFieldEnum[] | DeploymentScalarFieldEnum
    having?: DeploymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentCountAggregateInputType | true
    _min?: DeploymentMinAggregateInputType
    _max?: DeploymentMaxAggregateInputType
  }

  export type DeploymentGroupByOutputType = {
    id: string
    version: string
    status: string
    deployedUrl: string | null
    config: string | null
    metadata: string | null
    deployedAt: Date | null
    rollbackAt: Date | null
    createdAt: Date
    updatedAt: Date
    promptId: string
    environmentId: string
    deployedBy: string
    _count: DeploymentCountAggregateOutputType | null
    _min: DeploymentMinAggregateOutputType | null
    _max: DeploymentMaxAggregateOutputType | null
  }

  type GetDeploymentGroupByPayload<T extends DeploymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    status?: boolean
    deployedUrl?: boolean
    config?: boolean
    metadata?: boolean
    deployedAt?: boolean
    rollbackAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    promptId?: boolean
    environmentId?: boolean
    deployedBy?: boolean
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
    deployedByUser?: boolean | UserDefaultArgs<ExtArgs>
    history?: boolean | Deployment$historyArgs<ExtArgs>
    impactAnalysis?: boolean | Deployment$impactAnalysisArgs<ExtArgs>
    _count?: boolean | DeploymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deployment"]>

  export type DeploymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    status?: boolean
    deployedUrl?: boolean
    config?: boolean
    metadata?: boolean
    deployedAt?: boolean
    rollbackAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    promptId?: boolean
    environmentId?: boolean
    deployedBy?: boolean
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
    deployedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deployment"]>

  export type DeploymentSelectScalar = {
    id?: boolean
    version?: boolean
    status?: boolean
    deployedUrl?: boolean
    config?: boolean
    metadata?: boolean
    deployedAt?: boolean
    rollbackAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    promptId?: boolean
    environmentId?: boolean
    deployedBy?: boolean
  }

  export type DeploymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
    deployedByUser?: boolean | UserDefaultArgs<ExtArgs>
    history?: boolean | Deployment$historyArgs<ExtArgs>
    impactAnalysis?: boolean | Deployment$impactAnalysisArgs<ExtArgs>
    _count?: boolean | DeploymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeploymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    environment?: boolean | EnvironmentDefaultArgs<ExtArgs>
    deployedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeploymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deployment"
    objects: {
      prompt: Prisma.$PromptPayload<ExtArgs>
      environment: Prisma.$EnvironmentPayload<ExtArgs>
      deployedByUser: Prisma.$UserPayload<ExtArgs>
      history: Prisma.$DeploymentHistoryPayload<ExtArgs>[]
      impactAnalysis: Prisma.$ImpactAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      status: string
      deployedUrl: string | null
      config: string | null
      metadata: string | null
      deployedAt: Date | null
      rollbackAt: Date | null
      createdAt: Date
      updatedAt: Date
      promptId: string
      environmentId: string
      deployedBy: string
    }, ExtArgs["result"]["deployment"]>
    composites: {}
  }

  type DeploymentGetPayload<S extends boolean | null | undefined | DeploymentDefaultArgs> = $Result.GetResult<Prisma.$DeploymentPayload, S>

  type DeploymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentCountAggregateInputType | true
    }

  export interface DeploymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deployment'], meta: { name: 'Deployment' } }
    /**
     * Find zero or one Deployment that matches the filter.
     * @param {DeploymentFindUniqueArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentFindUniqueArgs>(args: SelectSubset<T, DeploymentFindUniqueArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deployment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentFindUniqueOrThrowArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deployment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindFirstArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentFindFirstArgs>(args?: SelectSubset<T, DeploymentFindFirstArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deployment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindFirstOrThrowArgs} args - Arguments to find a Deployment
     * @example
     * // Get one Deployment
     * const deployment = await prisma.deployment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deployments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deployments
     * const deployments = await prisma.deployment.findMany()
     * 
     * // Get first 10 Deployments
     * const deployments = await prisma.deployment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentWithIdOnly = await prisma.deployment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentFindManyArgs>(args?: SelectSubset<T, DeploymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deployment.
     * @param {DeploymentCreateArgs} args - Arguments to create a Deployment.
     * @example
     * // Create one Deployment
     * const Deployment = await prisma.deployment.create({
     *   data: {
     *     // ... data to create a Deployment
     *   }
     * })
     * 
     */
    create<T extends DeploymentCreateArgs>(args: SelectSubset<T, DeploymentCreateArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deployments.
     * @param {DeploymentCreateManyArgs} args - Arguments to create many Deployments.
     * @example
     * // Create many Deployments
     * const deployment = await prisma.deployment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentCreateManyArgs>(args?: SelectSubset<T, DeploymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deployments and returns the data saved in the database.
     * @param {DeploymentCreateManyAndReturnArgs} args - Arguments to create many Deployments.
     * @example
     * // Create many Deployments
     * const deployment = await prisma.deployment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deployments and only return the `id`
     * const deploymentWithIdOnly = await prisma.deployment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deployment.
     * @param {DeploymentDeleteArgs} args - Arguments to delete one Deployment.
     * @example
     * // Delete one Deployment
     * const Deployment = await prisma.deployment.delete({
     *   where: {
     *     // ... filter to delete one Deployment
     *   }
     * })
     * 
     */
    delete<T extends DeploymentDeleteArgs>(args: SelectSubset<T, DeploymentDeleteArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deployment.
     * @param {DeploymentUpdateArgs} args - Arguments to update one Deployment.
     * @example
     * // Update one Deployment
     * const deployment = await prisma.deployment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentUpdateArgs>(args: SelectSubset<T, DeploymentUpdateArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deployments.
     * @param {DeploymentDeleteManyArgs} args - Arguments to filter Deployments to delete.
     * @example
     * // Delete a few Deployments
     * const { count } = await prisma.deployment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentDeleteManyArgs>(args?: SelectSubset<T, DeploymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deployments
     * const deployment = await prisma.deployment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentUpdateManyArgs>(args: SelectSubset<T, DeploymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deployment.
     * @param {DeploymentUpsertArgs} args - Arguments to update or create a Deployment.
     * @example
     * // Update or create a Deployment
     * const deployment = await prisma.deployment.upsert({
     *   create: {
     *     // ... data to create a Deployment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deployment we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentUpsertArgs>(args: SelectSubset<T, DeploymentUpsertArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deployments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentCountArgs} args - Arguments to filter Deployments to count.
     * @example
     * // Count the number of Deployments
     * const count = await prisma.deployment.count({
     *   where: {
     *     // ... the filter for the Deployments we want to count
     *   }
     * })
    **/
    count<T extends DeploymentCountArgs>(
      args?: Subset<T, DeploymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentAggregateArgs>(args: Subset<T, DeploymentAggregateArgs>): Prisma.PrismaPromise<GetDeploymentAggregateType<T>>

    /**
     * Group by Deployment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deployment model
   */
  readonly fields: DeploymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deployment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompt<T extends PromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromptDefaultArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    environment<T extends EnvironmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnvironmentDefaultArgs<ExtArgs>>): Prisma__EnvironmentClient<$Result.GetResult<Prisma.$EnvironmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deployedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    history<T extends Deployment$historyArgs<ExtArgs> = {}>(args?: Subset<T, Deployment$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    impactAnalysis<T extends Deployment$impactAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, Deployment$impactAnalysisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deployment model
   */ 
  interface DeploymentFieldRefs {
    readonly id: FieldRef<"Deployment", 'String'>
    readonly version: FieldRef<"Deployment", 'String'>
    readonly status: FieldRef<"Deployment", 'String'>
    readonly deployedUrl: FieldRef<"Deployment", 'String'>
    readonly config: FieldRef<"Deployment", 'String'>
    readonly metadata: FieldRef<"Deployment", 'String'>
    readonly deployedAt: FieldRef<"Deployment", 'DateTime'>
    readonly rollbackAt: FieldRef<"Deployment", 'DateTime'>
    readonly createdAt: FieldRef<"Deployment", 'DateTime'>
    readonly updatedAt: FieldRef<"Deployment", 'DateTime'>
    readonly promptId: FieldRef<"Deployment", 'String'>
    readonly environmentId: FieldRef<"Deployment", 'String'>
    readonly deployedBy: FieldRef<"Deployment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Deployment findUnique
   */
  export type DeploymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment findUniqueOrThrow
   */
  export type DeploymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment findFirst
   */
  export type DeploymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deployments.
     */
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment findFirstOrThrow
   */
  export type DeploymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployment to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deployments.
     */
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment findMany
   */
  export type DeploymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter, which Deployments to fetch.
     */
    where?: DeploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deployments to fetch.
     */
    orderBy?: DeploymentOrderByWithRelationInput | DeploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deployments.
     */
    cursor?: DeploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deployments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deployments.
     */
    skip?: number
    distinct?: DeploymentScalarFieldEnum | DeploymentScalarFieldEnum[]
  }

  /**
   * Deployment create
   */
  export type DeploymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Deployment.
     */
    data: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
  }

  /**
   * Deployment createMany
   */
  export type DeploymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deployments.
     */
    data: DeploymentCreateManyInput | DeploymentCreateManyInput[]
  }

  /**
   * Deployment createManyAndReturn
   */
  export type DeploymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deployments.
     */
    data: DeploymentCreateManyInput | DeploymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deployment update
   */
  export type DeploymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Deployment.
     */
    data: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
    /**
     * Choose, which Deployment to update.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment updateMany
   */
  export type DeploymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deployments.
     */
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyInput>
    /**
     * Filter which Deployments to update
     */
    where?: DeploymentWhereInput
  }

  /**
   * Deployment upsert
   */
  export type DeploymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Deployment to update in case it exists.
     */
    where: DeploymentWhereUniqueInput
    /**
     * In case the Deployment found by the `where` argument doesn't exist, create a new Deployment with this data.
     */
    create: XOR<DeploymentCreateInput, DeploymentUncheckedCreateInput>
    /**
     * In case the Deployment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentUpdateInput, DeploymentUncheckedUpdateInput>
  }

  /**
   * Deployment delete
   */
  export type DeploymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
    /**
     * Filter which Deployment to delete.
     */
    where: DeploymentWhereUniqueInput
  }

  /**
   * Deployment deleteMany
   */
  export type DeploymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deployments to delete
     */
    where?: DeploymentWhereInput
  }

  /**
   * Deployment.history
   */
  export type Deployment$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    where?: DeploymentHistoryWhereInput
    orderBy?: DeploymentHistoryOrderByWithRelationInput | DeploymentHistoryOrderByWithRelationInput[]
    cursor?: DeploymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentHistoryScalarFieldEnum | DeploymentHistoryScalarFieldEnum[]
  }

  /**
   * Deployment.impactAnalysis
   */
  export type Deployment$impactAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    where?: ImpactAnalysisWhereInput
    orderBy?: ImpactAnalysisOrderByWithRelationInput | ImpactAnalysisOrderByWithRelationInput[]
    cursor?: ImpactAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImpactAnalysisScalarFieldEnum | ImpactAnalysisScalarFieldEnum[]
  }

  /**
   * Deployment without action
   */
  export type DeploymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deployment
     */
    select?: DeploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentInclude<ExtArgs> | null
  }


  /**
   * Model DeploymentHistory
   */

  export type AggregateDeploymentHistory = {
    _count: DeploymentHistoryCountAggregateOutputType | null
    _min: DeploymentHistoryMinAggregateOutputType | null
    _max: DeploymentHistoryMaxAggregateOutputType | null
  }

  export type DeploymentHistoryMinAggregateOutputType = {
    id: string | null
    action: string | null
    status: string | null
    metadata: string | null
    timestamp: Date | null
    deploymentId: string | null
    performedBy: string | null
  }

  export type DeploymentHistoryMaxAggregateOutputType = {
    id: string | null
    action: string | null
    status: string | null
    metadata: string | null
    timestamp: Date | null
    deploymentId: string | null
    performedBy: string | null
  }

  export type DeploymentHistoryCountAggregateOutputType = {
    id: number
    action: number
    status: number
    metadata: number
    timestamp: number
    deploymentId: number
    performedBy: number
    _all: number
  }


  export type DeploymentHistoryMinAggregateInputType = {
    id?: true
    action?: true
    status?: true
    metadata?: true
    timestamp?: true
    deploymentId?: true
    performedBy?: true
  }

  export type DeploymentHistoryMaxAggregateInputType = {
    id?: true
    action?: true
    status?: true
    metadata?: true
    timestamp?: true
    deploymentId?: true
    performedBy?: true
  }

  export type DeploymentHistoryCountAggregateInputType = {
    id?: true
    action?: true
    status?: true
    metadata?: true
    timestamp?: true
    deploymentId?: true
    performedBy?: true
    _all?: true
  }

  export type DeploymentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentHistory to aggregate.
     */
    where?: DeploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentHistories to fetch.
     */
    orderBy?: DeploymentHistoryOrderByWithRelationInput | DeploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeploymentHistories
    **/
    _count?: true | DeploymentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentHistoryMaxAggregateInputType
  }

  export type GetDeploymentHistoryAggregateType<T extends DeploymentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDeploymentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeploymentHistory[P]>
      : GetScalarType<T[P], AggregateDeploymentHistory[P]>
  }




  export type DeploymentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentHistoryWhereInput
    orderBy?: DeploymentHistoryOrderByWithAggregationInput | DeploymentHistoryOrderByWithAggregationInput[]
    by: DeploymentHistoryScalarFieldEnum[] | DeploymentHistoryScalarFieldEnum
    having?: DeploymentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentHistoryCountAggregateInputType | true
    _min?: DeploymentHistoryMinAggregateInputType
    _max?: DeploymentHistoryMaxAggregateInputType
  }

  export type DeploymentHistoryGroupByOutputType = {
    id: string
    action: string
    status: string
    metadata: string | null
    timestamp: Date
    deploymentId: string
    performedBy: string
    _count: DeploymentHistoryCountAggregateOutputType | null
    _min: DeploymentHistoryMinAggregateOutputType | null
    _max: DeploymentHistoryMaxAggregateOutputType | null
  }

  type GetDeploymentHistoryGroupByPayload<T extends DeploymentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    status?: boolean
    metadata?: boolean
    timestamp?: boolean
    deploymentId?: boolean
    performedBy?: boolean
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentHistory"]>

  export type DeploymentHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    status?: boolean
    metadata?: boolean
    timestamp?: boolean
    deploymentId?: boolean
    performedBy?: boolean
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentHistory"]>

  export type DeploymentHistorySelectScalar = {
    id?: boolean
    action?: boolean
    status?: boolean
    metadata?: boolean
    timestamp?: boolean
    deploymentId?: boolean
    performedBy?: boolean
  }

  export type DeploymentHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeploymentHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeploymentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeploymentHistory"
    objects: {
      deployment: Prisma.$DeploymentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      status: string
      metadata: string | null
      timestamp: Date
      deploymentId: string
      performedBy: string
    }, ExtArgs["result"]["deploymentHistory"]>
    composites: {}
  }

  type DeploymentHistoryGetPayload<S extends boolean | null | undefined | DeploymentHistoryDefaultArgs> = $Result.GetResult<Prisma.$DeploymentHistoryPayload, S>

  type DeploymentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentHistoryCountAggregateInputType | true
    }

  export interface DeploymentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeploymentHistory'], meta: { name: 'DeploymentHistory' } }
    /**
     * Find zero or one DeploymentHistory that matches the filter.
     * @param {DeploymentHistoryFindUniqueArgs} args - Arguments to find a DeploymentHistory
     * @example
     * // Get one DeploymentHistory
     * const deploymentHistory = await prisma.deploymentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentHistoryFindUniqueArgs>(args: SelectSubset<T, DeploymentHistoryFindUniqueArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeploymentHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentHistoryFindUniqueOrThrowArgs} args - Arguments to find a DeploymentHistory
     * @example
     * // Get one DeploymentHistory
     * const deploymentHistory = await prisma.deploymentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeploymentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryFindFirstArgs} args - Arguments to find a DeploymentHistory
     * @example
     * // Get one DeploymentHistory
     * const deploymentHistory = await prisma.deploymentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentHistoryFindFirstArgs>(args?: SelectSubset<T, DeploymentHistoryFindFirstArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeploymentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryFindFirstOrThrowArgs} args - Arguments to find a DeploymentHistory
     * @example
     * // Get one DeploymentHistory
     * const deploymentHistory = await prisma.deploymentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeploymentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeploymentHistories
     * const deploymentHistories = await prisma.deploymentHistory.findMany()
     * 
     * // Get first 10 DeploymentHistories
     * const deploymentHistories = await prisma.deploymentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentHistoryWithIdOnly = await prisma.deploymentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentHistoryFindManyArgs>(args?: SelectSubset<T, DeploymentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeploymentHistory.
     * @param {DeploymentHistoryCreateArgs} args - Arguments to create a DeploymentHistory.
     * @example
     * // Create one DeploymentHistory
     * const DeploymentHistory = await prisma.deploymentHistory.create({
     *   data: {
     *     // ... data to create a DeploymentHistory
     *   }
     * })
     * 
     */
    create<T extends DeploymentHistoryCreateArgs>(args: SelectSubset<T, DeploymentHistoryCreateArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeploymentHistories.
     * @param {DeploymentHistoryCreateManyArgs} args - Arguments to create many DeploymentHistories.
     * @example
     * // Create many DeploymentHistories
     * const deploymentHistory = await prisma.deploymentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentHistoryCreateManyArgs>(args?: SelectSubset<T, DeploymentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeploymentHistories and returns the data saved in the database.
     * @param {DeploymentHistoryCreateManyAndReturnArgs} args - Arguments to create many DeploymentHistories.
     * @example
     * // Create many DeploymentHistories
     * const deploymentHistory = await prisma.deploymentHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeploymentHistories and only return the `id`
     * const deploymentHistoryWithIdOnly = await prisma.deploymentHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeploymentHistory.
     * @param {DeploymentHistoryDeleteArgs} args - Arguments to delete one DeploymentHistory.
     * @example
     * // Delete one DeploymentHistory
     * const DeploymentHistory = await prisma.deploymentHistory.delete({
     *   where: {
     *     // ... filter to delete one DeploymentHistory
     *   }
     * })
     * 
     */
    delete<T extends DeploymentHistoryDeleteArgs>(args: SelectSubset<T, DeploymentHistoryDeleteArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeploymentHistory.
     * @param {DeploymentHistoryUpdateArgs} args - Arguments to update one DeploymentHistory.
     * @example
     * // Update one DeploymentHistory
     * const deploymentHistory = await prisma.deploymentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentHistoryUpdateArgs>(args: SelectSubset<T, DeploymentHistoryUpdateArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeploymentHistories.
     * @param {DeploymentHistoryDeleteManyArgs} args - Arguments to filter DeploymentHistories to delete.
     * @example
     * // Delete a few DeploymentHistories
     * const { count } = await prisma.deploymentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentHistoryDeleteManyArgs>(args?: SelectSubset<T, DeploymentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeploymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeploymentHistories
     * const deploymentHistory = await prisma.deploymentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentHistoryUpdateManyArgs>(args: SelectSubset<T, DeploymentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeploymentHistory.
     * @param {DeploymentHistoryUpsertArgs} args - Arguments to update or create a DeploymentHistory.
     * @example
     * // Update or create a DeploymentHistory
     * const deploymentHistory = await prisma.deploymentHistory.upsert({
     *   create: {
     *     // ... data to create a DeploymentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeploymentHistory we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentHistoryUpsertArgs>(args: SelectSubset<T, DeploymentHistoryUpsertArgs<ExtArgs>>): Prisma__DeploymentHistoryClient<$Result.GetResult<Prisma.$DeploymentHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeploymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryCountArgs} args - Arguments to filter DeploymentHistories to count.
     * @example
     * // Count the number of DeploymentHistories
     * const count = await prisma.deploymentHistory.count({
     *   where: {
     *     // ... the filter for the DeploymentHistories we want to count
     *   }
     * })
    **/
    count<T extends DeploymentHistoryCountArgs>(
      args?: Subset<T, DeploymentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeploymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentHistoryAggregateArgs>(args: Subset<T, DeploymentHistoryAggregateArgs>): Prisma.PrismaPromise<GetDeploymentHistoryAggregateType<T>>

    /**
     * Group by DeploymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeploymentHistory model
   */
  readonly fields: DeploymentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeploymentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deployment<T extends DeploymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentDefaultArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeploymentHistory model
   */ 
  interface DeploymentHistoryFieldRefs {
    readonly id: FieldRef<"DeploymentHistory", 'String'>
    readonly action: FieldRef<"DeploymentHistory", 'String'>
    readonly status: FieldRef<"DeploymentHistory", 'String'>
    readonly metadata: FieldRef<"DeploymentHistory", 'String'>
    readonly timestamp: FieldRef<"DeploymentHistory", 'DateTime'>
    readonly deploymentId: FieldRef<"DeploymentHistory", 'String'>
    readonly performedBy: FieldRef<"DeploymentHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeploymentHistory findUnique
   */
  export type DeploymentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentHistory to fetch.
     */
    where: DeploymentHistoryWhereUniqueInput
  }

  /**
   * DeploymentHistory findUniqueOrThrow
   */
  export type DeploymentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentHistory to fetch.
     */
    where: DeploymentHistoryWhereUniqueInput
  }

  /**
   * DeploymentHistory findFirst
   */
  export type DeploymentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentHistory to fetch.
     */
    where?: DeploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentHistories to fetch.
     */
    orderBy?: DeploymentHistoryOrderByWithRelationInput | DeploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentHistories.
     */
    cursor?: DeploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentHistories.
     */
    distinct?: DeploymentHistoryScalarFieldEnum | DeploymentHistoryScalarFieldEnum[]
  }

  /**
   * DeploymentHistory findFirstOrThrow
   */
  export type DeploymentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentHistory to fetch.
     */
    where?: DeploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentHistories to fetch.
     */
    orderBy?: DeploymentHistoryOrderByWithRelationInput | DeploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentHistories.
     */
    cursor?: DeploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentHistories.
     */
    distinct?: DeploymentHistoryScalarFieldEnum | DeploymentHistoryScalarFieldEnum[]
  }

  /**
   * DeploymentHistory findMany
   */
  export type DeploymentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentHistories to fetch.
     */
    where?: DeploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentHistories to fetch.
     */
    orderBy?: DeploymentHistoryOrderByWithRelationInput | DeploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeploymentHistories.
     */
    cursor?: DeploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentHistories.
     */
    skip?: number
    distinct?: DeploymentHistoryScalarFieldEnum | DeploymentHistoryScalarFieldEnum[]
  }

  /**
   * DeploymentHistory create
   */
  export type DeploymentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a DeploymentHistory.
     */
    data: XOR<DeploymentHistoryCreateInput, DeploymentHistoryUncheckedCreateInput>
  }

  /**
   * DeploymentHistory createMany
   */
  export type DeploymentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeploymentHistories.
     */
    data: DeploymentHistoryCreateManyInput | DeploymentHistoryCreateManyInput[]
  }

  /**
   * DeploymentHistory createManyAndReturn
   */
  export type DeploymentHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeploymentHistories.
     */
    data: DeploymentHistoryCreateManyInput | DeploymentHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeploymentHistory update
   */
  export type DeploymentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a DeploymentHistory.
     */
    data: XOR<DeploymentHistoryUpdateInput, DeploymentHistoryUncheckedUpdateInput>
    /**
     * Choose, which DeploymentHistory to update.
     */
    where: DeploymentHistoryWhereUniqueInput
  }

  /**
   * DeploymentHistory updateMany
   */
  export type DeploymentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeploymentHistories.
     */
    data: XOR<DeploymentHistoryUpdateManyMutationInput, DeploymentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which DeploymentHistories to update
     */
    where?: DeploymentHistoryWhereInput
  }

  /**
   * DeploymentHistory upsert
   */
  export type DeploymentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the DeploymentHistory to update in case it exists.
     */
    where: DeploymentHistoryWhereUniqueInput
    /**
     * In case the DeploymentHistory found by the `where` argument doesn't exist, create a new DeploymentHistory with this data.
     */
    create: XOR<DeploymentHistoryCreateInput, DeploymentHistoryUncheckedCreateInput>
    /**
     * In case the DeploymentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentHistoryUpdateInput, DeploymentHistoryUncheckedUpdateInput>
  }

  /**
   * DeploymentHistory delete
   */
  export type DeploymentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter which DeploymentHistory to delete.
     */
    where: DeploymentHistoryWhereUniqueInput
  }

  /**
   * DeploymentHistory deleteMany
   */
  export type DeploymentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentHistories to delete
     */
    where?: DeploymentHistoryWhereInput
  }

  /**
   * DeploymentHistory without action
   */
  export type DeploymentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentHistory
     */
    select?: DeploymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ImpactAnalysis
   */

  export type AggregateImpactAnalysis = {
    _count: ImpactAnalysisCountAggregateOutputType | null
    _avg: ImpactAnalysisAvgAggregateOutputType | null
    _sum: ImpactAnalysisSumAggregateOutputType | null
    _min: ImpactAnalysisMinAggregateOutputType | null
    _max: ImpactAnalysisMaxAggregateOutputType | null
  }

  export type ImpactAnalysisAvgAggregateOutputType = {
    impactPercentage: number | null
  }

  export type ImpactAnalysisSumAggregateOutputType = {
    impactPercentage: number | null
  }

  export type ImpactAnalysisMinAggregateOutputType = {
    id: string | null
    impactPercentage: number | null
    diffAnalysis: string | null
    sampleComparisons: string | null
    createdAt: Date | null
    deploymentId: string | null
    baselinePromptId: string | null
  }

  export type ImpactAnalysisMaxAggregateOutputType = {
    id: string | null
    impactPercentage: number | null
    diffAnalysis: string | null
    sampleComparisons: string | null
    createdAt: Date | null
    deploymentId: string | null
    baselinePromptId: string | null
  }

  export type ImpactAnalysisCountAggregateOutputType = {
    id: number
    impactPercentage: number
    diffAnalysis: number
    sampleComparisons: number
    createdAt: number
    deploymentId: number
    baselinePromptId: number
    _all: number
  }


  export type ImpactAnalysisAvgAggregateInputType = {
    impactPercentage?: true
  }

  export type ImpactAnalysisSumAggregateInputType = {
    impactPercentage?: true
  }

  export type ImpactAnalysisMinAggregateInputType = {
    id?: true
    impactPercentage?: true
    diffAnalysis?: true
    sampleComparisons?: true
    createdAt?: true
    deploymentId?: true
    baselinePromptId?: true
  }

  export type ImpactAnalysisMaxAggregateInputType = {
    id?: true
    impactPercentage?: true
    diffAnalysis?: true
    sampleComparisons?: true
    createdAt?: true
    deploymentId?: true
    baselinePromptId?: true
  }

  export type ImpactAnalysisCountAggregateInputType = {
    id?: true
    impactPercentage?: true
    diffAnalysis?: true
    sampleComparisons?: true
    createdAt?: true
    deploymentId?: true
    baselinePromptId?: true
    _all?: true
  }

  export type ImpactAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImpactAnalysis to aggregate.
     */
    where?: ImpactAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactAnalyses to fetch.
     */
    orderBy?: ImpactAnalysisOrderByWithRelationInput | ImpactAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpactAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImpactAnalyses
    **/
    _count?: true | ImpactAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImpactAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImpactAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpactAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpactAnalysisMaxAggregateInputType
  }

  export type GetImpactAnalysisAggregateType<T extends ImpactAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateImpactAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpactAnalysis[P]>
      : GetScalarType<T[P], AggregateImpactAnalysis[P]>
  }




  export type ImpactAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpactAnalysisWhereInput
    orderBy?: ImpactAnalysisOrderByWithAggregationInput | ImpactAnalysisOrderByWithAggregationInput[]
    by: ImpactAnalysisScalarFieldEnum[] | ImpactAnalysisScalarFieldEnum
    having?: ImpactAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpactAnalysisCountAggregateInputType | true
    _avg?: ImpactAnalysisAvgAggregateInputType
    _sum?: ImpactAnalysisSumAggregateInputType
    _min?: ImpactAnalysisMinAggregateInputType
    _max?: ImpactAnalysisMaxAggregateInputType
  }

  export type ImpactAnalysisGroupByOutputType = {
    id: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt: Date
    deploymentId: string
    baselinePromptId: string | null
    _count: ImpactAnalysisCountAggregateOutputType | null
    _avg: ImpactAnalysisAvgAggregateOutputType | null
    _sum: ImpactAnalysisSumAggregateOutputType | null
    _min: ImpactAnalysisMinAggregateOutputType | null
    _max: ImpactAnalysisMaxAggregateOutputType | null
  }

  type GetImpactAnalysisGroupByPayload<T extends ImpactAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImpactAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpactAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpactAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], ImpactAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type ImpactAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impactPercentage?: boolean
    diffAnalysis?: boolean
    sampleComparisons?: boolean
    createdAt?: boolean
    deploymentId?: boolean
    baselinePromptId?: boolean
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | ImpactAnalysis$baselinePromptArgs<ExtArgs>
    approvalRequests?: boolean | ImpactAnalysis$approvalRequestsArgs<ExtArgs>
    _count?: boolean | ImpactAnalysisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impactAnalysis"]>

  export type ImpactAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impactPercentage?: boolean
    diffAnalysis?: boolean
    sampleComparisons?: boolean
    createdAt?: boolean
    deploymentId?: boolean
    baselinePromptId?: boolean
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | ImpactAnalysis$baselinePromptArgs<ExtArgs>
  }, ExtArgs["result"]["impactAnalysis"]>

  export type ImpactAnalysisSelectScalar = {
    id?: boolean
    impactPercentage?: boolean
    diffAnalysis?: boolean
    sampleComparisons?: boolean
    createdAt?: boolean
    deploymentId?: boolean
    baselinePromptId?: boolean
  }

  export type ImpactAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | ImpactAnalysis$baselinePromptArgs<ExtArgs>
    approvalRequests?: boolean | ImpactAnalysis$approvalRequestsArgs<ExtArgs>
    _count?: boolean | ImpactAnalysisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImpactAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deployment?: boolean | DeploymentDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | ImpactAnalysis$baselinePromptArgs<ExtArgs>
  }

  export type $ImpactAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImpactAnalysis"
    objects: {
      deployment: Prisma.$DeploymentPayload<ExtArgs>
      baselinePrompt: Prisma.$PromptPayload<ExtArgs> | null
      approvalRequests: Prisma.$ApprovalRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      impactPercentage: number
      diffAnalysis: string
      sampleComparisons: string
      createdAt: Date
      deploymentId: string
      baselinePromptId: string | null
    }, ExtArgs["result"]["impactAnalysis"]>
    composites: {}
  }

  type ImpactAnalysisGetPayload<S extends boolean | null | undefined | ImpactAnalysisDefaultArgs> = $Result.GetResult<Prisma.$ImpactAnalysisPayload, S>

  type ImpactAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImpactAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImpactAnalysisCountAggregateInputType | true
    }

  export interface ImpactAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImpactAnalysis'], meta: { name: 'ImpactAnalysis' } }
    /**
     * Find zero or one ImpactAnalysis that matches the filter.
     * @param {ImpactAnalysisFindUniqueArgs} args - Arguments to find a ImpactAnalysis
     * @example
     * // Get one ImpactAnalysis
     * const impactAnalysis = await prisma.impactAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImpactAnalysisFindUniqueArgs>(args: SelectSubset<T, ImpactAnalysisFindUniqueArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImpactAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImpactAnalysisFindUniqueOrThrowArgs} args - Arguments to find a ImpactAnalysis
     * @example
     * // Get one ImpactAnalysis
     * const impactAnalysis = await prisma.impactAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImpactAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, ImpactAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImpactAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisFindFirstArgs} args - Arguments to find a ImpactAnalysis
     * @example
     * // Get one ImpactAnalysis
     * const impactAnalysis = await prisma.impactAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImpactAnalysisFindFirstArgs>(args?: SelectSubset<T, ImpactAnalysisFindFirstArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImpactAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisFindFirstOrThrowArgs} args - Arguments to find a ImpactAnalysis
     * @example
     * // Get one ImpactAnalysis
     * const impactAnalysis = await prisma.impactAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImpactAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, ImpactAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImpactAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImpactAnalyses
     * const impactAnalyses = await prisma.impactAnalysis.findMany()
     * 
     * // Get first 10 ImpactAnalyses
     * const impactAnalyses = await prisma.impactAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impactAnalysisWithIdOnly = await prisma.impactAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImpactAnalysisFindManyArgs>(args?: SelectSubset<T, ImpactAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImpactAnalysis.
     * @param {ImpactAnalysisCreateArgs} args - Arguments to create a ImpactAnalysis.
     * @example
     * // Create one ImpactAnalysis
     * const ImpactAnalysis = await prisma.impactAnalysis.create({
     *   data: {
     *     // ... data to create a ImpactAnalysis
     *   }
     * })
     * 
     */
    create<T extends ImpactAnalysisCreateArgs>(args: SelectSubset<T, ImpactAnalysisCreateArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImpactAnalyses.
     * @param {ImpactAnalysisCreateManyArgs} args - Arguments to create many ImpactAnalyses.
     * @example
     * // Create many ImpactAnalyses
     * const impactAnalysis = await prisma.impactAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImpactAnalysisCreateManyArgs>(args?: SelectSubset<T, ImpactAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImpactAnalyses and returns the data saved in the database.
     * @param {ImpactAnalysisCreateManyAndReturnArgs} args - Arguments to create many ImpactAnalyses.
     * @example
     * // Create many ImpactAnalyses
     * const impactAnalysis = await prisma.impactAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImpactAnalyses and only return the `id`
     * const impactAnalysisWithIdOnly = await prisma.impactAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImpactAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, ImpactAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImpactAnalysis.
     * @param {ImpactAnalysisDeleteArgs} args - Arguments to delete one ImpactAnalysis.
     * @example
     * // Delete one ImpactAnalysis
     * const ImpactAnalysis = await prisma.impactAnalysis.delete({
     *   where: {
     *     // ... filter to delete one ImpactAnalysis
     *   }
     * })
     * 
     */
    delete<T extends ImpactAnalysisDeleteArgs>(args: SelectSubset<T, ImpactAnalysisDeleteArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImpactAnalysis.
     * @param {ImpactAnalysisUpdateArgs} args - Arguments to update one ImpactAnalysis.
     * @example
     * // Update one ImpactAnalysis
     * const impactAnalysis = await prisma.impactAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImpactAnalysisUpdateArgs>(args: SelectSubset<T, ImpactAnalysisUpdateArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImpactAnalyses.
     * @param {ImpactAnalysisDeleteManyArgs} args - Arguments to filter ImpactAnalyses to delete.
     * @example
     * // Delete a few ImpactAnalyses
     * const { count } = await prisma.impactAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImpactAnalysisDeleteManyArgs>(args?: SelectSubset<T, ImpactAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImpactAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImpactAnalyses
     * const impactAnalysis = await prisma.impactAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImpactAnalysisUpdateManyArgs>(args: SelectSubset<T, ImpactAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImpactAnalysis.
     * @param {ImpactAnalysisUpsertArgs} args - Arguments to update or create a ImpactAnalysis.
     * @example
     * // Update or create a ImpactAnalysis
     * const impactAnalysis = await prisma.impactAnalysis.upsert({
     *   create: {
     *     // ... data to create a ImpactAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImpactAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends ImpactAnalysisUpsertArgs>(args: SelectSubset<T, ImpactAnalysisUpsertArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImpactAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisCountArgs} args - Arguments to filter ImpactAnalyses to count.
     * @example
     * // Count the number of ImpactAnalyses
     * const count = await prisma.impactAnalysis.count({
     *   where: {
     *     // ... the filter for the ImpactAnalyses we want to count
     *   }
     * })
    **/
    count<T extends ImpactAnalysisCountArgs>(
      args?: Subset<T, ImpactAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpactAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImpactAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpactAnalysisAggregateArgs>(args: Subset<T, ImpactAnalysisAggregateArgs>): Prisma.PrismaPromise<GetImpactAnalysisAggregateType<T>>

    /**
     * Group by ImpactAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpactAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpactAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: ImpactAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpactAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpactAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImpactAnalysis model
   */
  readonly fields: ImpactAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImpactAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImpactAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deployment<T extends DeploymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentDefaultArgs<ExtArgs>>): Prisma__DeploymentClient<$Result.GetResult<Prisma.$DeploymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    baselinePrompt<T extends ImpactAnalysis$baselinePromptArgs<ExtArgs> = {}>(args?: Subset<T, ImpactAnalysis$baselinePromptArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    approvalRequests<T extends ImpactAnalysis$approvalRequestsArgs<ExtArgs> = {}>(args?: Subset<T, ImpactAnalysis$approvalRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImpactAnalysis model
   */ 
  interface ImpactAnalysisFieldRefs {
    readonly id: FieldRef<"ImpactAnalysis", 'String'>
    readonly impactPercentage: FieldRef<"ImpactAnalysis", 'Float'>
    readonly diffAnalysis: FieldRef<"ImpactAnalysis", 'String'>
    readonly sampleComparisons: FieldRef<"ImpactAnalysis", 'String'>
    readonly createdAt: FieldRef<"ImpactAnalysis", 'DateTime'>
    readonly deploymentId: FieldRef<"ImpactAnalysis", 'String'>
    readonly baselinePromptId: FieldRef<"ImpactAnalysis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImpactAnalysis findUnique
   */
  export type ImpactAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ImpactAnalysis to fetch.
     */
    where: ImpactAnalysisWhereUniqueInput
  }

  /**
   * ImpactAnalysis findUniqueOrThrow
   */
  export type ImpactAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ImpactAnalysis to fetch.
     */
    where: ImpactAnalysisWhereUniqueInput
  }

  /**
   * ImpactAnalysis findFirst
   */
  export type ImpactAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ImpactAnalysis to fetch.
     */
    where?: ImpactAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactAnalyses to fetch.
     */
    orderBy?: ImpactAnalysisOrderByWithRelationInput | ImpactAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpactAnalyses.
     */
    cursor?: ImpactAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpactAnalyses.
     */
    distinct?: ImpactAnalysisScalarFieldEnum | ImpactAnalysisScalarFieldEnum[]
  }

  /**
   * ImpactAnalysis findFirstOrThrow
   */
  export type ImpactAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ImpactAnalysis to fetch.
     */
    where?: ImpactAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactAnalyses to fetch.
     */
    orderBy?: ImpactAnalysisOrderByWithRelationInput | ImpactAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpactAnalyses.
     */
    cursor?: ImpactAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpactAnalyses.
     */
    distinct?: ImpactAnalysisScalarFieldEnum | ImpactAnalysisScalarFieldEnum[]
  }

  /**
   * ImpactAnalysis findMany
   */
  export type ImpactAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which ImpactAnalyses to fetch.
     */
    where?: ImpactAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactAnalyses to fetch.
     */
    orderBy?: ImpactAnalysisOrderByWithRelationInput | ImpactAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImpactAnalyses.
     */
    cursor?: ImpactAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactAnalyses.
     */
    skip?: number
    distinct?: ImpactAnalysisScalarFieldEnum | ImpactAnalysisScalarFieldEnum[]
  }

  /**
   * ImpactAnalysis create
   */
  export type ImpactAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a ImpactAnalysis.
     */
    data: XOR<ImpactAnalysisCreateInput, ImpactAnalysisUncheckedCreateInput>
  }

  /**
   * ImpactAnalysis createMany
   */
  export type ImpactAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImpactAnalyses.
     */
    data: ImpactAnalysisCreateManyInput | ImpactAnalysisCreateManyInput[]
  }

  /**
   * ImpactAnalysis createManyAndReturn
   */
  export type ImpactAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImpactAnalyses.
     */
    data: ImpactAnalysisCreateManyInput | ImpactAnalysisCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImpactAnalysis update
   */
  export type ImpactAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a ImpactAnalysis.
     */
    data: XOR<ImpactAnalysisUpdateInput, ImpactAnalysisUncheckedUpdateInput>
    /**
     * Choose, which ImpactAnalysis to update.
     */
    where: ImpactAnalysisWhereUniqueInput
  }

  /**
   * ImpactAnalysis updateMany
   */
  export type ImpactAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImpactAnalyses.
     */
    data: XOR<ImpactAnalysisUpdateManyMutationInput, ImpactAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which ImpactAnalyses to update
     */
    where?: ImpactAnalysisWhereInput
  }

  /**
   * ImpactAnalysis upsert
   */
  export type ImpactAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the ImpactAnalysis to update in case it exists.
     */
    where: ImpactAnalysisWhereUniqueInput
    /**
     * In case the ImpactAnalysis found by the `where` argument doesn't exist, create a new ImpactAnalysis with this data.
     */
    create: XOR<ImpactAnalysisCreateInput, ImpactAnalysisUncheckedCreateInput>
    /**
     * In case the ImpactAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpactAnalysisUpdateInput, ImpactAnalysisUncheckedUpdateInput>
  }

  /**
   * ImpactAnalysis delete
   */
  export type ImpactAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    /**
     * Filter which ImpactAnalysis to delete.
     */
    where: ImpactAnalysisWhereUniqueInput
  }

  /**
   * ImpactAnalysis deleteMany
   */
  export type ImpactAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImpactAnalyses to delete
     */
    where?: ImpactAnalysisWhereInput
  }

  /**
   * ImpactAnalysis.baselinePrompt
   */
  export type ImpactAnalysis$baselinePromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
  }

  /**
   * ImpactAnalysis.approvalRequests
   */
  export type ImpactAnalysis$approvalRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ImpactAnalysis without action
   */
  export type ImpactAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model CostTracking
   */

  export type AggregateCostTracking = {
    _count: CostTrackingCountAggregateOutputType | null
    _avg: CostTrackingAvgAggregateOutputType | null
    _sum: CostTrackingSumAggregateOutputType | null
    _min: CostTrackingMinAggregateOutputType | null
    _max: CostTrackingMaxAggregateOutputType | null
  }

  export type CostTrackingAvgAggregateOutputType = {
    totalCost: number | null
    tokenUsage: number | null
    requestCount: number | null
  }

  export type CostTrackingSumAggregateOutputType = {
    totalCost: number | null
    tokenUsage: number | null
    requestCount: number | null
  }

  export type CostTrackingMinAggregateOutputType = {
    id: string | null
    period: string | null
    totalCost: number | null
    tokenUsage: number | null
    requestCount: number | null
    breakdown: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
  }

  export type CostTrackingMaxAggregateOutputType = {
    id: string | null
    period: string | null
    totalCost: number | null
    tokenUsage: number | null
    requestCount: number | null
    breakdown: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    userId: string | null
  }

  export type CostTrackingCountAggregateOutputType = {
    id: number
    period: number
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: number
    createdAt: number
    updatedAt: number
    projectId: number
    userId: number
    _all: number
  }


  export type CostTrackingAvgAggregateInputType = {
    totalCost?: true
    tokenUsage?: true
    requestCount?: true
  }

  export type CostTrackingSumAggregateInputType = {
    totalCost?: true
    tokenUsage?: true
    requestCount?: true
  }

  export type CostTrackingMinAggregateInputType = {
    id?: true
    period?: true
    totalCost?: true
    tokenUsage?: true
    requestCount?: true
    breakdown?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
  }

  export type CostTrackingMaxAggregateInputType = {
    id?: true
    period?: true
    totalCost?: true
    tokenUsage?: true
    requestCount?: true
    breakdown?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
  }

  export type CostTrackingCountAggregateInputType = {
    id?: true
    period?: true
    totalCost?: true
    tokenUsage?: true
    requestCount?: true
    breakdown?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    userId?: true
    _all?: true
  }

  export type CostTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostTracking to aggregate.
     */
    where?: CostTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTrackings to fetch.
     */
    orderBy?: CostTrackingOrderByWithRelationInput | CostTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostTrackings
    **/
    _count?: true | CostTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostTrackingMaxAggregateInputType
  }

  export type GetCostTrackingAggregateType<T extends CostTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateCostTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostTracking[P]>
      : GetScalarType<T[P], AggregateCostTracking[P]>
  }




  export type CostTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostTrackingWhereInput
    orderBy?: CostTrackingOrderByWithAggregationInput | CostTrackingOrderByWithAggregationInput[]
    by: CostTrackingScalarFieldEnum[] | CostTrackingScalarFieldEnum
    having?: CostTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostTrackingCountAggregateInputType | true
    _avg?: CostTrackingAvgAggregateInputType
    _sum?: CostTrackingSumAggregateInputType
    _min?: CostTrackingMinAggregateInputType
    _max?: CostTrackingMaxAggregateInputType
  }

  export type CostTrackingGroupByOutputType = {
    id: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    userId: string | null
    _count: CostTrackingCountAggregateOutputType | null
    _avg: CostTrackingAvgAggregateOutputType | null
    _sum: CostTrackingSumAggregateOutputType | null
    _min: CostTrackingMinAggregateOutputType | null
    _max: CostTrackingMaxAggregateOutputType | null
  }

  type GetCostTrackingGroupByPayload<T extends CostTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], CostTrackingGroupByOutputType[P]>
        }
      >
    >


  export type CostTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    totalCost?: boolean
    tokenUsage?: boolean
    requestCount?: boolean
    breakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | CostTracking$userArgs<ExtArgs>
  }, ExtArgs["result"]["costTracking"]>

  export type CostTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    totalCost?: boolean
    tokenUsage?: boolean
    requestCount?: boolean
    breakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | CostTracking$userArgs<ExtArgs>
  }, ExtArgs["result"]["costTracking"]>

  export type CostTrackingSelectScalar = {
    id?: boolean
    period?: boolean
    totalCost?: boolean
    tokenUsage?: boolean
    requestCount?: boolean
    breakdown?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    userId?: boolean
  }

  export type CostTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | CostTracking$userArgs<ExtArgs>
  }
  export type CostTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | CostTracking$userArgs<ExtArgs>
  }

  export type $CostTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostTracking"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: string
      totalCost: number
      tokenUsage: number
      requestCount: number
      breakdown: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      userId: string | null
    }, ExtArgs["result"]["costTracking"]>
    composites: {}
  }

  type CostTrackingGetPayload<S extends boolean | null | undefined | CostTrackingDefaultArgs> = $Result.GetResult<Prisma.$CostTrackingPayload, S>

  type CostTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostTrackingCountAggregateInputType | true
    }

  export interface CostTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostTracking'], meta: { name: 'CostTracking' } }
    /**
     * Find zero or one CostTracking that matches the filter.
     * @param {CostTrackingFindUniqueArgs} args - Arguments to find a CostTracking
     * @example
     * // Get one CostTracking
     * const costTracking = await prisma.costTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostTrackingFindUniqueArgs>(args: SelectSubset<T, CostTrackingFindUniqueArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostTracking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostTrackingFindUniqueOrThrowArgs} args - Arguments to find a CostTracking
     * @example
     * // Get one CostTracking
     * const costTracking = await prisma.costTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, CostTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingFindFirstArgs} args - Arguments to find a CostTracking
     * @example
     * // Get one CostTracking
     * const costTracking = await prisma.costTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostTrackingFindFirstArgs>(args?: SelectSubset<T, CostTrackingFindFirstArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingFindFirstOrThrowArgs} args - Arguments to find a CostTracking
     * @example
     * // Get one CostTracking
     * const costTracking = await prisma.costTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, CostTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostTrackings
     * const costTrackings = await prisma.costTracking.findMany()
     * 
     * // Get first 10 CostTrackings
     * const costTrackings = await prisma.costTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costTrackingWithIdOnly = await prisma.costTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostTrackingFindManyArgs>(args?: SelectSubset<T, CostTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostTracking.
     * @param {CostTrackingCreateArgs} args - Arguments to create a CostTracking.
     * @example
     * // Create one CostTracking
     * const CostTracking = await prisma.costTracking.create({
     *   data: {
     *     // ... data to create a CostTracking
     *   }
     * })
     * 
     */
    create<T extends CostTrackingCreateArgs>(args: SelectSubset<T, CostTrackingCreateArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostTrackings.
     * @param {CostTrackingCreateManyArgs} args - Arguments to create many CostTrackings.
     * @example
     * // Create many CostTrackings
     * const costTracking = await prisma.costTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostTrackingCreateManyArgs>(args?: SelectSubset<T, CostTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostTrackings and returns the data saved in the database.
     * @param {CostTrackingCreateManyAndReturnArgs} args - Arguments to create many CostTrackings.
     * @example
     * // Create many CostTrackings
     * const costTracking = await prisma.costTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostTrackings and only return the `id`
     * const costTrackingWithIdOnly = await prisma.costTracking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, CostTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CostTracking.
     * @param {CostTrackingDeleteArgs} args - Arguments to delete one CostTracking.
     * @example
     * // Delete one CostTracking
     * const CostTracking = await prisma.costTracking.delete({
     *   where: {
     *     // ... filter to delete one CostTracking
     *   }
     * })
     * 
     */
    delete<T extends CostTrackingDeleteArgs>(args: SelectSubset<T, CostTrackingDeleteArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostTracking.
     * @param {CostTrackingUpdateArgs} args - Arguments to update one CostTracking.
     * @example
     * // Update one CostTracking
     * const costTracking = await prisma.costTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostTrackingUpdateArgs>(args: SelectSubset<T, CostTrackingUpdateArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostTrackings.
     * @param {CostTrackingDeleteManyArgs} args - Arguments to filter CostTrackings to delete.
     * @example
     * // Delete a few CostTrackings
     * const { count } = await prisma.costTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostTrackingDeleteManyArgs>(args?: SelectSubset<T, CostTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostTrackings
     * const costTracking = await prisma.costTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostTrackingUpdateManyArgs>(args: SelectSubset<T, CostTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostTracking.
     * @param {CostTrackingUpsertArgs} args - Arguments to update or create a CostTracking.
     * @example
     * // Update or create a CostTracking
     * const costTracking = await prisma.costTracking.upsert({
     *   create: {
     *     // ... data to create a CostTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostTracking we want to update
     *   }
     * })
     */
    upsert<T extends CostTrackingUpsertArgs>(args: SelectSubset<T, CostTrackingUpsertArgs<ExtArgs>>): Prisma__CostTrackingClient<$Result.GetResult<Prisma.$CostTrackingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingCountArgs} args - Arguments to filter CostTrackings to count.
     * @example
     * // Count the number of CostTrackings
     * const count = await prisma.costTracking.count({
     *   where: {
     *     // ... the filter for the CostTrackings we want to count
     *   }
     * })
    **/
    count<T extends CostTrackingCountArgs>(
      args?: Subset<T, CostTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostTrackingAggregateArgs>(args: Subset<T, CostTrackingAggregateArgs>): Prisma.PrismaPromise<GetCostTrackingAggregateType<T>>

    /**
     * Group by CostTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostTrackingGroupByArgs['orderBy'] }
        : { orderBy?: CostTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostTracking model
   */
  readonly fields: CostTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends CostTracking$userArgs<ExtArgs> = {}>(args?: Subset<T, CostTracking$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostTracking model
   */ 
  interface CostTrackingFieldRefs {
    readonly id: FieldRef<"CostTracking", 'String'>
    readonly period: FieldRef<"CostTracking", 'String'>
    readonly totalCost: FieldRef<"CostTracking", 'Float'>
    readonly tokenUsage: FieldRef<"CostTracking", 'Int'>
    readonly requestCount: FieldRef<"CostTracking", 'Int'>
    readonly breakdown: FieldRef<"CostTracking", 'String'>
    readonly createdAt: FieldRef<"CostTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"CostTracking", 'DateTime'>
    readonly projectId: FieldRef<"CostTracking", 'String'>
    readonly userId: FieldRef<"CostTracking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CostTracking findUnique
   */
  export type CostTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * Filter, which CostTracking to fetch.
     */
    where: CostTrackingWhereUniqueInput
  }

  /**
   * CostTracking findUniqueOrThrow
   */
  export type CostTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * Filter, which CostTracking to fetch.
     */
    where: CostTrackingWhereUniqueInput
  }

  /**
   * CostTracking findFirst
   */
  export type CostTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * Filter, which CostTracking to fetch.
     */
    where?: CostTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTrackings to fetch.
     */
    orderBy?: CostTrackingOrderByWithRelationInput | CostTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostTrackings.
     */
    cursor?: CostTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostTrackings.
     */
    distinct?: CostTrackingScalarFieldEnum | CostTrackingScalarFieldEnum[]
  }

  /**
   * CostTracking findFirstOrThrow
   */
  export type CostTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * Filter, which CostTracking to fetch.
     */
    where?: CostTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTrackings to fetch.
     */
    orderBy?: CostTrackingOrderByWithRelationInput | CostTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostTrackings.
     */
    cursor?: CostTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostTrackings.
     */
    distinct?: CostTrackingScalarFieldEnum | CostTrackingScalarFieldEnum[]
  }

  /**
   * CostTracking findMany
   */
  export type CostTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * Filter, which CostTrackings to fetch.
     */
    where?: CostTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostTrackings to fetch.
     */
    orderBy?: CostTrackingOrderByWithRelationInput | CostTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostTrackings.
     */
    cursor?: CostTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostTrackings.
     */
    skip?: number
    distinct?: CostTrackingScalarFieldEnum | CostTrackingScalarFieldEnum[]
  }

  /**
   * CostTracking create
   */
  export type CostTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a CostTracking.
     */
    data: XOR<CostTrackingCreateInput, CostTrackingUncheckedCreateInput>
  }

  /**
   * CostTracking createMany
   */
  export type CostTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostTrackings.
     */
    data: CostTrackingCreateManyInput | CostTrackingCreateManyInput[]
  }

  /**
   * CostTracking createManyAndReturn
   */
  export type CostTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CostTrackings.
     */
    data: CostTrackingCreateManyInput | CostTrackingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostTracking update
   */
  export type CostTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a CostTracking.
     */
    data: XOR<CostTrackingUpdateInput, CostTrackingUncheckedUpdateInput>
    /**
     * Choose, which CostTracking to update.
     */
    where: CostTrackingWhereUniqueInput
  }

  /**
   * CostTracking updateMany
   */
  export type CostTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostTrackings.
     */
    data: XOR<CostTrackingUpdateManyMutationInput, CostTrackingUncheckedUpdateManyInput>
    /**
     * Filter which CostTrackings to update
     */
    where?: CostTrackingWhereInput
  }

  /**
   * CostTracking upsert
   */
  export type CostTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the CostTracking to update in case it exists.
     */
    where: CostTrackingWhereUniqueInput
    /**
     * In case the CostTracking found by the `where` argument doesn't exist, create a new CostTracking with this data.
     */
    create: XOR<CostTrackingCreateInput, CostTrackingUncheckedCreateInput>
    /**
     * In case the CostTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostTrackingUpdateInput, CostTrackingUncheckedUpdateInput>
  }

  /**
   * CostTracking delete
   */
  export type CostTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
    /**
     * Filter which CostTracking to delete.
     */
    where: CostTrackingWhereUniqueInput
  }

  /**
   * CostTracking deleteMany
   */
  export type CostTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostTrackings to delete
     */
    where?: CostTrackingWhereInput
  }

  /**
   * CostTracking.user
   */
  export type CostTracking$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CostTracking without action
   */
  export type CostTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostTracking
     */
    select?: CostTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostTrackingInclude<ExtArgs> | null
  }


  /**
   * Model UserBilling
   */

  export type AggregateUserBilling = {
    _count: UserBillingCountAggregateOutputType | null
    _avg: UserBillingAvgAggregateOutputType | null
    _sum: UserBillingSumAggregateOutputType | null
    _min: UserBillingMinAggregateOutputType | null
    _max: UserBillingMaxAggregateOutputType | null
  }

  export type UserBillingAvgAggregateOutputType = {
    monthlyLimit: number | null
    currentUsage: number | null
  }

  export type UserBillingSumAggregateOutputType = {
    monthlyLimit: number | null
    currentUsage: number | null
  }

  export type UserBillingMinAggregateOutputType = {
    id: string | null
    billingEmail: string | null
    plan: string | null
    monthlyLimit: number | null
    currentUsage: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserBillingMaxAggregateOutputType = {
    id: string | null
    billingEmail: string | null
    plan: string | null
    monthlyLimit: number | null
    currentUsage: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserBillingCountAggregateOutputType = {
    id: number
    billingEmail: number
    plan: number
    monthlyLimit: number
    currentUsage: number
    isActive: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type UserBillingAvgAggregateInputType = {
    monthlyLimit?: true
    currentUsage?: true
  }

  export type UserBillingSumAggregateInputType = {
    monthlyLimit?: true
    currentUsage?: true
  }

  export type UserBillingMinAggregateInputType = {
    id?: true
    billingEmail?: true
    plan?: true
    monthlyLimit?: true
    currentUsage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserBillingMaxAggregateInputType = {
    id?: true
    billingEmail?: true
    plan?: true
    monthlyLimit?: true
    currentUsage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserBillingCountAggregateInputType = {
    id?: true
    billingEmail?: true
    plan?: true
    monthlyLimit?: true
    currentUsage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type UserBillingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBilling to aggregate.
     */
    where?: UserBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBillings to fetch.
     */
    orderBy?: UserBillingOrderByWithRelationInput | UserBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBillings
    **/
    _count?: true | UserBillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBillingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBillingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBillingMaxAggregateInputType
  }

  export type GetUserBillingAggregateType<T extends UserBillingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBilling[P]>
      : GetScalarType<T[P], AggregateUserBilling[P]>
  }




  export type UserBillingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBillingWhereInput
    orderBy?: UserBillingOrderByWithAggregationInput | UserBillingOrderByWithAggregationInput[]
    by: UserBillingScalarFieldEnum[] | UserBillingScalarFieldEnum
    having?: UserBillingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBillingCountAggregateInputType | true
    _avg?: UserBillingAvgAggregateInputType
    _sum?: UserBillingSumAggregateInputType
    _min?: UserBillingMinAggregateInputType
    _max?: UserBillingMaxAggregateInputType
  }

  export type UserBillingGroupByOutputType = {
    id: string
    billingEmail: string | null
    plan: string
    monthlyLimit: number
    currentUsage: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: UserBillingCountAggregateOutputType | null
    _avg: UserBillingAvgAggregateOutputType | null
    _sum: UserBillingSumAggregateOutputType | null
    _min: UserBillingMinAggregateOutputType | null
    _max: UserBillingMaxAggregateOutputType | null
  }

  type GetUserBillingGroupByPayload<T extends UserBillingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBillingGroupByOutputType[P]>
            : GetScalarType<T[P], UserBillingGroupByOutputType[P]>
        }
      >
    >


  export type UserBillingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billingEmail?: boolean
    plan?: boolean
    monthlyLimit?: boolean
    currentUsage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBilling"]>

  export type UserBillingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billingEmail?: boolean
    plan?: boolean
    monthlyLimit?: boolean
    currentUsage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBilling"]>

  export type UserBillingSelectScalar = {
    id?: boolean
    billingEmail?: boolean
    plan?: boolean
    monthlyLimit?: boolean
    currentUsage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type UserBillingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBillingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBillingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBilling"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billingEmail: string | null
      plan: string
      monthlyLimit: number
      currentUsage: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["userBilling"]>
    composites: {}
  }

  type UserBillingGetPayload<S extends boolean | null | undefined | UserBillingDefaultArgs> = $Result.GetResult<Prisma.$UserBillingPayload, S>

  type UserBillingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBillingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBillingCountAggregateInputType | true
    }

  export interface UserBillingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBilling'], meta: { name: 'UserBilling' } }
    /**
     * Find zero or one UserBilling that matches the filter.
     * @param {UserBillingFindUniqueArgs} args - Arguments to find a UserBilling
     * @example
     * // Get one UserBilling
     * const userBilling = await prisma.userBilling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBillingFindUniqueArgs>(args: SelectSubset<T, UserBillingFindUniqueArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBilling that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBillingFindUniqueOrThrowArgs} args - Arguments to find a UserBilling
     * @example
     * // Get one UserBilling
     * const userBilling = await prisma.userBilling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBillingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBillingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBilling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingFindFirstArgs} args - Arguments to find a UserBilling
     * @example
     * // Get one UserBilling
     * const userBilling = await prisma.userBilling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBillingFindFirstArgs>(args?: SelectSubset<T, UserBillingFindFirstArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBilling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingFindFirstOrThrowArgs} args - Arguments to find a UserBilling
     * @example
     * // Get one UserBilling
     * const userBilling = await prisma.userBilling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBillingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBillingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBillings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBillings
     * const userBillings = await prisma.userBilling.findMany()
     * 
     * // Get first 10 UserBillings
     * const userBillings = await prisma.userBilling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBillingWithIdOnly = await prisma.userBilling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBillingFindManyArgs>(args?: SelectSubset<T, UserBillingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBilling.
     * @param {UserBillingCreateArgs} args - Arguments to create a UserBilling.
     * @example
     * // Create one UserBilling
     * const UserBilling = await prisma.userBilling.create({
     *   data: {
     *     // ... data to create a UserBilling
     *   }
     * })
     * 
     */
    create<T extends UserBillingCreateArgs>(args: SelectSubset<T, UserBillingCreateArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBillings.
     * @param {UserBillingCreateManyArgs} args - Arguments to create many UserBillings.
     * @example
     * // Create many UserBillings
     * const userBilling = await prisma.userBilling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBillingCreateManyArgs>(args?: SelectSubset<T, UserBillingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBillings and returns the data saved in the database.
     * @param {UserBillingCreateManyAndReturnArgs} args - Arguments to create many UserBillings.
     * @example
     * // Create many UserBillings
     * const userBilling = await prisma.userBilling.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBillings and only return the `id`
     * const userBillingWithIdOnly = await prisma.userBilling.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBillingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBillingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBilling.
     * @param {UserBillingDeleteArgs} args - Arguments to delete one UserBilling.
     * @example
     * // Delete one UserBilling
     * const UserBilling = await prisma.userBilling.delete({
     *   where: {
     *     // ... filter to delete one UserBilling
     *   }
     * })
     * 
     */
    delete<T extends UserBillingDeleteArgs>(args: SelectSubset<T, UserBillingDeleteArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBilling.
     * @param {UserBillingUpdateArgs} args - Arguments to update one UserBilling.
     * @example
     * // Update one UserBilling
     * const userBilling = await prisma.userBilling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBillingUpdateArgs>(args: SelectSubset<T, UserBillingUpdateArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBillings.
     * @param {UserBillingDeleteManyArgs} args - Arguments to filter UserBillings to delete.
     * @example
     * // Delete a few UserBillings
     * const { count } = await prisma.userBilling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBillingDeleteManyArgs>(args?: SelectSubset<T, UserBillingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBillings
     * const userBilling = await prisma.userBilling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBillingUpdateManyArgs>(args: SelectSubset<T, UserBillingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBilling.
     * @param {UserBillingUpsertArgs} args - Arguments to update or create a UserBilling.
     * @example
     * // Update or create a UserBilling
     * const userBilling = await prisma.userBilling.upsert({
     *   create: {
     *     // ... data to create a UserBilling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBilling we want to update
     *   }
     * })
     */
    upsert<T extends UserBillingUpsertArgs>(args: SelectSubset<T, UserBillingUpsertArgs<ExtArgs>>): Prisma__UserBillingClient<$Result.GetResult<Prisma.$UserBillingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingCountArgs} args - Arguments to filter UserBillings to count.
     * @example
     * // Count the number of UserBillings
     * const count = await prisma.userBilling.count({
     *   where: {
     *     // ... the filter for the UserBillings we want to count
     *   }
     * })
    **/
    count<T extends UserBillingCountArgs>(
      args?: Subset<T, UserBillingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBillingAggregateArgs>(args: Subset<T, UserBillingAggregateArgs>): Prisma.PrismaPromise<GetUserBillingAggregateType<T>>

    /**
     * Group by UserBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBillingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBillingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBillingGroupByArgs['orderBy'] }
        : { orderBy?: UserBillingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBillingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBillingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBilling model
   */
  readonly fields: UserBillingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBilling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBillingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBilling model
   */ 
  interface UserBillingFieldRefs {
    readonly id: FieldRef<"UserBilling", 'String'>
    readonly billingEmail: FieldRef<"UserBilling", 'String'>
    readonly plan: FieldRef<"UserBilling", 'String'>
    readonly monthlyLimit: FieldRef<"UserBilling", 'Float'>
    readonly currentUsage: FieldRef<"UserBilling", 'Float'>
    readonly isActive: FieldRef<"UserBilling", 'Boolean'>
    readonly createdAt: FieldRef<"UserBilling", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBilling", 'DateTime'>
    readonly userId: FieldRef<"UserBilling", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserBilling findUnique
   */
  export type UserBillingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * Filter, which UserBilling to fetch.
     */
    where: UserBillingWhereUniqueInput
  }

  /**
   * UserBilling findUniqueOrThrow
   */
  export type UserBillingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * Filter, which UserBilling to fetch.
     */
    where: UserBillingWhereUniqueInput
  }

  /**
   * UserBilling findFirst
   */
  export type UserBillingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * Filter, which UserBilling to fetch.
     */
    where?: UserBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBillings to fetch.
     */
    orderBy?: UserBillingOrderByWithRelationInput | UserBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBillings.
     */
    cursor?: UserBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBillings.
     */
    distinct?: UserBillingScalarFieldEnum | UserBillingScalarFieldEnum[]
  }

  /**
   * UserBilling findFirstOrThrow
   */
  export type UserBillingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * Filter, which UserBilling to fetch.
     */
    where?: UserBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBillings to fetch.
     */
    orderBy?: UserBillingOrderByWithRelationInput | UserBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBillings.
     */
    cursor?: UserBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBillings.
     */
    distinct?: UserBillingScalarFieldEnum | UserBillingScalarFieldEnum[]
  }

  /**
   * UserBilling findMany
   */
  export type UserBillingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * Filter, which UserBillings to fetch.
     */
    where?: UserBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBillings to fetch.
     */
    orderBy?: UserBillingOrderByWithRelationInput | UserBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBillings.
     */
    cursor?: UserBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBillings.
     */
    skip?: number
    distinct?: UserBillingScalarFieldEnum | UserBillingScalarFieldEnum[]
  }

  /**
   * UserBilling create
   */
  export type UserBillingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBilling.
     */
    data: XOR<UserBillingCreateInput, UserBillingUncheckedCreateInput>
  }

  /**
   * UserBilling createMany
   */
  export type UserBillingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBillings.
     */
    data: UserBillingCreateManyInput | UserBillingCreateManyInput[]
  }

  /**
   * UserBilling createManyAndReturn
   */
  export type UserBillingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBillings.
     */
    data: UserBillingCreateManyInput | UserBillingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBilling update
   */
  export type UserBillingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBilling.
     */
    data: XOR<UserBillingUpdateInput, UserBillingUncheckedUpdateInput>
    /**
     * Choose, which UserBilling to update.
     */
    where: UserBillingWhereUniqueInput
  }

  /**
   * UserBilling updateMany
   */
  export type UserBillingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBillings.
     */
    data: XOR<UserBillingUpdateManyMutationInput, UserBillingUncheckedUpdateManyInput>
    /**
     * Filter which UserBillings to update
     */
    where?: UserBillingWhereInput
  }

  /**
   * UserBilling upsert
   */
  export type UserBillingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBilling to update in case it exists.
     */
    where: UserBillingWhereUniqueInput
    /**
     * In case the UserBilling found by the `where` argument doesn't exist, create a new UserBilling with this data.
     */
    create: XOR<UserBillingCreateInput, UserBillingUncheckedCreateInput>
    /**
     * In case the UserBilling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBillingUpdateInput, UserBillingUncheckedUpdateInput>
  }

  /**
   * UserBilling delete
   */
  export type UserBillingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
    /**
     * Filter which UserBilling to delete.
     */
    where: UserBillingWhereUniqueInput
  }

  /**
   * UserBilling deleteMany
   */
  export type UserBillingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBillings to delete
     */
    where?: UserBillingWhereInput
  }

  /**
   * UserBilling without action
   */
  export type UserBillingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBilling
     */
    select?: UserBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBillingInclude<ExtArgs> | null
  }


  /**
   * Model AppIntegration
   */

  export type AggregateAppIntegration = {
    _count: AppIntegrationCountAggregateOutputType | null
    _min: AppIntegrationMinAggregateOutputType | null
    _max: AppIntegrationMaxAggregateOutputType | null
  }

  export type AppIntegrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    baseUrl: string | null
    apiKeyHash: string | null
    syncConfig: string | null
    isActive: boolean | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type AppIntegrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    baseUrl: string | null
    apiKeyHash: string | null
    syncConfig: string | null
    isActive: boolean | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type AppIntegrationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    baseUrl: number
    apiKeyHash: number
    syncConfig: number
    isActive: number
    lastSync: number
    createdAt: number
    updatedAt: number
    projectId: number
    createdBy: number
    _all: number
  }


  export type AppIntegrationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    baseUrl?: true
    apiKeyHash?: true
    syncConfig?: true
    isActive?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type AppIntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    baseUrl?: true
    apiKeyHash?: true
    syncConfig?: true
    isActive?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type AppIntegrationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    baseUrl?: true
    apiKeyHash?: true
    syncConfig?: true
    isActive?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    _all?: true
  }

  export type AppIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppIntegration to aggregate.
     */
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     */
    orderBy?: AppIntegrationOrderByWithRelationInput | AppIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppIntegrations
    **/
    _count?: true | AppIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppIntegrationMaxAggregateInputType
  }

  export type GetAppIntegrationAggregateType<T extends AppIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateAppIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppIntegration[P]>
      : GetScalarType<T[P], AggregateAppIntegration[P]>
  }




  export type AppIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppIntegrationWhereInput
    orderBy?: AppIntegrationOrderByWithAggregationInput | AppIntegrationOrderByWithAggregationInput[]
    by: AppIntegrationScalarFieldEnum[] | AppIntegrationScalarFieldEnum
    having?: AppIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppIntegrationCountAggregateInputType | true
    _min?: AppIntegrationMinAggregateInputType
    _max?: AppIntegrationMaxAggregateInputType
  }

  export type AppIntegrationGroupByOutputType = {
    id: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive: boolean
    lastSync: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    createdBy: string
    _count: AppIntegrationCountAggregateOutputType | null
    _min: AppIntegrationMinAggregateOutputType | null
    _max: AppIntegrationMaxAggregateOutputType | null
  }

  type GetAppIntegrationGroupByPayload<T extends AppIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], AppIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type AppIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    apiKeyHash?: boolean
    syncConfig?: boolean
    isActive?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    syncOperations?: boolean | AppIntegration$syncOperationsArgs<ExtArgs>
    _count?: boolean | AppIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appIntegration"]>

  export type AppIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    apiKeyHash?: boolean
    syncConfig?: boolean
    isActive?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appIntegration"]>

  export type AppIntegrationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    baseUrl?: boolean
    apiKeyHash?: boolean
    syncConfig?: boolean
    isActive?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
  }

  export type AppIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    syncOperations?: boolean | AppIntegration$syncOperationsArgs<ExtArgs>
    _count?: boolean | AppIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AppIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppIntegration"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      syncOperations: Prisma.$SyncOperationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      baseUrl: string
      apiKeyHash: string
      syncConfig: string
      isActive: boolean
      lastSync: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      createdBy: string
    }, ExtArgs["result"]["appIntegration"]>
    composites: {}
  }

  type AppIntegrationGetPayload<S extends boolean | null | undefined | AppIntegrationDefaultArgs> = $Result.GetResult<Prisma.$AppIntegrationPayload, S>

  type AppIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppIntegrationCountAggregateInputType | true
    }

  export interface AppIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppIntegration'], meta: { name: 'AppIntegration' } }
    /**
     * Find zero or one AppIntegration that matches the filter.
     * @param {AppIntegrationFindUniqueArgs} args - Arguments to find a AppIntegration
     * @example
     * // Get one AppIntegration
     * const appIntegration = await prisma.appIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppIntegrationFindUniqueArgs>(args: SelectSubset<T, AppIntegrationFindUniqueArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AppIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppIntegrationFindUniqueOrThrowArgs} args - Arguments to find a AppIntegration
     * @example
     * // Get one AppIntegration
     * const appIntegration = await prisma.appIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, AppIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AppIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationFindFirstArgs} args - Arguments to find a AppIntegration
     * @example
     * // Get one AppIntegration
     * const appIntegration = await prisma.appIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppIntegrationFindFirstArgs>(args?: SelectSubset<T, AppIntegrationFindFirstArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AppIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationFindFirstOrThrowArgs} args - Arguments to find a AppIntegration
     * @example
     * // Get one AppIntegration
     * const appIntegration = await prisma.appIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, AppIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AppIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppIntegrations
     * const appIntegrations = await prisma.appIntegration.findMany()
     * 
     * // Get first 10 AppIntegrations
     * const appIntegrations = await prisma.appIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appIntegrationWithIdOnly = await prisma.appIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppIntegrationFindManyArgs>(args?: SelectSubset<T, AppIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AppIntegration.
     * @param {AppIntegrationCreateArgs} args - Arguments to create a AppIntegration.
     * @example
     * // Create one AppIntegration
     * const AppIntegration = await prisma.appIntegration.create({
     *   data: {
     *     // ... data to create a AppIntegration
     *   }
     * })
     * 
     */
    create<T extends AppIntegrationCreateArgs>(args: SelectSubset<T, AppIntegrationCreateArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AppIntegrations.
     * @param {AppIntegrationCreateManyArgs} args - Arguments to create many AppIntegrations.
     * @example
     * // Create many AppIntegrations
     * const appIntegration = await prisma.appIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppIntegrationCreateManyArgs>(args?: SelectSubset<T, AppIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppIntegrations and returns the data saved in the database.
     * @param {AppIntegrationCreateManyAndReturnArgs} args - Arguments to create many AppIntegrations.
     * @example
     * // Create many AppIntegrations
     * const appIntegration = await prisma.appIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppIntegrations and only return the `id`
     * const appIntegrationWithIdOnly = await prisma.appIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, AppIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AppIntegration.
     * @param {AppIntegrationDeleteArgs} args - Arguments to delete one AppIntegration.
     * @example
     * // Delete one AppIntegration
     * const AppIntegration = await prisma.appIntegration.delete({
     *   where: {
     *     // ... filter to delete one AppIntegration
     *   }
     * })
     * 
     */
    delete<T extends AppIntegrationDeleteArgs>(args: SelectSubset<T, AppIntegrationDeleteArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AppIntegration.
     * @param {AppIntegrationUpdateArgs} args - Arguments to update one AppIntegration.
     * @example
     * // Update one AppIntegration
     * const appIntegration = await prisma.appIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppIntegrationUpdateArgs>(args: SelectSubset<T, AppIntegrationUpdateArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AppIntegrations.
     * @param {AppIntegrationDeleteManyArgs} args - Arguments to filter AppIntegrations to delete.
     * @example
     * // Delete a few AppIntegrations
     * const { count } = await prisma.appIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppIntegrationDeleteManyArgs>(args?: SelectSubset<T, AppIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppIntegrations
     * const appIntegration = await prisma.appIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppIntegrationUpdateManyArgs>(args: SelectSubset<T, AppIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppIntegration.
     * @param {AppIntegrationUpsertArgs} args - Arguments to update or create a AppIntegration.
     * @example
     * // Update or create a AppIntegration
     * const appIntegration = await prisma.appIntegration.upsert({
     *   create: {
     *     // ... data to create a AppIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppIntegration we want to update
     *   }
     * })
     */
    upsert<T extends AppIntegrationUpsertArgs>(args: SelectSubset<T, AppIntegrationUpsertArgs<ExtArgs>>): Prisma__AppIntegrationClient<$Result.GetResult<Prisma.$AppIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AppIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationCountArgs} args - Arguments to filter AppIntegrations to count.
     * @example
     * // Count the number of AppIntegrations
     * const count = await prisma.appIntegration.count({
     *   where: {
     *     // ... the filter for the AppIntegrations we want to count
     *   }
     * })
    **/
    count<T extends AppIntegrationCountArgs>(
      args?: Subset<T, AppIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppIntegrationAggregateArgs>(args: Subset<T, AppIntegrationAggregateArgs>): Prisma.PrismaPromise<GetAppIntegrationAggregateType<T>>

    /**
     * Group by AppIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: AppIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppIntegration model
   */
  readonly fields: AppIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    syncOperations<T extends AppIntegration$syncOperationsArgs<ExtArgs> = {}>(args?: Subset<T, AppIntegration$syncOperationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppIntegration model
   */ 
  interface AppIntegrationFieldRefs {
    readonly id: FieldRef<"AppIntegration", 'String'>
    readonly name: FieldRef<"AppIntegration", 'String'>
    readonly type: FieldRef<"AppIntegration", 'String'>
    readonly baseUrl: FieldRef<"AppIntegration", 'String'>
    readonly apiKeyHash: FieldRef<"AppIntegration", 'String'>
    readonly syncConfig: FieldRef<"AppIntegration", 'String'>
    readonly isActive: FieldRef<"AppIntegration", 'Boolean'>
    readonly lastSync: FieldRef<"AppIntegration", 'DateTime'>
    readonly createdAt: FieldRef<"AppIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"AppIntegration", 'DateTime'>
    readonly projectId: FieldRef<"AppIntegration", 'String'>
    readonly createdBy: FieldRef<"AppIntegration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AppIntegration findUnique
   */
  export type AppIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which AppIntegration to fetch.
     */
    where: AppIntegrationWhereUniqueInput
  }

  /**
   * AppIntegration findUniqueOrThrow
   */
  export type AppIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which AppIntegration to fetch.
     */
    where: AppIntegrationWhereUniqueInput
  }

  /**
   * AppIntegration findFirst
   */
  export type AppIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which AppIntegration to fetch.
     */
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     */
    orderBy?: AppIntegrationOrderByWithRelationInput | AppIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppIntegrations.
     */
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppIntegrations.
     */
    distinct?: AppIntegrationScalarFieldEnum | AppIntegrationScalarFieldEnum[]
  }

  /**
   * AppIntegration findFirstOrThrow
   */
  export type AppIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which AppIntegration to fetch.
     */
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     */
    orderBy?: AppIntegrationOrderByWithRelationInput | AppIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppIntegrations.
     */
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppIntegrations.
     */
    distinct?: AppIntegrationScalarFieldEnum | AppIntegrationScalarFieldEnum[]
  }

  /**
   * AppIntegration findMany
   */
  export type AppIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which AppIntegrations to fetch.
     */
    where?: AppIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIntegrations to fetch.
     */
    orderBy?: AppIntegrationOrderByWithRelationInput | AppIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppIntegrations.
     */
    cursor?: AppIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIntegrations.
     */
    skip?: number
    distinct?: AppIntegrationScalarFieldEnum | AppIntegrationScalarFieldEnum[]
  }

  /**
   * AppIntegration create
   */
  export type AppIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a AppIntegration.
     */
    data: XOR<AppIntegrationCreateInput, AppIntegrationUncheckedCreateInput>
  }

  /**
   * AppIntegration createMany
   */
  export type AppIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppIntegrations.
     */
    data: AppIntegrationCreateManyInput | AppIntegrationCreateManyInput[]
  }

  /**
   * AppIntegration createManyAndReturn
   */
  export type AppIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AppIntegrations.
     */
    data: AppIntegrationCreateManyInput | AppIntegrationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppIntegration update
   */
  export type AppIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a AppIntegration.
     */
    data: XOR<AppIntegrationUpdateInput, AppIntegrationUncheckedUpdateInput>
    /**
     * Choose, which AppIntegration to update.
     */
    where: AppIntegrationWhereUniqueInput
  }

  /**
   * AppIntegration updateMany
   */
  export type AppIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppIntegrations.
     */
    data: XOR<AppIntegrationUpdateManyMutationInput, AppIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which AppIntegrations to update
     */
    where?: AppIntegrationWhereInput
  }

  /**
   * AppIntegration upsert
   */
  export type AppIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the AppIntegration to update in case it exists.
     */
    where: AppIntegrationWhereUniqueInput
    /**
     * In case the AppIntegration found by the `where` argument doesn't exist, create a new AppIntegration with this data.
     */
    create: XOR<AppIntegrationCreateInput, AppIntegrationUncheckedCreateInput>
    /**
     * In case the AppIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppIntegrationUpdateInput, AppIntegrationUncheckedUpdateInput>
  }

  /**
   * AppIntegration delete
   */
  export type AppIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
    /**
     * Filter which AppIntegration to delete.
     */
    where: AppIntegrationWhereUniqueInput
  }

  /**
   * AppIntegration deleteMany
   */
  export type AppIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppIntegrations to delete
     */
    where?: AppIntegrationWhereInput
  }

  /**
   * AppIntegration.syncOperations
   */
  export type AppIntegration$syncOperationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncOperation
     */
    select?: SyncOperationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncOperationInclude<ExtArgs> | null
    where?: SyncOperationWhereInput
    orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[]
    cursor?: SyncOperationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[]
  }

  /**
   * AppIntegration without action
   */
  export type AppIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIntegration
     */
    select?: AppIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model TestPipeline
   */

  export type AggregateTestPipeline = {
    _count: TestPipelineCountAggregateOutputType | null
    _min: TestPipelineMinAggregateOutputType | null
    _max: TestPipelineMaxAggregateOutputType | null
  }

  export type TestPipelineMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    config: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type TestPipelineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    config: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type TestPipelineCountAggregateOutputType = {
    id: number
    name: number
    description: number
    config: number
    status: number
    createdAt: number
    updatedAt: number
    projectId: number
    createdBy: number
    _all: number
  }


  export type TestPipelineMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    config?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type TestPipelineMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    config?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type TestPipelineCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    config?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    _all?: true
  }

  export type TestPipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestPipeline to aggregate.
     */
    where?: TestPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPipelines to fetch.
     */
    orderBy?: TestPipelineOrderByWithRelationInput | TestPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestPipelines
    **/
    _count?: true | TestPipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestPipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestPipelineMaxAggregateInputType
  }

  export type GetTestPipelineAggregateType<T extends TestPipelineAggregateArgs> = {
        [P in keyof T & keyof AggregateTestPipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestPipeline[P]>
      : GetScalarType<T[P], AggregateTestPipeline[P]>
  }




  export type TestPipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestPipelineWhereInput
    orderBy?: TestPipelineOrderByWithAggregationInput | TestPipelineOrderByWithAggregationInput[]
    by: TestPipelineScalarFieldEnum[] | TestPipelineScalarFieldEnum
    having?: TestPipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestPipelineCountAggregateInputType | true
    _min?: TestPipelineMinAggregateInputType
    _max?: TestPipelineMaxAggregateInputType
  }

  export type TestPipelineGroupByOutputType = {
    id: string
    name: string
    description: string | null
    config: string
    status: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    createdBy: string
    _count: TestPipelineCountAggregateOutputType | null
    _min: TestPipelineMinAggregateOutputType | null
    _max: TestPipelineMaxAggregateOutputType | null
  }

  type GetTestPipelineGroupByPayload<T extends TestPipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestPipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestPipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestPipelineGroupByOutputType[P]>
            : GetScalarType<T[P], TestPipelineGroupByOutputType[P]>
        }
      >
    >


  export type TestPipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    stages?: boolean | TestPipeline$stagesArgs<ExtArgs>
    executions?: boolean | TestPipeline$executionsArgs<ExtArgs>
    _count?: boolean | TestPipelineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testPipeline"]>

  export type TestPipelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testPipeline"]>

  export type TestPipelineSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    config?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
  }

  export type TestPipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    stages?: boolean | TestPipeline$stagesArgs<ExtArgs>
    executions?: boolean | TestPipeline$executionsArgs<ExtArgs>
    _count?: boolean | TestPipelineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestPipelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestPipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestPipeline"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      stages: Prisma.$PipelineStagePayload<ExtArgs>[]
      executions: Prisma.$PipelineExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      config: string
      status: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      createdBy: string
    }, ExtArgs["result"]["testPipeline"]>
    composites: {}
  }

  type TestPipelineGetPayload<S extends boolean | null | undefined | TestPipelineDefaultArgs> = $Result.GetResult<Prisma.$TestPipelinePayload, S>

  type TestPipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestPipelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestPipelineCountAggregateInputType | true
    }

  export interface TestPipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestPipeline'], meta: { name: 'TestPipeline' } }
    /**
     * Find zero or one TestPipeline that matches the filter.
     * @param {TestPipelineFindUniqueArgs} args - Arguments to find a TestPipeline
     * @example
     * // Get one TestPipeline
     * const testPipeline = await prisma.testPipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestPipelineFindUniqueArgs>(args: SelectSubset<T, TestPipelineFindUniqueArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TestPipeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TestPipelineFindUniqueOrThrowArgs} args - Arguments to find a TestPipeline
     * @example
     * // Get one TestPipeline
     * const testPipeline = await prisma.testPipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestPipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, TestPipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TestPipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineFindFirstArgs} args - Arguments to find a TestPipeline
     * @example
     * // Get one TestPipeline
     * const testPipeline = await prisma.testPipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestPipelineFindFirstArgs>(args?: SelectSubset<T, TestPipelineFindFirstArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TestPipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineFindFirstOrThrowArgs} args - Arguments to find a TestPipeline
     * @example
     * // Get one TestPipeline
     * const testPipeline = await prisma.testPipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestPipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, TestPipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TestPipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestPipelines
     * const testPipelines = await prisma.testPipeline.findMany()
     * 
     * // Get first 10 TestPipelines
     * const testPipelines = await prisma.testPipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testPipelineWithIdOnly = await prisma.testPipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestPipelineFindManyArgs>(args?: SelectSubset<T, TestPipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TestPipeline.
     * @param {TestPipelineCreateArgs} args - Arguments to create a TestPipeline.
     * @example
     * // Create one TestPipeline
     * const TestPipeline = await prisma.testPipeline.create({
     *   data: {
     *     // ... data to create a TestPipeline
     *   }
     * })
     * 
     */
    create<T extends TestPipelineCreateArgs>(args: SelectSubset<T, TestPipelineCreateArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TestPipelines.
     * @param {TestPipelineCreateManyArgs} args - Arguments to create many TestPipelines.
     * @example
     * // Create many TestPipelines
     * const testPipeline = await prisma.testPipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestPipelineCreateManyArgs>(args?: SelectSubset<T, TestPipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestPipelines and returns the data saved in the database.
     * @param {TestPipelineCreateManyAndReturnArgs} args - Arguments to create many TestPipelines.
     * @example
     * // Create many TestPipelines
     * const testPipeline = await prisma.testPipeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestPipelines and only return the `id`
     * const testPipelineWithIdOnly = await prisma.testPipeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestPipelineCreateManyAndReturnArgs>(args?: SelectSubset<T, TestPipelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TestPipeline.
     * @param {TestPipelineDeleteArgs} args - Arguments to delete one TestPipeline.
     * @example
     * // Delete one TestPipeline
     * const TestPipeline = await prisma.testPipeline.delete({
     *   where: {
     *     // ... filter to delete one TestPipeline
     *   }
     * })
     * 
     */
    delete<T extends TestPipelineDeleteArgs>(args: SelectSubset<T, TestPipelineDeleteArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TestPipeline.
     * @param {TestPipelineUpdateArgs} args - Arguments to update one TestPipeline.
     * @example
     * // Update one TestPipeline
     * const testPipeline = await prisma.testPipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestPipelineUpdateArgs>(args: SelectSubset<T, TestPipelineUpdateArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TestPipelines.
     * @param {TestPipelineDeleteManyArgs} args - Arguments to filter TestPipelines to delete.
     * @example
     * // Delete a few TestPipelines
     * const { count } = await prisma.testPipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestPipelineDeleteManyArgs>(args?: SelectSubset<T, TestPipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestPipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestPipelines
     * const testPipeline = await prisma.testPipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestPipelineUpdateManyArgs>(args: SelectSubset<T, TestPipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestPipeline.
     * @param {TestPipelineUpsertArgs} args - Arguments to update or create a TestPipeline.
     * @example
     * // Update or create a TestPipeline
     * const testPipeline = await prisma.testPipeline.upsert({
     *   create: {
     *     // ... data to create a TestPipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestPipeline we want to update
     *   }
     * })
     */
    upsert<T extends TestPipelineUpsertArgs>(args: SelectSubset<T, TestPipelineUpsertArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TestPipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineCountArgs} args - Arguments to filter TestPipelines to count.
     * @example
     * // Count the number of TestPipelines
     * const count = await prisma.testPipeline.count({
     *   where: {
     *     // ... the filter for the TestPipelines we want to count
     *   }
     * })
    **/
    count<T extends TestPipelineCountArgs>(
      args?: Subset<T, TestPipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestPipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestPipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestPipelineAggregateArgs>(args: Subset<T, TestPipelineAggregateArgs>): Prisma.PrismaPromise<GetTestPipelineAggregateType<T>>

    /**
     * Group by TestPipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestPipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestPipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestPipelineGroupByArgs['orderBy'] }
        : { orderBy?: TestPipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestPipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestPipeline model
   */
  readonly fields: TestPipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestPipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestPipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stages<T extends TestPipeline$stagesArgs<ExtArgs> = {}>(args?: Subset<T, TestPipeline$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findMany"> | Null>
    executions<T extends TestPipeline$executionsArgs<ExtArgs> = {}>(args?: Subset<T, TestPipeline$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestPipeline model
   */ 
  interface TestPipelineFieldRefs {
    readonly id: FieldRef<"TestPipeline", 'String'>
    readonly name: FieldRef<"TestPipeline", 'String'>
    readonly description: FieldRef<"TestPipeline", 'String'>
    readonly config: FieldRef<"TestPipeline", 'String'>
    readonly status: FieldRef<"TestPipeline", 'String'>
    readonly createdAt: FieldRef<"TestPipeline", 'DateTime'>
    readonly updatedAt: FieldRef<"TestPipeline", 'DateTime'>
    readonly projectId: FieldRef<"TestPipeline", 'String'>
    readonly createdBy: FieldRef<"TestPipeline", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestPipeline findUnique
   */
  export type TestPipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * Filter, which TestPipeline to fetch.
     */
    where: TestPipelineWhereUniqueInput
  }

  /**
   * TestPipeline findUniqueOrThrow
   */
  export type TestPipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * Filter, which TestPipeline to fetch.
     */
    where: TestPipelineWhereUniqueInput
  }

  /**
   * TestPipeline findFirst
   */
  export type TestPipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * Filter, which TestPipeline to fetch.
     */
    where?: TestPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPipelines to fetch.
     */
    orderBy?: TestPipelineOrderByWithRelationInput | TestPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestPipelines.
     */
    cursor?: TestPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestPipelines.
     */
    distinct?: TestPipelineScalarFieldEnum | TestPipelineScalarFieldEnum[]
  }

  /**
   * TestPipeline findFirstOrThrow
   */
  export type TestPipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * Filter, which TestPipeline to fetch.
     */
    where?: TestPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPipelines to fetch.
     */
    orderBy?: TestPipelineOrderByWithRelationInput | TestPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestPipelines.
     */
    cursor?: TestPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestPipelines.
     */
    distinct?: TestPipelineScalarFieldEnum | TestPipelineScalarFieldEnum[]
  }

  /**
   * TestPipeline findMany
   */
  export type TestPipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * Filter, which TestPipelines to fetch.
     */
    where?: TestPipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestPipelines to fetch.
     */
    orderBy?: TestPipelineOrderByWithRelationInput | TestPipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestPipelines.
     */
    cursor?: TestPipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestPipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestPipelines.
     */
    skip?: number
    distinct?: TestPipelineScalarFieldEnum | TestPipelineScalarFieldEnum[]
  }

  /**
   * TestPipeline create
   */
  export type TestPipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a TestPipeline.
     */
    data: XOR<TestPipelineCreateInput, TestPipelineUncheckedCreateInput>
  }

  /**
   * TestPipeline createMany
   */
  export type TestPipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestPipelines.
     */
    data: TestPipelineCreateManyInput | TestPipelineCreateManyInput[]
  }

  /**
   * TestPipeline createManyAndReturn
   */
  export type TestPipelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TestPipelines.
     */
    data: TestPipelineCreateManyInput | TestPipelineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestPipeline update
   */
  export type TestPipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a TestPipeline.
     */
    data: XOR<TestPipelineUpdateInput, TestPipelineUncheckedUpdateInput>
    /**
     * Choose, which TestPipeline to update.
     */
    where: TestPipelineWhereUniqueInput
  }

  /**
   * TestPipeline updateMany
   */
  export type TestPipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestPipelines.
     */
    data: XOR<TestPipelineUpdateManyMutationInput, TestPipelineUncheckedUpdateManyInput>
    /**
     * Filter which TestPipelines to update
     */
    where?: TestPipelineWhereInput
  }

  /**
   * TestPipeline upsert
   */
  export type TestPipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the TestPipeline to update in case it exists.
     */
    where: TestPipelineWhereUniqueInput
    /**
     * In case the TestPipeline found by the `where` argument doesn't exist, create a new TestPipeline with this data.
     */
    create: XOR<TestPipelineCreateInput, TestPipelineUncheckedCreateInput>
    /**
     * In case the TestPipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestPipelineUpdateInput, TestPipelineUncheckedUpdateInput>
  }

  /**
   * TestPipeline delete
   */
  export type TestPipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
    /**
     * Filter which TestPipeline to delete.
     */
    where: TestPipelineWhereUniqueInput
  }

  /**
   * TestPipeline deleteMany
   */
  export type TestPipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestPipelines to delete
     */
    where?: TestPipelineWhereInput
  }

  /**
   * TestPipeline.stages
   */
  export type TestPipeline$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    where?: PipelineStageWhereInput
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    cursor?: PipelineStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * TestPipeline.executions
   */
  export type TestPipeline$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    where?: PipelineExecutionWhereInput
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    cursor?: PipelineExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * TestPipeline without action
   */
  export type TestPipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestPipeline
     */
    select?: TestPipelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestPipelineInclude<ExtArgs> | null
  }


  /**
   * Model PipelineStage
   */

  export type AggregatePipelineStage = {
    _count: PipelineStageCountAggregateOutputType | null
    _avg: PipelineStageAvgAggregateOutputType | null
    _sum: PipelineStageSumAggregateOutputType | null
    _min: PipelineStageMinAggregateOutputType | null
    _max: PipelineStageMaxAggregateOutputType | null
  }

  export type PipelineStageAvgAggregateOutputType = {
    order: number | null
  }

  export type PipelineStageSumAggregateOutputType = {
    order: number | null
  }

  export type PipelineStageMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    config: string | null
    order: number | null
    status: string | null
    result: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
  }

  export type PipelineStageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    config: string | null
    order: number | null
    status: string | null
    result: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
  }

  export type PipelineStageCountAggregateOutputType = {
    id: number
    name: number
    type: number
    config: number
    order: number
    status: number
    result: number
    createdAt: number
    updatedAt: number
    pipelineId: number
    _all: number
  }


  export type PipelineStageAvgAggregateInputType = {
    order?: true
  }

  export type PipelineStageSumAggregateInputType = {
    order?: true
  }

  export type PipelineStageMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    order?: true
    status?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
  }

  export type PipelineStageMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    order?: true
    status?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
  }

  export type PipelineStageCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    config?: true
    order?: true
    status?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    _all?: true
  }

  export type PipelineStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineStage to aggregate.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PipelineStages
    **/
    _count?: true | PipelineStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PipelineStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PipelineStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineStageMaxAggregateInputType
  }

  export type GetPipelineStageAggregateType<T extends PipelineStageAggregateArgs> = {
        [P in keyof T & keyof AggregatePipelineStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipelineStage[P]>
      : GetScalarType<T[P], AggregatePipelineStage[P]>
  }




  export type PipelineStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineStageWhereInput
    orderBy?: PipelineStageOrderByWithAggregationInput | PipelineStageOrderByWithAggregationInput[]
    by: PipelineStageScalarFieldEnum[] | PipelineStageScalarFieldEnum
    having?: PipelineStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineStageCountAggregateInputType | true
    _avg?: PipelineStageAvgAggregateInputType
    _sum?: PipelineStageSumAggregateInputType
    _min?: PipelineStageMinAggregateInputType
    _max?: PipelineStageMaxAggregateInputType
  }

  export type PipelineStageGroupByOutputType = {
    id: string
    name: string
    type: string
    config: string
    order: number
    status: string
    result: string | null
    createdAt: Date
    updatedAt: Date
    pipelineId: string
    _count: PipelineStageCountAggregateOutputType | null
    _avg: PipelineStageAvgAggregateOutputType | null
    _sum: PipelineStageSumAggregateOutputType | null
    _min: PipelineStageMinAggregateOutputType | null
    _max: PipelineStageMaxAggregateOutputType | null
  }

  type GetPipelineStageGroupByPayload<T extends PipelineStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineStageGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineStageGroupByOutputType[P]>
        }
      >
    >


  export type PipelineStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    order?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineStage"]>

  export type PipelineStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    order?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineStage"]>

  export type PipelineStageSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    config?: boolean
    order?: boolean
    status?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
  }

  export type PipelineStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
  }
  export type PipelineStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
  }

  export type $PipelineStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PipelineStage"
    objects: {
      pipeline: Prisma.$TestPipelinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      config: string
      order: number
      status: string
      result: string | null
      createdAt: Date
      updatedAt: Date
      pipelineId: string
    }, ExtArgs["result"]["pipelineStage"]>
    composites: {}
  }

  type PipelineStageGetPayload<S extends boolean | null | undefined | PipelineStageDefaultArgs> = $Result.GetResult<Prisma.$PipelineStagePayload, S>

  type PipelineStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PipelineStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PipelineStageCountAggregateInputType | true
    }

  export interface PipelineStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PipelineStage'], meta: { name: 'PipelineStage' } }
    /**
     * Find zero or one PipelineStage that matches the filter.
     * @param {PipelineStageFindUniqueArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineStageFindUniqueArgs>(args: SelectSubset<T, PipelineStageFindUniqueArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PipelineStage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PipelineStageFindUniqueOrThrowArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineStageFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PipelineStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageFindFirstArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineStageFindFirstArgs>(args?: SelectSubset<T, PipelineStageFindFirstArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PipelineStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageFindFirstOrThrowArgs} args - Arguments to find a PipelineStage
     * @example
     * // Get one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineStageFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PipelineStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PipelineStages
     * const pipelineStages = await prisma.pipelineStage.findMany()
     * 
     * // Get first 10 PipelineStages
     * const pipelineStages = await prisma.pipelineStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineStageWithIdOnly = await prisma.pipelineStage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineStageFindManyArgs>(args?: SelectSubset<T, PipelineStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PipelineStage.
     * @param {PipelineStageCreateArgs} args - Arguments to create a PipelineStage.
     * @example
     * // Create one PipelineStage
     * const PipelineStage = await prisma.pipelineStage.create({
     *   data: {
     *     // ... data to create a PipelineStage
     *   }
     * })
     * 
     */
    create<T extends PipelineStageCreateArgs>(args: SelectSubset<T, PipelineStageCreateArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PipelineStages.
     * @param {PipelineStageCreateManyArgs} args - Arguments to create many PipelineStages.
     * @example
     * // Create many PipelineStages
     * const pipelineStage = await prisma.pipelineStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineStageCreateManyArgs>(args?: SelectSubset<T, PipelineStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PipelineStages and returns the data saved in the database.
     * @param {PipelineStageCreateManyAndReturnArgs} args - Arguments to create many PipelineStages.
     * @example
     * // Create many PipelineStages
     * const pipelineStage = await prisma.pipelineStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PipelineStages and only return the `id`
     * const pipelineStageWithIdOnly = await prisma.pipelineStage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineStageCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PipelineStage.
     * @param {PipelineStageDeleteArgs} args - Arguments to delete one PipelineStage.
     * @example
     * // Delete one PipelineStage
     * const PipelineStage = await prisma.pipelineStage.delete({
     *   where: {
     *     // ... filter to delete one PipelineStage
     *   }
     * })
     * 
     */
    delete<T extends PipelineStageDeleteArgs>(args: SelectSubset<T, PipelineStageDeleteArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PipelineStage.
     * @param {PipelineStageUpdateArgs} args - Arguments to update one PipelineStage.
     * @example
     * // Update one PipelineStage
     * const pipelineStage = await prisma.pipelineStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineStageUpdateArgs>(args: SelectSubset<T, PipelineStageUpdateArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PipelineStages.
     * @param {PipelineStageDeleteManyArgs} args - Arguments to filter PipelineStages to delete.
     * @example
     * // Delete a few PipelineStages
     * const { count } = await prisma.pipelineStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineStageDeleteManyArgs>(args?: SelectSubset<T, PipelineStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PipelineStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PipelineStages
     * const pipelineStage = await prisma.pipelineStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineStageUpdateManyArgs>(args: SelectSubset<T, PipelineStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PipelineStage.
     * @param {PipelineStageUpsertArgs} args - Arguments to update or create a PipelineStage.
     * @example
     * // Update or create a PipelineStage
     * const pipelineStage = await prisma.pipelineStage.upsert({
     *   create: {
     *     // ... data to create a PipelineStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PipelineStage we want to update
     *   }
     * })
     */
    upsert<T extends PipelineStageUpsertArgs>(args: SelectSubset<T, PipelineStageUpsertArgs<ExtArgs>>): Prisma__PipelineStageClient<$Result.GetResult<Prisma.$PipelineStagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PipelineStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageCountArgs} args - Arguments to filter PipelineStages to count.
     * @example
     * // Count the number of PipelineStages
     * const count = await prisma.pipelineStage.count({
     *   where: {
     *     // ... the filter for the PipelineStages we want to count
     *   }
     * })
    **/
    count<T extends PipelineStageCountArgs>(
      args?: Subset<T, PipelineStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PipelineStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineStageAggregateArgs>(args: Subset<T, PipelineStageAggregateArgs>): Prisma.PrismaPromise<GetPipelineStageAggregateType<T>>

    /**
     * Group by PipelineStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineStageGroupByArgs['orderBy'] }
        : { orderBy?: PipelineStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PipelineStage model
   */
  readonly fields: PipelineStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PipelineStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pipeline<T extends TestPipelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestPipelineDefaultArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PipelineStage model
   */ 
  interface PipelineStageFieldRefs {
    readonly id: FieldRef<"PipelineStage", 'String'>
    readonly name: FieldRef<"PipelineStage", 'String'>
    readonly type: FieldRef<"PipelineStage", 'String'>
    readonly config: FieldRef<"PipelineStage", 'String'>
    readonly order: FieldRef<"PipelineStage", 'Int'>
    readonly status: FieldRef<"PipelineStage", 'String'>
    readonly result: FieldRef<"PipelineStage", 'String'>
    readonly createdAt: FieldRef<"PipelineStage", 'DateTime'>
    readonly updatedAt: FieldRef<"PipelineStage", 'DateTime'>
    readonly pipelineId: FieldRef<"PipelineStage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PipelineStage findUnique
   */
  export type PipelineStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage findUniqueOrThrow
   */
  export type PipelineStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage findFirst
   */
  export type PipelineStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineStages.
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineStages.
     */
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * PipelineStage findFirstOrThrow
   */
  export type PipelineStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStage to fetch.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineStages.
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineStages.
     */
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * PipelineStage findMany
   */
  export type PipelineStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter, which PipelineStages to fetch.
     */
    where?: PipelineStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineStages to fetch.
     */
    orderBy?: PipelineStageOrderByWithRelationInput | PipelineStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PipelineStages.
     */
    cursor?: PipelineStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineStages.
     */
    skip?: number
    distinct?: PipelineStageScalarFieldEnum | PipelineStageScalarFieldEnum[]
  }

  /**
   * PipelineStage create
   */
  export type PipelineStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * The data needed to create a PipelineStage.
     */
    data: XOR<PipelineStageCreateInput, PipelineStageUncheckedCreateInput>
  }

  /**
   * PipelineStage createMany
   */
  export type PipelineStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PipelineStages.
     */
    data: PipelineStageCreateManyInput | PipelineStageCreateManyInput[]
  }

  /**
   * PipelineStage createManyAndReturn
   */
  export type PipelineStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PipelineStages.
     */
    data: PipelineStageCreateManyInput | PipelineStageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PipelineStage update
   */
  export type PipelineStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * The data needed to update a PipelineStage.
     */
    data: XOR<PipelineStageUpdateInput, PipelineStageUncheckedUpdateInput>
    /**
     * Choose, which PipelineStage to update.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage updateMany
   */
  export type PipelineStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PipelineStages.
     */
    data: XOR<PipelineStageUpdateManyMutationInput, PipelineStageUncheckedUpdateManyInput>
    /**
     * Filter which PipelineStages to update
     */
    where?: PipelineStageWhereInput
  }

  /**
   * PipelineStage upsert
   */
  export type PipelineStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * The filter to search for the PipelineStage to update in case it exists.
     */
    where: PipelineStageWhereUniqueInput
    /**
     * In case the PipelineStage found by the `where` argument doesn't exist, create a new PipelineStage with this data.
     */
    create: XOR<PipelineStageCreateInput, PipelineStageUncheckedCreateInput>
    /**
     * In case the PipelineStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineStageUpdateInput, PipelineStageUncheckedUpdateInput>
  }

  /**
   * PipelineStage delete
   */
  export type PipelineStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
    /**
     * Filter which PipelineStage to delete.
     */
    where: PipelineStageWhereUniqueInput
  }

  /**
   * PipelineStage deleteMany
   */
  export type PipelineStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineStages to delete
     */
    where?: PipelineStageWhereInput
  }

  /**
   * PipelineStage without action
   */
  export type PipelineStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineStage
     */
    select?: PipelineStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineStageInclude<ExtArgs> | null
  }


  /**
   * Model PipelineExecution
   */

  export type AggregatePipelineExecution = {
    _count: PipelineExecutionCountAggregateOutputType | null
    _min: PipelineExecutionMinAggregateOutputType | null
    _max: PipelineExecutionMaxAggregateOutputType | null
  }

  export type PipelineExecutionMinAggregateOutputType = {
    id: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    result: string | null
    error: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
    promptId: string | null
    baselinePromptId: string | null
    executedBy: string | null
  }

  export type PipelineExecutionMaxAggregateOutputType = {
    id: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    result: string | null
    error: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
    promptId: string | null
    baselinePromptId: string | null
    executedBy: string | null
  }

  export type PipelineExecutionCountAggregateOutputType = {
    id: number
    status: number
    startedAt: number
    completedAt: number
    result: number
    error: number
    metadata: number
    createdAt: number
    updatedAt: number
    pipelineId: number
    promptId: number
    baselinePromptId: number
    executedBy: number
    _all: number
  }


  export type PipelineExecutionMinAggregateInputType = {
    id?: true
    status?: true
    startedAt?: true
    completedAt?: true
    result?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    promptId?: true
    baselinePromptId?: true
    executedBy?: true
  }

  export type PipelineExecutionMaxAggregateInputType = {
    id?: true
    status?: true
    startedAt?: true
    completedAt?: true
    result?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    promptId?: true
    baselinePromptId?: true
    executedBy?: true
  }

  export type PipelineExecutionCountAggregateInputType = {
    id?: true
    status?: true
    startedAt?: true
    completedAt?: true
    result?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    promptId?: true
    baselinePromptId?: true
    executedBy?: true
    _all?: true
  }

  export type PipelineExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineExecution to aggregate.
     */
    where?: PipelineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineExecutions to fetch.
     */
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PipelineExecutions
    **/
    _count?: true | PipelineExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineExecutionMaxAggregateInputType
  }

  export type GetPipelineExecutionAggregateType<T extends PipelineExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregatePipelineExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipelineExecution[P]>
      : GetScalarType<T[P], AggregatePipelineExecution[P]>
  }




  export type PipelineExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineExecutionWhereInput
    orderBy?: PipelineExecutionOrderByWithAggregationInput | PipelineExecutionOrderByWithAggregationInput[]
    by: PipelineExecutionScalarFieldEnum[] | PipelineExecutionScalarFieldEnum
    having?: PipelineExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineExecutionCountAggregateInputType | true
    _min?: PipelineExecutionMinAggregateInputType
    _max?: PipelineExecutionMaxAggregateInputType
  }

  export type PipelineExecutionGroupByOutputType = {
    id: string
    status: string
    startedAt: Date | null
    completedAt: Date | null
    result: string | null
    error: string | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    pipelineId: string
    promptId: string
    baselinePromptId: string | null
    executedBy: string
    _count: PipelineExecutionCountAggregateOutputType | null
    _min: PipelineExecutionMinAggregateOutputType | null
    _max: PipelineExecutionMaxAggregateOutputType | null
  }

  type GetPipelineExecutionGroupByPayload<T extends PipelineExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineExecutionGroupByOutputType[P]>
        }
      >
    >


  export type PipelineExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    promptId?: boolean
    baselinePromptId?: boolean
    executedBy?: boolean
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | PipelineExecution$baselinePromptArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineExecution"]>

  export type PipelineExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    promptId?: boolean
    baselinePromptId?: boolean
    executedBy?: boolean
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | PipelineExecution$baselinePromptArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelineExecution"]>

  export type PipelineExecutionSelectScalar = {
    id?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    result?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    promptId?: boolean
    baselinePromptId?: boolean
    executedBy?: boolean
  }

  export type PipelineExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | PipelineExecution$baselinePromptArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PipelineExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | TestPipelineDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    baselinePrompt?: boolean | PipelineExecution$baselinePromptArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PipelineExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PipelineExecution"
    objects: {
      pipeline: Prisma.$TestPipelinePayload<ExtArgs>
      prompt: Prisma.$PromptPayload<ExtArgs>
      baselinePrompt: Prisma.$PromptPayload<ExtArgs> | null
      executor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      startedAt: Date | null
      completedAt: Date | null
      result: string | null
      error: string | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
      pipelineId: string
      promptId: string
      baselinePromptId: string | null
      executedBy: string
    }, ExtArgs["result"]["pipelineExecution"]>
    composites: {}
  }

  type PipelineExecutionGetPayload<S extends boolean | null | undefined | PipelineExecutionDefaultArgs> = $Result.GetResult<Prisma.$PipelineExecutionPayload, S>

  type PipelineExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PipelineExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PipelineExecutionCountAggregateInputType | true
    }

  export interface PipelineExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PipelineExecution'], meta: { name: 'PipelineExecution' } }
    /**
     * Find zero or one PipelineExecution that matches the filter.
     * @param {PipelineExecutionFindUniqueArgs} args - Arguments to find a PipelineExecution
     * @example
     * // Get one PipelineExecution
     * const pipelineExecution = await prisma.pipelineExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineExecutionFindUniqueArgs>(args: SelectSubset<T, PipelineExecutionFindUniqueArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PipelineExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PipelineExecutionFindUniqueOrThrowArgs} args - Arguments to find a PipelineExecution
     * @example
     * // Get one PipelineExecution
     * const pipelineExecution = await prisma.pipelineExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PipelineExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionFindFirstArgs} args - Arguments to find a PipelineExecution
     * @example
     * // Get one PipelineExecution
     * const pipelineExecution = await prisma.pipelineExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineExecutionFindFirstArgs>(args?: SelectSubset<T, PipelineExecutionFindFirstArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PipelineExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionFindFirstOrThrowArgs} args - Arguments to find a PipelineExecution
     * @example
     * // Get one PipelineExecution
     * const pipelineExecution = await prisma.pipelineExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PipelineExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PipelineExecutions
     * const pipelineExecutions = await prisma.pipelineExecution.findMany()
     * 
     * // Get first 10 PipelineExecutions
     * const pipelineExecutions = await prisma.pipelineExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineExecutionWithIdOnly = await prisma.pipelineExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineExecutionFindManyArgs>(args?: SelectSubset<T, PipelineExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PipelineExecution.
     * @param {PipelineExecutionCreateArgs} args - Arguments to create a PipelineExecution.
     * @example
     * // Create one PipelineExecution
     * const PipelineExecution = await prisma.pipelineExecution.create({
     *   data: {
     *     // ... data to create a PipelineExecution
     *   }
     * })
     * 
     */
    create<T extends PipelineExecutionCreateArgs>(args: SelectSubset<T, PipelineExecutionCreateArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PipelineExecutions.
     * @param {PipelineExecutionCreateManyArgs} args - Arguments to create many PipelineExecutions.
     * @example
     * // Create many PipelineExecutions
     * const pipelineExecution = await prisma.pipelineExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineExecutionCreateManyArgs>(args?: SelectSubset<T, PipelineExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PipelineExecutions and returns the data saved in the database.
     * @param {PipelineExecutionCreateManyAndReturnArgs} args - Arguments to create many PipelineExecutions.
     * @example
     * // Create many PipelineExecutions
     * const pipelineExecution = await prisma.pipelineExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PipelineExecutions and only return the `id`
     * const pipelineExecutionWithIdOnly = await prisma.pipelineExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PipelineExecution.
     * @param {PipelineExecutionDeleteArgs} args - Arguments to delete one PipelineExecution.
     * @example
     * // Delete one PipelineExecution
     * const PipelineExecution = await prisma.pipelineExecution.delete({
     *   where: {
     *     // ... filter to delete one PipelineExecution
     *   }
     * })
     * 
     */
    delete<T extends PipelineExecutionDeleteArgs>(args: SelectSubset<T, PipelineExecutionDeleteArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PipelineExecution.
     * @param {PipelineExecutionUpdateArgs} args - Arguments to update one PipelineExecution.
     * @example
     * // Update one PipelineExecution
     * const pipelineExecution = await prisma.pipelineExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineExecutionUpdateArgs>(args: SelectSubset<T, PipelineExecutionUpdateArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PipelineExecutions.
     * @param {PipelineExecutionDeleteManyArgs} args - Arguments to filter PipelineExecutions to delete.
     * @example
     * // Delete a few PipelineExecutions
     * const { count } = await prisma.pipelineExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineExecutionDeleteManyArgs>(args?: SelectSubset<T, PipelineExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PipelineExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PipelineExecutions
     * const pipelineExecution = await prisma.pipelineExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineExecutionUpdateManyArgs>(args: SelectSubset<T, PipelineExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PipelineExecution.
     * @param {PipelineExecutionUpsertArgs} args - Arguments to update or create a PipelineExecution.
     * @example
     * // Update or create a PipelineExecution
     * const pipelineExecution = await prisma.pipelineExecution.upsert({
     *   create: {
     *     // ... data to create a PipelineExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PipelineExecution we want to update
     *   }
     * })
     */
    upsert<T extends PipelineExecutionUpsertArgs>(args: SelectSubset<T, PipelineExecutionUpsertArgs<ExtArgs>>): Prisma__PipelineExecutionClient<$Result.GetResult<Prisma.$PipelineExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PipelineExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionCountArgs} args - Arguments to filter PipelineExecutions to count.
     * @example
     * // Count the number of PipelineExecutions
     * const count = await prisma.pipelineExecution.count({
     *   where: {
     *     // ... the filter for the PipelineExecutions we want to count
     *   }
     * })
    **/
    count<T extends PipelineExecutionCountArgs>(
      args?: Subset<T, PipelineExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PipelineExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineExecutionAggregateArgs>(args: Subset<T, PipelineExecutionAggregateArgs>): Prisma.PrismaPromise<GetPipelineExecutionAggregateType<T>>

    /**
     * Group by PipelineExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineExecutionGroupByArgs['orderBy'] }
        : { orderBy?: PipelineExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PipelineExecution model
   */
  readonly fields: PipelineExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PipelineExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pipeline<T extends TestPipelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestPipelineDefaultArgs<ExtArgs>>): Prisma__TestPipelineClient<$Result.GetResult<Prisma.$TestPipelinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prompt<T extends PromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromptDefaultArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    baselinePrompt<T extends PipelineExecution$baselinePromptArgs<ExtArgs> = {}>(args?: Subset<T, PipelineExecution$baselinePromptArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    executor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PipelineExecution model
   */ 
  interface PipelineExecutionFieldRefs {
    readonly id: FieldRef<"PipelineExecution", 'String'>
    readonly status: FieldRef<"PipelineExecution", 'String'>
    readonly startedAt: FieldRef<"PipelineExecution", 'DateTime'>
    readonly completedAt: FieldRef<"PipelineExecution", 'DateTime'>
    readonly result: FieldRef<"PipelineExecution", 'String'>
    readonly error: FieldRef<"PipelineExecution", 'String'>
    readonly metadata: FieldRef<"PipelineExecution", 'String'>
    readonly createdAt: FieldRef<"PipelineExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"PipelineExecution", 'DateTime'>
    readonly pipelineId: FieldRef<"PipelineExecution", 'String'>
    readonly promptId: FieldRef<"PipelineExecution", 'String'>
    readonly baselinePromptId: FieldRef<"PipelineExecution", 'String'>
    readonly executedBy: FieldRef<"PipelineExecution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PipelineExecution findUnique
   */
  export type PipelineExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PipelineExecution to fetch.
     */
    where: PipelineExecutionWhereUniqueInput
  }

  /**
   * PipelineExecution findUniqueOrThrow
   */
  export type PipelineExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PipelineExecution to fetch.
     */
    where: PipelineExecutionWhereUniqueInput
  }

  /**
   * PipelineExecution findFirst
   */
  export type PipelineExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PipelineExecution to fetch.
     */
    where?: PipelineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineExecutions to fetch.
     */
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineExecutions.
     */
    cursor?: PipelineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineExecutions.
     */
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * PipelineExecution findFirstOrThrow
   */
  export type PipelineExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PipelineExecution to fetch.
     */
    where?: PipelineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineExecutions to fetch.
     */
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PipelineExecutions.
     */
    cursor?: PipelineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PipelineExecutions.
     */
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * PipelineExecution findMany
   */
  export type PipelineExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PipelineExecutions to fetch.
     */
    where?: PipelineExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PipelineExecutions to fetch.
     */
    orderBy?: PipelineExecutionOrderByWithRelationInput | PipelineExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PipelineExecutions.
     */
    cursor?: PipelineExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PipelineExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PipelineExecutions.
     */
    skip?: number
    distinct?: PipelineExecutionScalarFieldEnum | PipelineExecutionScalarFieldEnum[]
  }

  /**
   * PipelineExecution create
   */
  export type PipelineExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a PipelineExecution.
     */
    data: XOR<PipelineExecutionCreateInput, PipelineExecutionUncheckedCreateInput>
  }

  /**
   * PipelineExecution createMany
   */
  export type PipelineExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PipelineExecutions.
     */
    data: PipelineExecutionCreateManyInput | PipelineExecutionCreateManyInput[]
  }

  /**
   * PipelineExecution createManyAndReturn
   */
  export type PipelineExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PipelineExecutions.
     */
    data: PipelineExecutionCreateManyInput | PipelineExecutionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PipelineExecution update
   */
  export type PipelineExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a PipelineExecution.
     */
    data: XOR<PipelineExecutionUpdateInput, PipelineExecutionUncheckedUpdateInput>
    /**
     * Choose, which PipelineExecution to update.
     */
    where: PipelineExecutionWhereUniqueInput
  }

  /**
   * PipelineExecution updateMany
   */
  export type PipelineExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PipelineExecutions.
     */
    data: XOR<PipelineExecutionUpdateManyMutationInput, PipelineExecutionUncheckedUpdateManyInput>
    /**
     * Filter which PipelineExecutions to update
     */
    where?: PipelineExecutionWhereInput
  }

  /**
   * PipelineExecution upsert
   */
  export type PipelineExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the PipelineExecution to update in case it exists.
     */
    where: PipelineExecutionWhereUniqueInput
    /**
     * In case the PipelineExecution found by the `where` argument doesn't exist, create a new PipelineExecution with this data.
     */
    create: XOR<PipelineExecutionCreateInput, PipelineExecutionUncheckedCreateInput>
    /**
     * In case the PipelineExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineExecutionUpdateInput, PipelineExecutionUncheckedUpdateInput>
  }

  /**
   * PipelineExecution delete
   */
  export type PipelineExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
    /**
     * Filter which PipelineExecution to delete.
     */
    where: PipelineExecutionWhereUniqueInput
  }

  /**
   * PipelineExecution deleteMany
   */
  export type PipelineExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PipelineExecutions to delete
     */
    where?: PipelineExecutionWhereInput
  }

  /**
   * PipelineExecution.baselinePrompt
   */
  export type PipelineExecution$baselinePromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
  }

  /**
   * PipelineExecution without action
   */
  export type PipelineExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineExecution
     */
    select?: PipelineExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Dependency
   */

  export type AggregateDependency = {
    _count: DependencyCountAggregateOutputType | null
    _avg: DependencyAvgAggregateOutputType | null
    _sum: DependencySumAggregateOutputType | null
    _min: DependencyMinAggregateOutputType | null
    _max: DependencyMaxAggregateOutputType | null
  }

  export type DependencyAvgAggregateOutputType = {
    healthScore: number | null
  }

  export type DependencySumAggregateOutputType = {
    healthScore: number | null
  }

  export type DependencyMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    provider: string | null
    config: string | null
    status: string | null
    version: string | null
    healthScore: number | null
    lastCheck: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type DependencyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    provider: string | null
    config: string | null
    status: string | null
    version: string | null
    healthScore: number | null
    lastCheck: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
  }

  export type DependencyCountAggregateOutputType = {
    id: number
    name: number
    type: number
    provider: number
    config: number
    status: number
    version: number
    healthScore: number
    lastCheck: number
    createdAt: number
    updatedAt: number
    projectId: number
    createdBy: number
    _all: number
  }


  export type DependencyAvgAggregateInputType = {
    healthScore?: true
  }

  export type DependencySumAggregateInputType = {
    healthScore?: true
  }

  export type DependencyMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    provider?: true
    config?: true
    status?: true
    version?: true
    healthScore?: true
    lastCheck?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type DependencyMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    provider?: true
    config?: true
    status?: true
    version?: true
    healthScore?: true
    lastCheck?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
  }

  export type DependencyCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    provider?: true
    config?: true
    status?: true
    version?: true
    healthScore?: true
    lastCheck?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    _all?: true
  }

  export type DependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependency to aggregate.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dependencies
    **/
    _count?: true | DependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DependencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DependencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DependencyMaxAggregateInputType
  }

  export type GetDependencyAggregateType<T extends DependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependency[P]>
      : GetScalarType<T[P], AggregateDependency[P]>
  }




  export type DependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithAggregationInput | DependencyOrderByWithAggregationInput[]
    by: DependencyScalarFieldEnum[] | DependencyScalarFieldEnum
    having?: DependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DependencyCountAggregateInputType | true
    _avg?: DependencyAvgAggregateInputType
    _sum?: DependencySumAggregateInputType
    _min?: DependencyMinAggregateInputType
    _max?: DependencyMaxAggregateInputType
  }

  export type DependencyGroupByOutputType = {
    id: string
    name: string
    type: string
    provider: string
    config: string
    status: string
    version: string | null
    healthScore: number
    lastCheck: Date
    createdAt: Date
    updatedAt: Date
    projectId: string
    createdBy: string
    _count: DependencyCountAggregateOutputType | null
    _avg: DependencyAvgAggregateOutputType | null
    _sum: DependencySumAggregateOutputType | null
    _min: DependencyMinAggregateOutputType | null
    _max: DependencyMaxAggregateOutputType | null
  }

  type GetDependencyGroupByPayload<T extends DependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DependencyGroupByOutputType[P]>
            : GetScalarType<T[P], DependencyGroupByOutputType[P]>
        }
      >
    >


  export type DependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    config?: boolean
    status?: boolean
    version?: boolean
    healthScore?: boolean
    lastCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    config?: boolean
    status?: boolean
    version?: boolean
    healthScore?: boolean
    lastCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    provider?: boolean
    config?: boolean
    status?: boolean
    version?: boolean
    healthScore?: boolean
    lastCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
  }

  export type DependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DependencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dependency"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      provider: string
      config: string
      status: string
      version: string | null
      healthScore: number
      lastCheck: Date
      createdAt: Date
      updatedAt: Date
      projectId: string
      createdBy: string
    }, ExtArgs["result"]["dependency"]>
    composites: {}
  }

  type DependencyGetPayload<S extends boolean | null | undefined | DependencyDefaultArgs> = $Result.GetResult<Prisma.$DependencyPayload, S>

  type DependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DependencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DependencyCountAggregateInputType | true
    }

  export interface DependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dependency'], meta: { name: 'Dependency' } }
    /**
     * Find zero or one Dependency that matches the filter.
     * @param {DependencyFindUniqueArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DependencyFindUniqueArgs>(args: SelectSubset<T, DependencyFindUniqueArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dependency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DependencyFindUniqueOrThrowArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, DependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindFirstArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DependencyFindFirstArgs>(args?: SelectSubset<T, DependencyFindFirstArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindFirstOrThrowArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, DependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dependencies
     * const dependencies = await prisma.dependency.findMany()
     * 
     * // Get first 10 Dependencies
     * const dependencies = await prisma.dependency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dependencyWithIdOnly = await prisma.dependency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DependencyFindManyArgs>(args?: SelectSubset<T, DependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dependency.
     * @param {DependencyCreateArgs} args - Arguments to create a Dependency.
     * @example
     * // Create one Dependency
     * const Dependency = await prisma.dependency.create({
     *   data: {
     *     // ... data to create a Dependency
     *   }
     * })
     * 
     */
    create<T extends DependencyCreateArgs>(args: SelectSubset<T, DependencyCreateArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dependencies.
     * @param {DependencyCreateManyArgs} args - Arguments to create many Dependencies.
     * @example
     * // Create many Dependencies
     * const dependency = await prisma.dependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DependencyCreateManyArgs>(args?: SelectSubset<T, DependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dependencies and returns the data saved in the database.
     * @param {DependencyCreateManyAndReturnArgs} args - Arguments to create many Dependencies.
     * @example
     * // Create many Dependencies
     * const dependency = await prisma.dependency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dependencies and only return the `id`
     * const dependencyWithIdOnly = await prisma.dependency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DependencyCreateManyAndReturnArgs>(args?: SelectSubset<T, DependencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dependency.
     * @param {DependencyDeleteArgs} args - Arguments to delete one Dependency.
     * @example
     * // Delete one Dependency
     * const Dependency = await prisma.dependency.delete({
     *   where: {
     *     // ... filter to delete one Dependency
     *   }
     * })
     * 
     */
    delete<T extends DependencyDeleteArgs>(args: SelectSubset<T, DependencyDeleteArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dependency.
     * @param {DependencyUpdateArgs} args - Arguments to update one Dependency.
     * @example
     * // Update one Dependency
     * const dependency = await prisma.dependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DependencyUpdateArgs>(args: SelectSubset<T, DependencyUpdateArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dependencies.
     * @param {DependencyDeleteManyArgs} args - Arguments to filter Dependencies to delete.
     * @example
     * // Delete a few Dependencies
     * const { count } = await prisma.dependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DependencyDeleteManyArgs>(args?: SelectSubset<T, DependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dependencies
     * const dependency = await prisma.dependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DependencyUpdateManyArgs>(args: SelectSubset<T, DependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dependency.
     * @param {DependencyUpsertArgs} args - Arguments to update or create a Dependency.
     * @example
     * // Update or create a Dependency
     * const dependency = await prisma.dependency.upsert({
     *   create: {
     *     // ... data to create a Dependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dependency we want to update
     *   }
     * })
     */
    upsert<T extends DependencyUpsertArgs>(args: SelectSubset<T, DependencyUpsertArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyCountArgs} args - Arguments to filter Dependencies to count.
     * @example
     * // Count the number of Dependencies
     * const count = await prisma.dependency.count({
     *   where: {
     *     // ... the filter for the Dependencies we want to count
     *   }
     * })
    **/
    count<T extends DependencyCountArgs>(
      args?: Subset<T, DependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DependencyAggregateArgs>(args: Subset<T, DependencyAggregateArgs>): Prisma.PrismaPromise<GetDependencyAggregateType<T>>

    /**
     * Group by Dependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependencyGroupByArgs['orderBy'] }
        : { orderBy?: DependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dependency model
   */
  readonly fields: DependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dependency model
   */ 
  interface DependencyFieldRefs {
    readonly id: FieldRef<"Dependency", 'String'>
    readonly name: FieldRef<"Dependency", 'String'>
    readonly type: FieldRef<"Dependency", 'String'>
    readonly provider: FieldRef<"Dependency", 'String'>
    readonly config: FieldRef<"Dependency", 'String'>
    readonly status: FieldRef<"Dependency", 'String'>
    readonly version: FieldRef<"Dependency", 'String'>
    readonly healthScore: FieldRef<"Dependency", 'Int'>
    readonly lastCheck: FieldRef<"Dependency", 'DateTime'>
    readonly createdAt: FieldRef<"Dependency", 'DateTime'>
    readonly updatedAt: FieldRef<"Dependency", 'DateTime'>
    readonly projectId: FieldRef<"Dependency", 'String'>
    readonly createdBy: FieldRef<"Dependency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dependency findUnique
   */
  export type DependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency findUniqueOrThrow
   */
  export type DependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency findFirst
   */
  export type DependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependencies.
     */
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency findFirstOrThrow
   */
  export type DependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependencies.
     */
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency findMany
   */
  export type DependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependencies to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency create
   */
  export type DependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Dependency.
     */
    data: XOR<DependencyCreateInput, DependencyUncheckedCreateInput>
  }

  /**
   * Dependency createMany
   */
  export type DependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dependencies.
     */
    data: DependencyCreateManyInput | DependencyCreateManyInput[]
  }

  /**
   * Dependency createManyAndReturn
   */
  export type DependencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Dependencies.
     */
    data: DependencyCreateManyInput | DependencyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dependency update
   */
  export type DependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Dependency.
     */
    data: XOR<DependencyUpdateInput, DependencyUncheckedUpdateInput>
    /**
     * Choose, which Dependency to update.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency updateMany
   */
  export type DependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dependencies.
     */
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyInput>
    /**
     * Filter which Dependencies to update
     */
    where?: DependencyWhereInput
  }

  /**
   * Dependency upsert
   */
  export type DependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Dependency to update in case it exists.
     */
    where: DependencyWhereUniqueInput
    /**
     * In case the Dependency found by the `where` argument doesn't exist, create a new Dependency with this data.
     */
    create: XOR<DependencyCreateInput, DependencyUncheckedCreateInput>
    /**
     * In case the Dependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependencyUpdateInput, DependencyUncheckedUpdateInput>
  }

  /**
   * Dependency delete
   */
  export type DependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter which Dependency to delete.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency deleteMany
   */
  export type DependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependencies to delete
     */
    where?: DependencyWhereInput
  }

  /**
   * Dependency without action
   */
  export type DependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
  }


  /**
   * Model UpdatePlan
   */

  export type AggregateUpdatePlan = {
    _count: UpdatePlanCountAggregateOutputType | null
    _min: UpdatePlanMinAggregateOutputType | null
    _max: UpdatePlanMaxAggregateOutputType | null
  }

  export type UpdatePlanMinAggregateOutputType = {
    id: string | null
    planData: string | null
    status: string | null
    executionResult: string | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
    executedBy: string | null
  }

  export type UpdatePlanMaxAggregateOutputType = {
    id: string | null
    planData: string | null
    status: string | null
    executionResult: string | null
    executedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    createdBy: string | null
    executedBy: string | null
  }

  export type UpdatePlanCountAggregateOutputType = {
    id: number
    planData: number
    status: number
    executionResult: number
    executedAt: number
    createdAt: number
    updatedAt: number
    projectId: number
    createdBy: number
    executedBy: number
    _all: number
  }


  export type UpdatePlanMinAggregateInputType = {
    id?: true
    planData?: true
    status?: true
    executionResult?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    executedBy?: true
  }

  export type UpdatePlanMaxAggregateInputType = {
    id?: true
    planData?: true
    status?: true
    executionResult?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    executedBy?: true
  }

  export type UpdatePlanCountAggregateInputType = {
    id?: true
    planData?: true
    status?: true
    executionResult?: true
    executedAt?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    createdBy?: true
    executedBy?: true
    _all?: true
  }

  export type UpdatePlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpdatePlan to aggregate.
     */
    where?: UpdatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdatePlans to fetch.
     */
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpdatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdatePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UpdatePlans
    **/
    _count?: true | UpdatePlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpdatePlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpdatePlanMaxAggregateInputType
  }

  export type GetUpdatePlanAggregateType<T extends UpdatePlanAggregateArgs> = {
        [P in keyof T & keyof AggregateUpdatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpdatePlan[P]>
      : GetScalarType<T[P], AggregateUpdatePlan[P]>
  }




  export type UpdatePlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdatePlanWhereInput
    orderBy?: UpdatePlanOrderByWithAggregationInput | UpdatePlanOrderByWithAggregationInput[]
    by: UpdatePlanScalarFieldEnum[] | UpdatePlanScalarFieldEnum
    having?: UpdatePlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpdatePlanCountAggregateInputType | true
    _min?: UpdatePlanMinAggregateInputType
    _max?: UpdatePlanMaxAggregateInputType
  }

  export type UpdatePlanGroupByOutputType = {
    id: string
    planData: string
    status: string
    executionResult: string | null
    executedAt: Date | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    createdBy: string
    executedBy: string | null
    _count: UpdatePlanCountAggregateOutputType | null
    _min: UpdatePlanMinAggregateOutputType | null
    _max: UpdatePlanMaxAggregateOutputType | null
  }

  type GetUpdatePlanGroupByPayload<T extends UpdatePlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpdatePlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpdatePlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpdatePlanGroupByOutputType[P]>
            : GetScalarType<T[P], UpdatePlanGroupByOutputType[P]>
        }
      >
    >


  export type UpdatePlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planData?: boolean
    status?: boolean
    executionResult?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    executedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executor?: boolean | UpdatePlan$executorArgs<ExtArgs>
  }, ExtArgs["result"]["updatePlan"]>

  export type UpdatePlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planData?: boolean
    status?: boolean
    executionResult?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    executedBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executor?: boolean | UpdatePlan$executorArgs<ExtArgs>
  }, ExtArgs["result"]["updatePlan"]>

  export type UpdatePlanSelectScalar = {
    id?: boolean
    planData?: boolean
    status?: boolean
    executionResult?: boolean
    executedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    createdBy?: boolean
    executedBy?: boolean
  }

  export type UpdatePlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executor?: boolean | UpdatePlan$executorArgs<ExtArgs>
  }
  export type UpdatePlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executor?: boolean | UpdatePlan$executorArgs<ExtArgs>
  }

  export type $UpdatePlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UpdatePlan"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      executor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planData: string
      status: string
      executionResult: string | null
      executedAt: Date | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      createdBy: string
      executedBy: string | null
    }, ExtArgs["result"]["updatePlan"]>
    composites: {}
  }

  type UpdatePlanGetPayload<S extends boolean | null | undefined | UpdatePlanDefaultArgs> = $Result.GetResult<Prisma.$UpdatePlanPayload, S>

  type UpdatePlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UpdatePlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UpdatePlanCountAggregateInputType | true
    }

  export interface UpdatePlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UpdatePlan'], meta: { name: 'UpdatePlan' } }
    /**
     * Find zero or one UpdatePlan that matches the filter.
     * @param {UpdatePlanFindUniqueArgs} args - Arguments to find a UpdatePlan
     * @example
     * // Get one UpdatePlan
     * const updatePlan = await prisma.updatePlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpdatePlanFindUniqueArgs>(args: SelectSubset<T, UpdatePlanFindUniqueArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UpdatePlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UpdatePlanFindUniqueOrThrowArgs} args - Arguments to find a UpdatePlan
     * @example
     * // Get one UpdatePlan
     * const updatePlan = await prisma.updatePlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpdatePlanFindUniqueOrThrowArgs>(args: SelectSubset<T, UpdatePlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UpdatePlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanFindFirstArgs} args - Arguments to find a UpdatePlan
     * @example
     * // Get one UpdatePlan
     * const updatePlan = await prisma.updatePlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpdatePlanFindFirstArgs>(args?: SelectSubset<T, UpdatePlanFindFirstArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UpdatePlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanFindFirstOrThrowArgs} args - Arguments to find a UpdatePlan
     * @example
     * // Get one UpdatePlan
     * const updatePlan = await prisma.updatePlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpdatePlanFindFirstOrThrowArgs>(args?: SelectSubset<T, UpdatePlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UpdatePlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UpdatePlans
     * const updatePlans = await prisma.updatePlan.findMany()
     * 
     * // Get first 10 UpdatePlans
     * const updatePlans = await prisma.updatePlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const updatePlanWithIdOnly = await prisma.updatePlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UpdatePlanFindManyArgs>(args?: SelectSubset<T, UpdatePlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UpdatePlan.
     * @param {UpdatePlanCreateArgs} args - Arguments to create a UpdatePlan.
     * @example
     * // Create one UpdatePlan
     * const UpdatePlan = await prisma.updatePlan.create({
     *   data: {
     *     // ... data to create a UpdatePlan
     *   }
     * })
     * 
     */
    create<T extends UpdatePlanCreateArgs>(args: SelectSubset<T, UpdatePlanCreateArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UpdatePlans.
     * @param {UpdatePlanCreateManyArgs} args - Arguments to create many UpdatePlans.
     * @example
     * // Create many UpdatePlans
     * const updatePlan = await prisma.updatePlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpdatePlanCreateManyArgs>(args?: SelectSubset<T, UpdatePlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UpdatePlans and returns the data saved in the database.
     * @param {UpdatePlanCreateManyAndReturnArgs} args - Arguments to create many UpdatePlans.
     * @example
     * // Create many UpdatePlans
     * const updatePlan = await prisma.updatePlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UpdatePlans and only return the `id`
     * const updatePlanWithIdOnly = await prisma.updatePlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UpdatePlanCreateManyAndReturnArgs>(args?: SelectSubset<T, UpdatePlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UpdatePlan.
     * @param {UpdatePlanDeleteArgs} args - Arguments to delete one UpdatePlan.
     * @example
     * // Delete one UpdatePlan
     * const UpdatePlan = await prisma.updatePlan.delete({
     *   where: {
     *     // ... filter to delete one UpdatePlan
     *   }
     * })
     * 
     */
    delete<T extends UpdatePlanDeleteArgs>(args: SelectSubset<T, UpdatePlanDeleteArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UpdatePlan.
     * @param {UpdatePlanUpdateArgs} args - Arguments to update one UpdatePlan.
     * @example
     * // Update one UpdatePlan
     * const updatePlan = await prisma.updatePlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpdatePlanUpdateArgs>(args: SelectSubset<T, UpdatePlanUpdateArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UpdatePlans.
     * @param {UpdatePlanDeleteManyArgs} args - Arguments to filter UpdatePlans to delete.
     * @example
     * // Delete a few UpdatePlans
     * const { count } = await prisma.updatePlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpdatePlanDeleteManyArgs>(args?: SelectSubset<T, UpdatePlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpdatePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UpdatePlans
     * const updatePlan = await prisma.updatePlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpdatePlanUpdateManyArgs>(args: SelectSubset<T, UpdatePlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UpdatePlan.
     * @param {UpdatePlanUpsertArgs} args - Arguments to update or create a UpdatePlan.
     * @example
     * // Update or create a UpdatePlan
     * const updatePlan = await prisma.updatePlan.upsert({
     *   create: {
     *     // ... data to create a UpdatePlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UpdatePlan we want to update
     *   }
     * })
     */
    upsert<T extends UpdatePlanUpsertArgs>(args: SelectSubset<T, UpdatePlanUpsertArgs<ExtArgs>>): Prisma__UpdatePlanClient<$Result.GetResult<Prisma.$UpdatePlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UpdatePlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanCountArgs} args - Arguments to filter UpdatePlans to count.
     * @example
     * // Count the number of UpdatePlans
     * const count = await prisma.updatePlan.count({
     *   where: {
     *     // ... the filter for the UpdatePlans we want to count
     *   }
     * })
    **/
    count<T extends UpdatePlanCountArgs>(
      args?: Subset<T, UpdatePlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpdatePlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UpdatePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpdatePlanAggregateArgs>(args: Subset<T, UpdatePlanAggregateArgs>): Prisma.PrismaPromise<GetUpdatePlanAggregateType<T>>

    /**
     * Group by UpdatePlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdatePlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpdatePlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpdatePlanGroupByArgs['orderBy'] }
        : { orderBy?: UpdatePlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpdatePlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpdatePlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UpdatePlan model
   */
  readonly fields: UpdatePlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UpdatePlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpdatePlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executor<T extends UpdatePlan$executorArgs<ExtArgs> = {}>(args?: Subset<T, UpdatePlan$executorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UpdatePlan model
   */ 
  interface UpdatePlanFieldRefs {
    readonly id: FieldRef<"UpdatePlan", 'String'>
    readonly planData: FieldRef<"UpdatePlan", 'String'>
    readonly status: FieldRef<"UpdatePlan", 'String'>
    readonly executionResult: FieldRef<"UpdatePlan", 'String'>
    readonly executedAt: FieldRef<"UpdatePlan", 'DateTime'>
    readonly createdAt: FieldRef<"UpdatePlan", 'DateTime'>
    readonly updatedAt: FieldRef<"UpdatePlan", 'DateTime'>
    readonly projectId: FieldRef<"UpdatePlan", 'String'>
    readonly createdBy: FieldRef<"UpdatePlan", 'String'>
    readonly executedBy: FieldRef<"UpdatePlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UpdatePlan findUnique
   */
  export type UpdatePlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * Filter, which UpdatePlan to fetch.
     */
    where: UpdatePlanWhereUniqueInput
  }

  /**
   * UpdatePlan findUniqueOrThrow
   */
  export type UpdatePlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * Filter, which UpdatePlan to fetch.
     */
    where: UpdatePlanWhereUniqueInput
  }

  /**
   * UpdatePlan findFirst
   */
  export type UpdatePlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * Filter, which UpdatePlan to fetch.
     */
    where?: UpdatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdatePlans to fetch.
     */
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpdatePlans.
     */
    cursor?: UpdatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdatePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpdatePlans.
     */
    distinct?: UpdatePlanScalarFieldEnum | UpdatePlanScalarFieldEnum[]
  }

  /**
   * UpdatePlan findFirstOrThrow
   */
  export type UpdatePlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * Filter, which UpdatePlan to fetch.
     */
    where?: UpdatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdatePlans to fetch.
     */
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpdatePlans.
     */
    cursor?: UpdatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdatePlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpdatePlans.
     */
    distinct?: UpdatePlanScalarFieldEnum | UpdatePlanScalarFieldEnum[]
  }

  /**
   * UpdatePlan findMany
   */
  export type UpdatePlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * Filter, which UpdatePlans to fetch.
     */
    where?: UpdatePlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdatePlans to fetch.
     */
    orderBy?: UpdatePlanOrderByWithRelationInput | UpdatePlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UpdatePlans.
     */
    cursor?: UpdatePlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdatePlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdatePlans.
     */
    skip?: number
    distinct?: UpdatePlanScalarFieldEnum | UpdatePlanScalarFieldEnum[]
  }

  /**
   * UpdatePlan create
   */
  export type UpdatePlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * The data needed to create a UpdatePlan.
     */
    data: XOR<UpdatePlanCreateInput, UpdatePlanUncheckedCreateInput>
  }

  /**
   * UpdatePlan createMany
   */
  export type UpdatePlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UpdatePlans.
     */
    data: UpdatePlanCreateManyInput | UpdatePlanCreateManyInput[]
  }

  /**
   * UpdatePlan createManyAndReturn
   */
  export type UpdatePlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UpdatePlans.
     */
    data: UpdatePlanCreateManyInput | UpdatePlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UpdatePlan update
   */
  export type UpdatePlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * The data needed to update a UpdatePlan.
     */
    data: XOR<UpdatePlanUpdateInput, UpdatePlanUncheckedUpdateInput>
    /**
     * Choose, which UpdatePlan to update.
     */
    where: UpdatePlanWhereUniqueInput
  }

  /**
   * UpdatePlan updateMany
   */
  export type UpdatePlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UpdatePlans.
     */
    data: XOR<UpdatePlanUpdateManyMutationInput, UpdatePlanUncheckedUpdateManyInput>
    /**
     * Filter which UpdatePlans to update
     */
    where?: UpdatePlanWhereInput
  }

  /**
   * UpdatePlan upsert
   */
  export type UpdatePlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * The filter to search for the UpdatePlan to update in case it exists.
     */
    where: UpdatePlanWhereUniqueInput
    /**
     * In case the UpdatePlan found by the `where` argument doesn't exist, create a new UpdatePlan with this data.
     */
    create: XOR<UpdatePlanCreateInput, UpdatePlanUncheckedCreateInput>
    /**
     * In case the UpdatePlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpdatePlanUpdateInput, UpdatePlanUncheckedUpdateInput>
  }

  /**
   * UpdatePlan delete
   */
  export type UpdatePlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
    /**
     * Filter which UpdatePlan to delete.
     */
    where: UpdatePlanWhereUniqueInput
  }

  /**
   * UpdatePlan deleteMany
   */
  export type UpdatePlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpdatePlans to delete
     */
    where?: UpdatePlanWhereInput
  }

  /**
   * UpdatePlan.executor
   */
  export type UpdatePlan$executorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UpdatePlan without action
   */
  export type UpdatePlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdatePlan
     */
    select?: UpdatePlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdatePlanInclude<ExtArgs> | null
  }


  /**
   * Model DeploymentPlan
   */

  export type AggregateDeploymentPlan = {
    _count: DeploymentPlanCountAggregateOutputType | null
    _min: DeploymentPlanMinAggregateOutputType | null
    _max: DeploymentPlanMaxAggregateOutputType | null
  }

  export type DeploymentPlanMinAggregateOutputType = {
    id: string | null
    planData: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    promptId: string | null
    createdBy: string | null
  }

  export type DeploymentPlanMaxAggregateOutputType = {
    id: string | null
    planData: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    promptId: string | null
    createdBy: string | null
  }

  export type DeploymentPlanCountAggregateOutputType = {
    id: number
    planData: number
    status: number
    createdAt: number
    updatedAt: number
    projectId: number
    promptId: number
    createdBy: number
    _all: number
  }


  export type DeploymentPlanMinAggregateInputType = {
    id?: true
    planData?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    promptId?: true
    createdBy?: true
  }

  export type DeploymentPlanMaxAggregateInputType = {
    id?: true
    planData?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    promptId?: true
    createdBy?: true
  }

  export type DeploymentPlanCountAggregateInputType = {
    id?: true
    planData?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    promptId?: true
    createdBy?: true
    _all?: true
  }

  export type DeploymentPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentPlan to aggregate.
     */
    where?: DeploymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentPlans to fetch.
     */
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeploymentPlans
    **/
    _count?: true | DeploymentPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentPlanMaxAggregateInputType
  }

  export type GetDeploymentPlanAggregateType<T extends DeploymentPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateDeploymentPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeploymentPlan[P]>
      : GetScalarType<T[P], AggregateDeploymentPlan[P]>
  }




  export type DeploymentPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentPlanWhereInput
    orderBy?: DeploymentPlanOrderByWithAggregationInput | DeploymentPlanOrderByWithAggregationInput[]
    by: DeploymentPlanScalarFieldEnum[] | DeploymentPlanScalarFieldEnum
    having?: DeploymentPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentPlanCountAggregateInputType | true
    _min?: DeploymentPlanMinAggregateInputType
    _max?: DeploymentPlanMaxAggregateInputType
  }

  export type DeploymentPlanGroupByOutputType = {
    id: string
    planData: string
    status: string
    createdAt: Date
    updatedAt: Date
    projectId: string
    promptId: string
    createdBy: string
    _count: DeploymentPlanCountAggregateOutputType | null
    _min: DeploymentPlanMinAggregateOutputType | null
    _max: DeploymentPlanMaxAggregateOutputType | null
  }

  type GetDeploymentPlanGroupByPayload<T extends DeploymentPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentPlanGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentPlanGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planData?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    promptId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | DeploymentPlan$executionsArgs<ExtArgs>
    approvals?: boolean | DeploymentPlan$approvalsArgs<ExtArgs>
    _count?: boolean | DeploymentPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentPlan"]>

  export type DeploymentPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planData?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    promptId?: boolean
    createdBy?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentPlan"]>

  export type DeploymentPlanSelectScalar = {
    id?: boolean
    planData?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    promptId?: boolean
    createdBy?: boolean
  }

  export type DeploymentPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | DeploymentPlan$executionsArgs<ExtArgs>
    approvals?: boolean | DeploymentPlan$approvalsArgs<ExtArgs>
    _count?: boolean | DeploymentPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeploymentPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeploymentPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeploymentPlan"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      prompt: Prisma.$PromptPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$DeploymentExecutionPayload<ExtArgs>[]
      approvals: Prisma.$DeploymentApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planData: string
      status: string
      createdAt: Date
      updatedAt: Date
      projectId: string
      promptId: string
      createdBy: string
    }, ExtArgs["result"]["deploymentPlan"]>
    composites: {}
  }

  type DeploymentPlanGetPayload<S extends boolean | null | undefined | DeploymentPlanDefaultArgs> = $Result.GetResult<Prisma.$DeploymentPlanPayload, S>

  type DeploymentPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentPlanCountAggregateInputType | true
    }

  export interface DeploymentPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeploymentPlan'], meta: { name: 'DeploymentPlan' } }
    /**
     * Find zero or one DeploymentPlan that matches the filter.
     * @param {DeploymentPlanFindUniqueArgs} args - Arguments to find a DeploymentPlan
     * @example
     * // Get one DeploymentPlan
     * const deploymentPlan = await prisma.deploymentPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentPlanFindUniqueArgs>(args: SelectSubset<T, DeploymentPlanFindUniqueArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeploymentPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentPlanFindUniqueOrThrowArgs} args - Arguments to find a DeploymentPlan
     * @example
     * // Get one DeploymentPlan
     * const deploymentPlan = await prisma.deploymentPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeploymentPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanFindFirstArgs} args - Arguments to find a DeploymentPlan
     * @example
     * // Get one DeploymentPlan
     * const deploymentPlan = await prisma.deploymentPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentPlanFindFirstArgs>(args?: SelectSubset<T, DeploymentPlanFindFirstArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeploymentPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanFindFirstOrThrowArgs} args - Arguments to find a DeploymentPlan
     * @example
     * // Get one DeploymentPlan
     * const deploymentPlan = await prisma.deploymentPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeploymentPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeploymentPlans
     * const deploymentPlans = await prisma.deploymentPlan.findMany()
     * 
     * // Get first 10 DeploymentPlans
     * const deploymentPlans = await prisma.deploymentPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentPlanWithIdOnly = await prisma.deploymentPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentPlanFindManyArgs>(args?: SelectSubset<T, DeploymentPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeploymentPlan.
     * @param {DeploymentPlanCreateArgs} args - Arguments to create a DeploymentPlan.
     * @example
     * // Create one DeploymentPlan
     * const DeploymentPlan = await prisma.deploymentPlan.create({
     *   data: {
     *     // ... data to create a DeploymentPlan
     *   }
     * })
     * 
     */
    create<T extends DeploymentPlanCreateArgs>(args: SelectSubset<T, DeploymentPlanCreateArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeploymentPlans.
     * @param {DeploymentPlanCreateManyArgs} args - Arguments to create many DeploymentPlans.
     * @example
     * // Create many DeploymentPlans
     * const deploymentPlan = await prisma.deploymentPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentPlanCreateManyArgs>(args?: SelectSubset<T, DeploymentPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeploymentPlans and returns the data saved in the database.
     * @param {DeploymentPlanCreateManyAndReturnArgs} args - Arguments to create many DeploymentPlans.
     * @example
     * // Create many DeploymentPlans
     * const deploymentPlan = await prisma.deploymentPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeploymentPlans and only return the `id`
     * const deploymentPlanWithIdOnly = await prisma.deploymentPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeploymentPlan.
     * @param {DeploymentPlanDeleteArgs} args - Arguments to delete one DeploymentPlan.
     * @example
     * // Delete one DeploymentPlan
     * const DeploymentPlan = await prisma.deploymentPlan.delete({
     *   where: {
     *     // ... filter to delete one DeploymentPlan
     *   }
     * })
     * 
     */
    delete<T extends DeploymentPlanDeleteArgs>(args: SelectSubset<T, DeploymentPlanDeleteArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeploymentPlan.
     * @param {DeploymentPlanUpdateArgs} args - Arguments to update one DeploymentPlan.
     * @example
     * // Update one DeploymentPlan
     * const deploymentPlan = await prisma.deploymentPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentPlanUpdateArgs>(args: SelectSubset<T, DeploymentPlanUpdateArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeploymentPlans.
     * @param {DeploymentPlanDeleteManyArgs} args - Arguments to filter DeploymentPlans to delete.
     * @example
     * // Delete a few DeploymentPlans
     * const { count } = await prisma.deploymentPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentPlanDeleteManyArgs>(args?: SelectSubset<T, DeploymentPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeploymentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeploymentPlans
     * const deploymentPlan = await prisma.deploymentPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentPlanUpdateManyArgs>(args: SelectSubset<T, DeploymentPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeploymentPlan.
     * @param {DeploymentPlanUpsertArgs} args - Arguments to update or create a DeploymentPlan.
     * @example
     * // Update or create a DeploymentPlan
     * const deploymentPlan = await prisma.deploymentPlan.upsert({
     *   create: {
     *     // ... data to create a DeploymentPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeploymentPlan we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentPlanUpsertArgs>(args: SelectSubset<T, DeploymentPlanUpsertArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeploymentPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanCountArgs} args - Arguments to filter DeploymentPlans to count.
     * @example
     * // Count the number of DeploymentPlans
     * const count = await prisma.deploymentPlan.count({
     *   where: {
     *     // ... the filter for the DeploymentPlans we want to count
     *   }
     * })
    **/
    count<T extends DeploymentPlanCountArgs>(
      args?: Subset<T, DeploymentPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeploymentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentPlanAggregateArgs>(args: Subset<T, DeploymentPlanAggregateArgs>): Prisma.PrismaPromise<GetDeploymentPlanAggregateType<T>>

    /**
     * Group by DeploymentPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentPlanGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeploymentPlan model
   */
  readonly fields: DeploymentPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeploymentPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prompt<T extends PromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromptDefaultArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executions<T extends DeploymentPlan$executionsArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentPlan$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends DeploymentPlan$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentPlan$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeploymentPlan model
   */ 
  interface DeploymentPlanFieldRefs {
    readonly id: FieldRef<"DeploymentPlan", 'String'>
    readonly planData: FieldRef<"DeploymentPlan", 'String'>
    readonly status: FieldRef<"DeploymentPlan", 'String'>
    readonly createdAt: FieldRef<"DeploymentPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"DeploymentPlan", 'DateTime'>
    readonly projectId: FieldRef<"DeploymentPlan", 'String'>
    readonly promptId: FieldRef<"DeploymentPlan", 'String'>
    readonly createdBy: FieldRef<"DeploymentPlan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeploymentPlan findUnique
   */
  export type DeploymentPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentPlan to fetch.
     */
    where: DeploymentPlanWhereUniqueInput
  }

  /**
   * DeploymentPlan findUniqueOrThrow
   */
  export type DeploymentPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentPlan to fetch.
     */
    where: DeploymentPlanWhereUniqueInput
  }

  /**
   * DeploymentPlan findFirst
   */
  export type DeploymentPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentPlan to fetch.
     */
    where?: DeploymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentPlans to fetch.
     */
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentPlans.
     */
    cursor?: DeploymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentPlans.
     */
    distinct?: DeploymentPlanScalarFieldEnum | DeploymentPlanScalarFieldEnum[]
  }

  /**
   * DeploymentPlan findFirstOrThrow
   */
  export type DeploymentPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentPlan to fetch.
     */
    where?: DeploymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentPlans to fetch.
     */
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentPlans.
     */
    cursor?: DeploymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentPlans.
     */
    distinct?: DeploymentPlanScalarFieldEnum | DeploymentPlanScalarFieldEnum[]
  }

  /**
   * DeploymentPlan findMany
   */
  export type DeploymentPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentPlans to fetch.
     */
    where?: DeploymentPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentPlans to fetch.
     */
    orderBy?: DeploymentPlanOrderByWithRelationInput | DeploymentPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeploymentPlans.
     */
    cursor?: DeploymentPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentPlans.
     */
    skip?: number
    distinct?: DeploymentPlanScalarFieldEnum | DeploymentPlanScalarFieldEnum[]
  }

  /**
   * DeploymentPlan create
   */
  export type DeploymentPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a DeploymentPlan.
     */
    data: XOR<DeploymentPlanCreateInput, DeploymentPlanUncheckedCreateInput>
  }

  /**
   * DeploymentPlan createMany
   */
  export type DeploymentPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeploymentPlans.
     */
    data: DeploymentPlanCreateManyInput | DeploymentPlanCreateManyInput[]
  }

  /**
   * DeploymentPlan createManyAndReturn
   */
  export type DeploymentPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeploymentPlans.
     */
    data: DeploymentPlanCreateManyInput | DeploymentPlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeploymentPlan update
   */
  export type DeploymentPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a DeploymentPlan.
     */
    data: XOR<DeploymentPlanUpdateInput, DeploymentPlanUncheckedUpdateInput>
    /**
     * Choose, which DeploymentPlan to update.
     */
    where: DeploymentPlanWhereUniqueInput
  }

  /**
   * DeploymentPlan updateMany
   */
  export type DeploymentPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeploymentPlans.
     */
    data: XOR<DeploymentPlanUpdateManyMutationInput, DeploymentPlanUncheckedUpdateManyInput>
    /**
     * Filter which DeploymentPlans to update
     */
    where?: DeploymentPlanWhereInput
  }

  /**
   * DeploymentPlan upsert
   */
  export type DeploymentPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the DeploymentPlan to update in case it exists.
     */
    where: DeploymentPlanWhereUniqueInput
    /**
     * In case the DeploymentPlan found by the `where` argument doesn't exist, create a new DeploymentPlan with this data.
     */
    create: XOR<DeploymentPlanCreateInput, DeploymentPlanUncheckedCreateInput>
    /**
     * In case the DeploymentPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentPlanUpdateInput, DeploymentPlanUncheckedUpdateInput>
  }

  /**
   * DeploymentPlan delete
   */
  export type DeploymentPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
    /**
     * Filter which DeploymentPlan to delete.
     */
    where: DeploymentPlanWhereUniqueInput
  }

  /**
   * DeploymentPlan deleteMany
   */
  export type DeploymentPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentPlans to delete
     */
    where?: DeploymentPlanWhereInput
  }

  /**
   * DeploymentPlan.executions
   */
  export type DeploymentPlan$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    where?: DeploymentExecutionWhereInput
    orderBy?: DeploymentExecutionOrderByWithRelationInput | DeploymentExecutionOrderByWithRelationInput[]
    cursor?: DeploymentExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentExecutionScalarFieldEnum | DeploymentExecutionScalarFieldEnum[]
  }

  /**
   * DeploymentPlan.approvals
   */
  export type DeploymentPlan$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    where?: DeploymentApprovalWhereInput
    orderBy?: DeploymentApprovalOrderByWithRelationInput | DeploymentApprovalOrderByWithRelationInput[]
    cursor?: DeploymentApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeploymentApprovalScalarFieldEnum | DeploymentApprovalScalarFieldEnum[]
  }

  /**
   * DeploymentPlan without action
   */
  export type DeploymentPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentPlan
     */
    select?: DeploymentPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentPlanInclude<ExtArgs> | null
  }


  /**
   * Model DeploymentExecution
   */

  export type AggregateDeploymentExecution = {
    _count: DeploymentExecutionCountAggregateOutputType | null
    _avg: DeploymentExecutionAvgAggregateOutputType | null
    _sum: DeploymentExecutionSumAggregateOutputType | null
    _min: DeploymentExecutionMinAggregateOutputType | null
    _max: DeploymentExecutionMaxAggregateOutputType | null
  }

  export type DeploymentExecutionAvgAggregateOutputType = {
    currentStage: number | null
  }

  export type DeploymentExecutionSumAggregateOutputType = {
    currentStage: number | null
  }

  export type DeploymentExecutionMinAggregateOutputType = {
    id: string | null
    status: string | null
    currentStage: number | null
    startedAt: Date | null
    completedAt: Date | null
    metrics: string | null
    error: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    planId: string | null
    executedBy: string | null
  }

  export type DeploymentExecutionMaxAggregateOutputType = {
    id: string | null
    status: string | null
    currentStage: number | null
    startedAt: Date | null
    completedAt: Date | null
    metrics: string | null
    error: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    planId: string | null
    executedBy: string | null
  }

  export type DeploymentExecutionCountAggregateOutputType = {
    id: number
    status: number
    currentStage: number
    startedAt: number
    completedAt: number
    metrics: number
    error: number
    metadata: number
    createdAt: number
    updatedAt: number
    planId: number
    executedBy: number
    _all: number
  }


  export type DeploymentExecutionAvgAggregateInputType = {
    currentStage?: true
  }

  export type DeploymentExecutionSumAggregateInputType = {
    currentStage?: true
  }

  export type DeploymentExecutionMinAggregateInputType = {
    id?: true
    status?: true
    currentStage?: true
    startedAt?: true
    completedAt?: true
    metrics?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    executedBy?: true
  }

  export type DeploymentExecutionMaxAggregateInputType = {
    id?: true
    status?: true
    currentStage?: true
    startedAt?: true
    completedAt?: true
    metrics?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    executedBy?: true
  }

  export type DeploymentExecutionCountAggregateInputType = {
    id?: true
    status?: true
    currentStage?: true
    startedAt?: true
    completedAt?: true
    metrics?: true
    error?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    executedBy?: true
    _all?: true
  }

  export type DeploymentExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentExecution to aggregate.
     */
    where?: DeploymentExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentExecutions to fetch.
     */
    orderBy?: DeploymentExecutionOrderByWithRelationInput | DeploymentExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeploymentExecutions
    **/
    _count?: true | DeploymentExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeploymentExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeploymentExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentExecutionMaxAggregateInputType
  }

  export type GetDeploymentExecutionAggregateType<T extends DeploymentExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeploymentExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeploymentExecution[P]>
      : GetScalarType<T[P], AggregateDeploymentExecution[P]>
  }




  export type DeploymentExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentExecutionWhereInput
    orderBy?: DeploymentExecutionOrderByWithAggregationInput | DeploymentExecutionOrderByWithAggregationInput[]
    by: DeploymentExecutionScalarFieldEnum[] | DeploymentExecutionScalarFieldEnum
    having?: DeploymentExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentExecutionCountAggregateInputType | true
    _avg?: DeploymentExecutionAvgAggregateInputType
    _sum?: DeploymentExecutionSumAggregateInputType
    _min?: DeploymentExecutionMinAggregateInputType
    _max?: DeploymentExecutionMaxAggregateInputType
  }

  export type DeploymentExecutionGroupByOutputType = {
    id: string
    status: string
    currentStage: number
    startedAt: Date | null
    completedAt: Date | null
    metrics: string | null
    error: string | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    planId: string
    executedBy: string
    _count: DeploymentExecutionCountAggregateOutputType | null
    _avg: DeploymentExecutionAvgAggregateOutputType | null
    _sum: DeploymentExecutionSumAggregateOutputType | null
    _min: DeploymentExecutionMinAggregateOutputType | null
    _max: DeploymentExecutionMaxAggregateOutputType | null
  }

  type GetDeploymentExecutionGroupByPayload<T extends DeploymentExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentExecutionGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    currentStage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metrics?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    executedBy?: boolean
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentExecution"]>

  export type DeploymentExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    currentStage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metrics?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    executedBy?: boolean
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentExecution"]>

  export type DeploymentExecutionSelectScalar = {
    id?: boolean
    status?: boolean
    currentStage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metrics?: boolean
    error?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    executedBy?: boolean
  }

  export type DeploymentExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeploymentExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    executor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeploymentExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeploymentExecution"
    objects: {
      plan: Prisma.$DeploymentPlanPayload<ExtArgs>
      executor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      currentStage: number
      startedAt: Date | null
      completedAt: Date | null
      metrics: string | null
      error: string | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
      planId: string
      executedBy: string
    }, ExtArgs["result"]["deploymentExecution"]>
    composites: {}
  }

  type DeploymentExecutionGetPayload<S extends boolean | null | undefined | DeploymentExecutionDefaultArgs> = $Result.GetResult<Prisma.$DeploymentExecutionPayload, S>

  type DeploymentExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentExecutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentExecutionCountAggregateInputType | true
    }

  export interface DeploymentExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeploymentExecution'], meta: { name: 'DeploymentExecution' } }
    /**
     * Find zero or one DeploymentExecution that matches the filter.
     * @param {DeploymentExecutionFindUniqueArgs} args - Arguments to find a DeploymentExecution
     * @example
     * // Get one DeploymentExecution
     * const deploymentExecution = await prisma.deploymentExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentExecutionFindUniqueArgs>(args: SelectSubset<T, DeploymentExecutionFindUniqueArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeploymentExecution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentExecutionFindUniqueOrThrowArgs} args - Arguments to find a DeploymentExecution
     * @example
     * // Get one DeploymentExecution
     * const deploymentExecution = await prisma.deploymentExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeploymentExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionFindFirstArgs} args - Arguments to find a DeploymentExecution
     * @example
     * // Get one DeploymentExecution
     * const deploymentExecution = await prisma.deploymentExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentExecutionFindFirstArgs>(args?: SelectSubset<T, DeploymentExecutionFindFirstArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeploymentExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionFindFirstOrThrowArgs} args - Arguments to find a DeploymentExecution
     * @example
     * // Get one DeploymentExecution
     * const deploymentExecution = await prisma.deploymentExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeploymentExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeploymentExecutions
     * const deploymentExecutions = await prisma.deploymentExecution.findMany()
     * 
     * // Get first 10 DeploymentExecutions
     * const deploymentExecutions = await prisma.deploymentExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentExecutionWithIdOnly = await prisma.deploymentExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentExecutionFindManyArgs>(args?: SelectSubset<T, DeploymentExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeploymentExecution.
     * @param {DeploymentExecutionCreateArgs} args - Arguments to create a DeploymentExecution.
     * @example
     * // Create one DeploymentExecution
     * const DeploymentExecution = await prisma.deploymentExecution.create({
     *   data: {
     *     // ... data to create a DeploymentExecution
     *   }
     * })
     * 
     */
    create<T extends DeploymentExecutionCreateArgs>(args: SelectSubset<T, DeploymentExecutionCreateArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeploymentExecutions.
     * @param {DeploymentExecutionCreateManyArgs} args - Arguments to create many DeploymentExecutions.
     * @example
     * // Create many DeploymentExecutions
     * const deploymentExecution = await prisma.deploymentExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentExecutionCreateManyArgs>(args?: SelectSubset<T, DeploymentExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeploymentExecutions and returns the data saved in the database.
     * @param {DeploymentExecutionCreateManyAndReturnArgs} args - Arguments to create many DeploymentExecutions.
     * @example
     * // Create many DeploymentExecutions
     * const deploymentExecution = await prisma.deploymentExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeploymentExecutions and only return the `id`
     * const deploymentExecutionWithIdOnly = await prisma.deploymentExecution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeploymentExecution.
     * @param {DeploymentExecutionDeleteArgs} args - Arguments to delete one DeploymentExecution.
     * @example
     * // Delete one DeploymentExecution
     * const DeploymentExecution = await prisma.deploymentExecution.delete({
     *   where: {
     *     // ... filter to delete one DeploymentExecution
     *   }
     * })
     * 
     */
    delete<T extends DeploymentExecutionDeleteArgs>(args: SelectSubset<T, DeploymentExecutionDeleteArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeploymentExecution.
     * @param {DeploymentExecutionUpdateArgs} args - Arguments to update one DeploymentExecution.
     * @example
     * // Update one DeploymentExecution
     * const deploymentExecution = await prisma.deploymentExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentExecutionUpdateArgs>(args: SelectSubset<T, DeploymentExecutionUpdateArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeploymentExecutions.
     * @param {DeploymentExecutionDeleteManyArgs} args - Arguments to filter DeploymentExecutions to delete.
     * @example
     * // Delete a few DeploymentExecutions
     * const { count } = await prisma.deploymentExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentExecutionDeleteManyArgs>(args?: SelectSubset<T, DeploymentExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeploymentExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeploymentExecutions
     * const deploymentExecution = await prisma.deploymentExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentExecutionUpdateManyArgs>(args: SelectSubset<T, DeploymentExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeploymentExecution.
     * @param {DeploymentExecutionUpsertArgs} args - Arguments to update or create a DeploymentExecution.
     * @example
     * // Update or create a DeploymentExecution
     * const deploymentExecution = await prisma.deploymentExecution.upsert({
     *   create: {
     *     // ... data to create a DeploymentExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeploymentExecution we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentExecutionUpsertArgs>(args: SelectSubset<T, DeploymentExecutionUpsertArgs<ExtArgs>>): Prisma__DeploymentExecutionClient<$Result.GetResult<Prisma.$DeploymentExecutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeploymentExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionCountArgs} args - Arguments to filter DeploymentExecutions to count.
     * @example
     * // Count the number of DeploymentExecutions
     * const count = await prisma.deploymentExecution.count({
     *   where: {
     *     // ... the filter for the DeploymentExecutions we want to count
     *   }
     * })
    **/
    count<T extends DeploymentExecutionCountArgs>(
      args?: Subset<T, DeploymentExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeploymentExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentExecutionAggregateArgs>(args: Subset<T, DeploymentExecutionAggregateArgs>): Prisma.PrismaPromise<GetDeploymentExecutionAggregateType<T>>

    /**
     * Group by DeploymentExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentExecutionGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeploymentExecution model
   */
  readonly fields: DeploymentExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeploymentExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends DeploymentPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentPlanDefaultArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeploymentExecution model
   */ 
  interface DeploymentExecutionFieldRefs {
    readonly id: FieldRef<"DeploymentExecution", 'String'>
    readonly status: FieldRef<"DeploymentExecution", 'String'>
    readonly currentStage: FieldRef<"DeploymentExecution", 'Int'>
    readonly startedAt: FieldRef<"DeploymentExecution", 'DateTime'>
    readonly completedAt: FieldRef<"DeploymentExecution", 'DateTime'>
    readonly metrics: FieldRef<"DeploymentExecution", 'String'>
    readonly error: FieldRef<"DeploymentExecution", 'String'>
    readonly metadata: FieldRef<"DeploymentExecution", 'String'>
    readonly createdAt: FieldRef<"DeploymentExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"DeploymentExecution", 'DateTime'>
    readonly planId: FieldRef<"DeploymentExecution", 'String'>
    readonly executedBy: FieldRef<"DeploymentExecution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeploymentExecution findUnique
   */
  export type DeploymentExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentExecution to fetch.
     */
    where: DeploymentExecutionWhereUniqueInput
  }

  /**
   * DeploymentExecution findUniqueOrThrow
   */
  export type DeploymentExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentExecution to fetch.
     */
    where: DeploymentExecutionWhereUniqueInput
  }

  /**
   * DeploymentExecution findFirst
   */
  export type DeploymentExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentExecution to fetch.
     */
    where?: DeploymentExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentExecutions to fetch.
     */
    orderBy?: DeploymentExecutionOrderByWithRelationInput | DeploymentExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentExecutions.
     */
    cursor?: DeploymentExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentExecutions.
     */
    distinct?: DeploymentExecutionScalarFieldEnum | DeploymentExecutionScalarFieldEnum[]
  }

  /**
   * DeploymentExecution findFirstOrThrow
   */
  export type DeploymentExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentExecution to fetch.
     */
    where?: DeploymentExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentExecutions to fetch.
     */
    orderBy?: DeploymentExecutionOrderByWithRelationInput | DeploymentExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentExecutions.
     */
    cursor?: DeploymentExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentExecutions.
     */
    distinct?: DeploymentExecutionScalarFieldEnum | DeploymentExecutionScalarFieldEnum[]
  }

  /**
   * DeploymentExecution findMany
   */
  export type DeploymentExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentExecutions to fetch.
     */
    where?: DeploymentExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentExecutions to fetch.
     */
    orderBy?: DeploymentExecutionOrderByWithRelationInput | DeploymentExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeploymentExecutions.
     */
    cursor?: DeploymentExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentExecutions.
     */
    skip?: number
    distinct?: DeploymentExecutionScalarFieldEnum | DeploymentExecutionScalarFieldEnum[]
  }

  /**
   * DeploymentExecution create
   */
  export type DeploymentExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a DeploymentExecution.
     */
    data: XOR<DeploymentExecutionCreateInput, DeploymentExecutionUncheckedCreateInput>
  }

  /**
   * DeploymentExecution createMany
   */
  export type DeploymentExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeploymentExecutions.
     */
    data: DeploymentExecutionCreateManyInput | DeploymentExecutionCreateManyInput[]
  }

  /**
   * DeploymentExecution createManyAndReturn
   */
  export type DeploymentExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeploymentExecutions.
     */
    data: DeploymentExecutionCreateManyInput | DeploymentExecutionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeploymentExecution update
   */
  export type DeploymentExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a DeploymentExecution.
     */
    data: XOR<DeploymentExecutionUpdateInput, DeploymentExecutionUncheckedUpdateInput>
    /**
     * Choose, which DeploymentExecution to update.
     */
    where: DeploymentExecutionWhereUniqueInput
  }

  /**
   * DeploymentExecution updateMany
   */
  export type DeploymentExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeploymentExecutions.
     */
    data: XOR<DeploymentExecutionUpdateManyMutationInput, DeploymentExecutionUncheckedUpdateManyInput>
    /**
     * Filter which DeploymentExecutions to update
     */
    where?: DeploymentExecutionWhereInput
  }

  /**
   * DeploymentExecution upsert
   */
  export type DeploymentExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the DeploymentExecution to update in case it exists.
     */
    where: DeploymentExecutionWhereUniqueInput
    /**
     * In case the DeploymentExecution found by the `where` argument doesn't exist, create a new DeploymentExecution with this data.
     */
    create: XOR<DeploymentExecutionCreateInput, DeploymentExecutionUncheckedCreateInput>
    /**
     * In case the DeploymentExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentExecutionUpdateInput, DeploymentExecutionUncheckedUpdateInput>
  }

  /**
   * DeploymentExecution delete
   */
  export type DeploymentExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
    /**
     * Filter which DeploymentExecution to delete.
     */
    where: DeploymentExecutionWhereUniqueInput
  }

  /**
   * DeploymentExecution deleteMany
   */
  export type DeploymentExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentExecutions to delete
     */
    where?: DeploymentExecutionWhereInput
  }

  /**
   * DeploymentExecution without action
   */
  export type DeploymentExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentExecution
     */
    select?: DeploymentExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentExecutionInclude<ExtArgs> | null
  }


  /**
   * Model DeploymentApproval
   */

  export type AggregateDeploymentApproval = {
    _count: DeploymentApprovalCountAggregateOutputType | null
    _min: DeploymentApprovalMinAggregateOutputType | null
    _max: DeploymentApprovalMaxAggregateOutputType | null
  }

  export type DeploymentApprovalMinAggregateOutputType = {
    id: string | null
    status: string | null
    comments: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    planId: string | null
    approvedBy: string | null
  }

  export type DeploymentApprovalMaxAggregateOutputType = {
    id: string | null
    status: string | null
    comments: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    planId: string | null
    approvedBy: string | null
  }

  export type DeploymentApprovalCountAggregateOutputType = {
    id: number
    status: number
    comments: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    planId: number
    approvedBy: number
    _all: number
  }


  export type DeploymentApprovalMinAggregateInputType = {
    id?: true
    status?: true
    comments?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    approvedBy?: true
  }

  export type DeploymentApprovalMaxAggregateInputType = {
    id?: true
    status?: true
    comments?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    approvedBy?: true
  }

  export type DeploymentApprovalCountAggregateInputType = {
    id?: true
    status?: true
    comments?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    planId?: true
    approvedBy?: true
    _all?: true
  }

  export type DeploymentApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentApproval to aggregate.
     */
    where?: DeploymentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentApprovals to fetch.
     */
    orderBy?: DeploymentApprovalOrderByWithRelationInput | DeploymentApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeploymentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeploymentApprovals
    **/
    _count?: true | DeploymentApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeploymentApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeploymentApprovalMaxAggregateInputType
  }

  export type GetDeploymentApprovalAggregateType<T extends DeploymentApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateDeploymentApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeploymentApproval[P]>
      : GetScalarType<T[P], AggregateDeploymentApproval[P]>
  }




  export type DeploymentApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeploymentApprovalWhereInput
    orderBy?: DeploymentApprovalOrderByWithAggregationInput | DeploymentApprovalOrderByWithAggregationInput[]
    by: DeploymentApprovalScalarFieldEnum[] | DeploymentApprovalScalarFieldEnum
    having?: DeploymentApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeploymentApprovalCountAggregateInputType | true
    _min?: DeploymentApprovalMinAggregateInputType
    _max?: DeploymentApprovalMaxAggregateInputType
  }

  export type DeploymentApprovalGroupByOutputType = {
    id: string
    status: string
    comments: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    planId: string
    approvedBy: string
    _count: DeploymentApprovalCountAggregateOutputType | null
    _min: DeploymentApprovalMinAggregateOutputType | null
    _max: DeploymentApprovalMaxAggregateOutputType | null
  }

  type GetDeploymentApprovalGroupByPayload<T extends DeploymentApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeploymentApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeploymentApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeploymentApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], DeploymentApprovalGroupByOutputType[P]>
        }
      >
    >


  export type DeploymentApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    comments?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    approvedBy?: boolean
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentApproval"]>

  export type DeploymentApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    comments?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    approvedBy?: boolean
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deploymentApproval"]>

  export type DeploymentApprovalSelectScalar = {
    id?: boolean
    status?: boolean
    comments?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planId?: boolean
    approvedBy?: boolean
  }

  export type DeploymentApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeploymentApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | DeploymentPlanDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeploymentApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeploymentApproval"
    objects: {
      plan: Prisma.$DeploymentPlanPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      comments: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
      planId: string
      approvedBy: string
    }, ExtArgs["result"]["deploymentApproval"]>
    composites: {}
  }

  type DeploymentApprovalGetPayload<S extends boolean | null | undefined | DeploymentApprovalDefaultArgs> = $Result.GetResult<Prisma.$DeploymentApprovalPayload, S>

  type DeploymentApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeploymentApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeploymentApprovalCountAggregateInputType | true
    }

  export interface DeploymentApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeploymentApproval'], meta: { name: 'DeploymentApproval' } }
    /**
     * Find zero or one DeploymentApproval that matches the filter.
     * @param {DeploymentApprovalFindUniqueArgs} args - Arguments to find a DeploymentApproval
     * @example
     * // Get one DeploymentApproval
     * const deploymentApproval = await prisma.deploymentApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeploymentApprovalFindUniqueArgs>(args: SelectSubset<T, DeploymentApprovalFindUniqueArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeploymentApproval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeploymentApprovalFindUniqueOrThrowArgs} args - Arguments to find a DeploymentApproval
     * @example
     * // Get one DeploymentApproval
     * const deploymentApproval = await prisma.deploymentApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeploymentApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, DeploymentApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeploymentApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalFindFirstArgs} args - Arguments to find a DeploymentApproval
     * @example
     * // Get one DeploymentApproval
     * const deploymentApproval = await prisma.deploymentApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeploymentApprovalFindFirstArgs>(args?: SelectSubset<T, DeploymentApprovalFindFirstArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeploymentApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalFindFirstOrThrowArgs} args - Arguments to find a DeploymentApproval
     * @example
     * // Get one DeploymentApproval
     * const deploymentApproval = await prisma.deploymentApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeploymentApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, DeploymentApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeploymentApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeploymentApprovals
     * const deploymentApprovals = await prisma.deploymentApproval.findMany()
     * 
     * // Get first 10 DeploymentApprovals
     * const deploymentApprovals = await prisma.deploymentApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deploymentApprovalWithIdOnly = await prisma.deploymentApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeploymentApprovalFindManyArgs>(args?: SelectSubset<T, DeploymentApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeploymentApproval.
     * @param {DeploymentApprovalCreateArgs} args - Arguments to create a DeploymentApproval.
     * @example
     * // Create one DeploymentApproval
     * const DeploymentApproval = await prisma.deploymentApproval.create({
     *   data: {
     *     // ... data to create a DeploymentApproval
     *   }
     * })
     * 
     */
    create<T extends DeploymentApprovalCreateArgs>(args: SelectSubset<T, DeploymentApprovalCreateArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeploymentApprovals.
     * @param {DeploymentApprovalCreateManyArgs} args - Arguments to create many DeploymentApprovals.
     * @example
     * // Create many DeploymentApprovals
     * const deploymentApproval = await prisma.deploymentApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeploymentApprovalCreateManyArgs>(args?: SelectSubset<T, DeploymentApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeploymentApprovals and returns the data saved in the database.
     * @param {DeploymentApprovalCreateManyAndReturnArgs} args - Arguments to create many DeploymentApprovals.
     * @example
     * // Create many DeploymentApprovals
     * const deploymentApproval = await prisma.deploymentApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeploymentApprovals and only return the `id`
     * const deploymentApprovalWithIdOnly = await prisma.deploymentApproval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeploymentApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, DeploymentApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeploymentApproval.
     * @param {DeploymentApprovalDeleteArgs} args - Arguments to delete one DeploymentApproval.
     * @example
     * // Delete one DeploymentApproval
     * const DeploymentApproval = await prisma.deploymentApproval.delete({
     *   where: {
     *     // ... filter to delete one DeploymentApproval
     *   }
     * })
     * 
     */
    delete<T extends DeploymentApprovalDeleteArgs>(args: SelectSubset<T, DeploymentApprovalDeleteArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeploymentApproval.
     * @param {DeploymentApprovalUpdateArgs} args - Arguments to update one DeploymentApproval.
     * @example
     * // Update one DeploymentApproval
     * const deploymentApproval = await prisma.deploymentApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeploymentApprovalUpdateArgs>(args: SelectSubset<T, DeploymentApprovalUpdateArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeploymentApprovals.
     * @param {DeploymentApprovalDeleteManyArgs} args - Arguments to filter DeploymentApprovals to delete.
     * @example
     * // Delete a few DeploymentApprovals
     * const { count } = await prisma.deploymentApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeploymentApprovalDeleteManyArgs>(args?: SelectSubset<T, DeploymentApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeploymentApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeploymentApprovals
     * const deploymentApproval = await prisma.deploymentApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeploymentApprovalUpdateManyArgs>(args: SelectSubset<T, DeploymentApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeploymentApproval.
     * @param {DeploymentApprovalUpsertArgs} args - Arguments to update or create a DeploymentApproval.
     * @example
     * // Update or create a DeploymentApproval
     * const deploymentApproval = await prisma.deploymentApproval.upsert({
     *   create: {
     *     // ... data to create a DeploymentApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeploymentApproval we want to update
     *   }
     * })
     */
    upsert<T extends DeploymentApprovalUpsertArgs>(args: SelectSubset<T, DeploymentApprovalUpsertArgs<ExtArgs>>): Prisma__DeploymentApprovalClient<$Result.GetResult<Prisma.$DeploymentApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeploymentApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalCountArgs} args - Arguments to filter DeploymentApprovals to count.
     * @example
     * // Count the number of DeploymentApprovals
     * const count = await prisma.deploymentApproval.count({
     *   where: {
     *     // ... the filter for the DeploymentApprovals we want to count
     *   }
     * })
    **/
    count<T extends DeploymentApprovalCountArgs>(
      args?: Subset<T, DeploymentApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeploymentApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeploymentApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeploymentApprovalAggregateArgs>(args: Subset<T, DeploymentApprovalAggregateArgs>): Prisma.PrismaPromise<GetDeploymentApprovalAggregateType<T>>

    /**
     * Group by DeploymentApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeploymentApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeploymentApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeploymentApprovalGroupByArgs['orderBy'] }
        : { orderBy?: DeploymentApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeploymentApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeploymentApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeploymentApproval model
   */
  readonly fields: DeploymentApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeploymentApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeploymentApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends DeploymentPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeploymentPlanDefaultArgs<ExtArgs>>): Prisma__DeploymentPlanClient<$Result.GetResult<Prisma.$DeploymentPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeploymentApproval model
   */ 
  interface DeploymentApprovalFieldRefs {
    readonly id: FieldRef<"DeploymentApproval", 'String'>
    readonly status: FieldRef<"DeploymentApproval", 'String'>
    readonly comments: FieldRef<"DeploymentApproval", 'String'>
    readonly approvedAt: FieldRef<"DeploymentApproval", 'DateTime'>
    readonly createdAt: FieldRef<"DeploymentApproval", 'DateTime'>
    readonly updatedAt: FieldRef<"DeploymentApproval", 'DateTime'>
    readonly planId: FieldRef<"DeploymentApproval", 'String'>
    readonly approvedBy: FieldRef<"DeploymentApproval", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeploymentApproval findUnique
   */
  export type DeploymentApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentApproval to fetch.
     */
    where: DeploymentApprovalWhereUniqueInput
  }

  /**
   * DeploymentApproval findUniqueOrThrow
   */
  export type DeploymentApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentApproval to fetch.
     */
    where: DeploymentApprovalWhereUniqueInput
  }

  /**
   * DeploymentApproval findFirst
   */
  export type DeploymentApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentApproval to fetch.
     */
    where?: DeploymentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentApprovals to fetch.
     */
    orderBy?: DeploymentApprovalOrderByWithRelationInput | DeploymentApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentApprovals.
     */
    cursor?: DeploymentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentApprovals.
     */
    distinct?: DeploymentApprovalScalarFieldEnum | DeploymentApprovalScalarFieldEnum[]
  }

  /**
   * DeploymentApproval findFirstOrThrow
   */
  export type DeploymentApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentApproval to fetch.
     */
    where?: DeploymentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentApprovals to fetch.
     */
    orderBy?: DeploymentApprovalOrderByWithRelationInput | DeploymentApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeploymentApprovals.
     */
    cursor?: DeploymentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeploymentApprovals.
     */
    distinct?: DeploymentApprovalScalarFieldEnum | DeploymentApprovalScalarFieldEnum[]
  }

  /**
   * DeploymentApproval findMany
   */
  export type DeploymentApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * Filter, which DeploymentApprovals to fetch.
     */
    where?: DeploymentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeploymentApprovals to fetch.
     */
    orderBy?: DeploymentApprovalOrderByWithRelationInput | DeploymentApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeploymentApprovals.
     */
    cursor?: DeploymentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeploymentApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeploymentApprovals.
     */
    skip?: number
    distinct?: DeploymentApprovalScalarFieldEnum | DeploymentApprovalScalarFieldEnum[]
  }

  /**
   * DeploymentApproval create
   */
  export type DeploymentApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a DeploymentApproval.
     */
    data: XOR<DeploymentApprovalCreateInput, DeploymentApprovalUncheckedCreateInput>
  }

  /**
   * DeploymentApproval createMany
   */
  export type DeploymentApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeploymentApprovals.
     */
    data: DeploymentApprovalCreateManyInput | DeploymentApprovalCreateManyInput[]
  }

  /**
   * DeploymentApproval createManyAndReturn
   */
  export type DeploymentApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeploymentApprovals.
     */
    data: DeploymentApprovalCreateManyInput | DeploymentApprovalCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeploymentApproval update
   */
  export type DeploymentApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a DeploymentApproval.
     */
    data: XOR<DeploymentApprovalUpdateInput, DeploymentApprovalUncheckedUpdateInput>
    /**
     * Choose, which DeploymentApproval to update.
     */
    where: DeploymentApprovalWhereUniqueInput
  }

  /**
   * DeploymentApproval updateMany
   */
  export type DeploymentApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeploymentApprovals.
     */
    data: XOR<DeploymentApprovalUpdateManyMutationInput, DeploymentApprovalUncheckedUpdateManyInput>
    /**
     * Filter which DeploymentApprovals to update
     */
    where?: DeploymentApprovalWhereInput
  }

  /**
   * DeploymentApproval upsert
   */
  export type DeploymentApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the DeploymentApproval to update in case it exists.
     */
    where: DeploymentApprovalWhereUniqueInput
    /**
     * In case the DeploymentApproval found by the `where` argument doesn't exist, create a new DeploymentApproval with this data.
     */
    create: XOR<DeploymentApprovalCreateInput, DeploymentApprovalUncheckedCreateInput>
    /**
     * In case the DeploymentApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeploymentApprovalUpdateInput, DeploymentApprovalUncheckedUpdateInput>
  }

  /**
   * DeploymentApproval delete
   */
  export type DeploymentApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
    /**
     * Filter which DeploymentApproval to delete.
     */
    where: DeploymentApprovalWhereUniqueInput
  }

  /**
   * DeploymentApproval deleteMany
   */
  export type DeploymentApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeploymentApprovals to delete
     */
    where?: DeploymentApprovalWhereInput
  }

  /**
   * DeploymentApproval without action
   */
  export type DeploymentApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeploymentApproval
     */
    select?: DeploymentApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeploymentApprovalInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalRequest
   */

  export type AggregateApprovalRequest = {
    _count: ApprovalRequestCountAggregateOutputType | null
    _min: ApprovalRequestMinAggregateOutputType | null
    _max: ApprovalRequestMaxAggregateOutputType | null
  }

  export type ApprovalRequestMinAggregateOutputType = {
    id: string | null
    status: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    promptId: string | null
    appId: string | null
    requestedBy: string | null
    impactAnalysisId: string | null
  }

  export type ApprovalRequestMaxAggregateOutputType = {
    id: string | null
    status: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    promptId: string | null
    appId: string | null
    requestedBy: string | null
    impactAnalysisId: string | null
  }

  export type ApprovalRequestCountAggregateOutputType = {
    id: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    projectId: number
    promptId: number
    appId: number
    requestedBy: number
    impactAnalysisId: number
    _all: number
  }


  export type ApprovalRequestMinAggregateInputType = {
    id?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    promptId?: true
    appId?: true
    requestedBy?: true
    impactAnalysisId?: true
  }

  export type ApprovalRequestMaxAggregateInputType = {
    id?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    promptId?: true
    appId?: true
    requestedBy?: true
    impactAnalysisId?: true
  }

  export type ApprovalRequestCountAggregateInputType = {
    id?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    promptId?: true
    appId?: true
    requestedBy?: true
    impactAnalysisId?: true
    _all?: true
  }

  export type ApprovalRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalRequest to aggregate.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalRequests
    **/
    _count?: true | ApprovalRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalRequestMaxAggregateInputType
  }

  export type GetApprovalRequestAggregateType<T extends ApprovalRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalRequest[P]>
      : GetScalarType<T[P], AggregateApprovalRequest[P]>
  }




  export type ApprovalRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithAggregationInput | ApprovalRequestOrderByWithAggregationInput[]
    by: ApprovalRequestScalarFieldEnum[] | ApprovalRequestScalarFieldEnum
    having?: ApprovalRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalRequestCountAggregateInputType | true
    _min?: ApprovalRequestMinAggregateInputType
    _max?: ApprovalRequestMaxAggregateInputType
  }

  export type ApprovalRequestGroupByOutputType = {
    id: string
    status: string
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    promptId: string
    appId: string
    requestedBy: string
    impactAnalysisId: string | null
    _count: ApprovalRequestCountAggregateOutputType | null
    _min: ApprovalRequestMinAggregateOutputType | null
    _max: ApprovalRequestMaxAggregateOutputType | null
  }

  type GetApprovalRequestGroupByPayload<T extends ApprovalRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalRequestGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    promptId?: boolean
    appId?: boolean
    requestedBy?: boolean
    impactAnalysisId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    impactAnalysis?: boolean | ApprovalRequest$impactAnalysisArgs<ExtArgs>
  }, ExtArgs["result"]["approvalRequest"]>

  export type ApprovalRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    promptId?: boolean
    appId?: boolean
    requestedBy?: boolean
    impactAnalysisId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    impactAnalysis?: boolean | ApprovalRequest$impactAnalysisArgs<ExtArgs>
  }, ExtArgs["result"]["approvalRequest"]>

  export type ApprovalRequestSelectScalar = {
    id?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    promptId?: boolean
    appId?: boolean
    requestedBy?: boolean
    impactAnalysisId?: boolean
  }

  export type ApprovalRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    impactAnalysis?: boolean | ApprovalRequest$impactAnalysisArgs<ExtArgs>
  }
  export type ApprovalRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    prompt?: boolean | PromptDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    impactAnalysis?: boolean | ApprovalRequest$impactAnalysisArgs<ExtArgs>
  }

  export type $ApprovalRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalRequest"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      prompt: Prisma.$PromptPayload<ExtArgs>
      requester: Prisma.$UserPayload<ExtArgs>
      impactAnalysis: Prisma.$ImpactAnalysisPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      metadata: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
      promptId: string
      appId: string
      requestedBy: string
      impactAnalysisId: string | null
    }, ExtArgs["result"]["approvalRequest"]>
    composites: {}
  }

  type ApprovalRequestGetPayload<S extends boolean | null | undefined | ApprovalRequestDefaultArgs> = $Result.GetResult<Prisma.$ApprovalRequestPayload, S>

  type ApprovalRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalRequestCountAggregateInputType | true
    }

  export interface ApprovalRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalRequest'], meta: { name: 'ApprovalRequest' } }
    /**
     * Find zero or one ApprovalRequest that matches the filter.
     * @param {ApprovalRequestFindUniqueArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalRequestFindUniqueArgs>(args: SelectSubset<T, ApprovalRequestFindUniqueArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalRequestFindUniqueOrThrowArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindFirstArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalRequestFindFirstArgs>(args?: SelectSubset<T, ApprovalRequestFindFirstArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindFirstOrThrowArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalRequests
     * const approvalRequests = await prisma.approvalRequest.findMany()
     * 
     * // Get first 10 ApprovalRequests
     * const approvalRequests = await prisma.approvalRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalRequestWithIdOnly = await prisma.approvalRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalRequestFindManyArgs>(args?: SelectSubset<T, ApprovalRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalRequest.
     * @param {ApprovalRequestCreateArgs} args - Arguments to create a ApprovalRequest.
     * @example
     * // Create one ApprovalRequest
     * const ApprovalRequest = await prisma.approvalRequest.create({
     *   data: {
     *     // ... data to create a ApprovalRequest
     *   }
     * })
     * 
     */
    create<T extends ApprovalRequestCreateArgs>(args: SelectSubset<T, ApprovalRequestCreateArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalRequests.
     * @param {ApprovalRequestCreateManyArgs} args - Arguments to create many ApprovalRequests.
     * @example
     * // Create many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalRequestCreateManyArgs>(args?: SelectSubset<T, ApprovalRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalRequests and returns the data saved in the database.
     * @param {ApprovalRequestCreateManyAndReturnArgs} args - Arguments to create many ApprovalRequests.
     * @example
     * // Create many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalRequests and only return the `id`
     * const approvalRequestWithIdOnly = await prisma.approvalRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalRequest.
     * @param {ApprovalRequestDeleteArgs} args - Arguments to delete one ApprovalRequest.
     * @example
     * // Delete one ApprovalRequest
     * const ApprovalRequest = await prisma.approvalRequest.delete({
     *   where: {
     *     // ... filter to delete one ApprovalRequest
     *   }
     * })
     * 
     */
    delete<T extends ApprovalRequestDeleteArgs>(args: SelectSubset<T, ApprovalRequestDeleteArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalRequest.
     * @param {ApprovalRequestUpdateArgs} args - Arguments to update one ApprovalRequest.
     * @example
     * // Update one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalRequestUpdateArgs>(args: SelectSubset<T, ApprovalRequestUpdateArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalRequests.
     * @param {ApprovalRequestDeleteManyArgs} args - Arguments to filter ApprovalRequests to delete.
     * @example
     * // Delete a few ApprovalRequests
     * const { count } = await prisma.approvalRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalRequestDeleteManyArgs>(args?: SelectSubset<T, ApprovalRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalRequestUpdateManyArgs>(args: SelectSubset<T, ApprovalRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalRequest.
     * @param {ApprovalRequestUpsertArgs} args - Arguments to update or create a ApprovalRequest.
     * @example
     * // Update or create a ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.upsert({
     *   create: {
     *     // ... data to create a ApprovalRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalRequest we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalRequestUpsertArgs>(args: SelectSubset<T, ApprovalRequestUpsertArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestCountArgs} args - Arguments to filter ApprovalRequests to count.
     * @example
     * // Count the number of ApprovalRequests
     * const count = await prisma.approvalRequest.count({
     *   where: {
     *     // ... the filter for the ApprovalRequests we want to count
     *   }
     * })
    **/
    count<T extends ApprovalRequestCountArgs>(
      args?: Subset<T, ApprovalRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalRequestAggregateArgs>(args: Subset<T, ApprovalRequestAggregateArgs>): Prisma.PrismaPromise<GetApprovalRequestAggregateType<T>>

    /**
     * Group by ApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalRequestGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalRequest model
   */
  readonly fields: ApprovalRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prompt<T extends PromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromptDefaultArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    impactAnalysis<T extends ApprovalRequest$impactAnalysisArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalRequest$impactAnalysisArgs<ExtArgs>>): Prisma__ImpactAnalysisClient<$Result.GetResult<Prisma.$ImpactAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalRequest model
   */ 
  interface ApprovalRequestFieldRefs {
    readonly id: FieldRef<"ApprovalRequest", 'String'>
    readonly status: FieldRef<"ApprovalRequest", 'String'>
    readonly metadata: FieldRef<"ApprovalRequest", 'String'>
    readonly createdAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly projectId: FieldRef<"ApprovalRequest", 'String'>
    readonly promptId: FieldRef<"ApprovalRequest", 'String'>
    readonly appId: FieldRef<"ApprovalRequest", 'String'>
    readonly requestedBy: FieldRef<"ApprovalRequest", 'String'>
    readonly impactAnalysisId: FieldRef<"ApprovalRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalRequest findUnique
   */
  export type ApprovalRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest findUniqueOrThrow
   */
  export type ApprovalRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest findFirst
   */
  export type ApprovalRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalRequests.
     */
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest findFirstOrThrow
   */
  export type ApprovalRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalRequests.
     */
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest findMany
   */
  export type ApprovalRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequests to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest create
   */
  export type ApprovalRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalRequest.
     */
    data: XOR<ApprovalRequestCreateInput, ApprovalRequestUncheckedCreateInput>
  }

  /**
   * ApprovalRequest createMany
   */
  export type ApprovalRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalRequests.
     */
    data: ApprovalRequestCreateManyInput | ApprovalRequestCreateManyInput[]
  }

  /**
   * ApprovalRequest createManyAndReturn
   */
  export type ApprovalRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalRequests.
     */
    data: ApprovalRequestCreateManyInput | ApprovalRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalRequest update
   */
  export type ApprovalRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalRequest.
     */
    data: XOR<ApprovalRequestUpdateInput, ApprovalRequestUncheckedUpdateInput>
    /**
     * Choose, which ApprovalRequest to update.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest updateMany
   */
  export type ApprovalRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalRequests.
     */
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalRequests to update
     */
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalRequest upsert
   */
  export type ApprovalRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalRequest to update in case it exists.
     */
    where: ApprovalRequestWhereUniqueInput
    /**
     * In case the ApprovalRequest found by the `where` argument doesn't exist, create a new ApprovalRequest with this data.
     */
    create: XOR<ApprovalRequestCreateInput, ApprovalRequestUncheckedCreateInput>
    /**
     * In case the ApprovalRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalRequestUpdateInput, ApprovalRequestUncheckedUpdateInput>
  }

  /**
   * ApprovalRequest delete
   */
  export type ApprovalRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter which ApprovalRequest to delete.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest deleteMany
   */
  export type ApprovalRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalRequests to delete
     */
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalRequest.impactAnalysis
   */
  export type ApprovalRequest$impactAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpactAnalysis
     */
    select?: ImpactAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpactAnalysisInclude<ExtArgs> | null
    where?: ImpactAnalysisWhereInput
  }

  /**
   * ApprovalRequest without action
   */
  export type ApprovalRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    userId: 'userId'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const PromptScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    content: 'content',
    version: 'version',
    isArchived: 'isArchived',
    tags: 'tags',
    metadata: 'metadata',
    outputSchema: 'outputSchema',
    outputFormat: 'outputFormat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    parentId: 'parentId'
  };

  export type PromptScalarFieldEnum = (typeof PromptScalarFieldEnum)[keyof typeof PromptScalarFieldEnum]


  export const TestRunScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    config: 'config',
    metadata: 'metadata',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    userId: 'userId',
    promptId: 'promptId'
  };

  export type TestRunScalarFieldEnum = (typeof TestRunScalarFieldEnum)[keyof typeof TestRunScalarFieldEnum]


  export const TestResponseScalarFieldEnum: {
    id: 'id',
    modelProvider: 'modelProvider',
    modelName: 'modelName',
    input: 'input',
    output: 'output',
    parsedOutput: 'parsedOutput',
    outputStructure: 'outputStructure',
    tokenUsage: 'tokenUsage',
    latencyMs: 'latencyMs',
    cost: 'cost',
    error: 'error',
    rawResponse: 'rawResponse',
    evaluationData: 'evaluationData',
    createdAt: 'createdAt',
    testRunId: 'testRunId'
  };

  export type TestResponseScalarFieldEnum = (typeof TestResponseScalarFieldEnum)[keyof typeof TestResponseScalarFieldEnum]


  export const TestMetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    unit: 'unit',
    metadata: 'metadata',
    createdAt: 'createdAt',
    testRunId: 'testRunId'
  };

  export type TestMetricScalarFieldEnum = (typeof TestMetricScalarFieldEnum)[keyof typeof TestMetricScalarFieldEnum]


  export const EvaluationPluginScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    description: 'description',
    config: 'config',
    code: 'code',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationPluginScalarFieldEnum = (typeof EvaluationPluginScalarFieldEnum)[keyof typeof EvaluationPluginScalarFieldEnum]


  export const QueueJobScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    priority: 'priority',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    status: 'status',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    processedAt: 'processedAt'
  };

  export type QueueJobScalarFieldEnum = (typeof QueueJobScalarFieldEnum)[keyof typeof QueueJobScalarFieldEnum]


  export const RecurringJobScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    interval: 'interval',
    priority: 'priority',
    enabled: 'enabled',
    nextRun: 'nextRun',
    lastRun: 'lastRun',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringJobScalarFieldEnum = (typeof RecurringJobScalarFieldEnum)[keyof typeof RecurringJobScalarFieldEnum]


  export const SyncOperationScalarFieldEnum: {
    id: 'id',
    direction: 'direction',
    strategy: 'strategy',
    status: 'status',
    progress: 'progress',
    result: 'result',
    error: 'error',
    config: 'config',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    connectionId: 'connectionId',
    initiatedBy: 'initiatedBy'
  };

  export type SyncOperationScalarFieldEnum = (typeof SyncOperationScalarFieldEnum)[keyof typeof SyncOperationScalarFieldEnum]


  export const WebhookSubscriptionScalarFieldEnum: {
    id: 'id',
    url: 'url',
    events: 'events',
    headers: 'headers',
    secret: 'secret',
    enabled: 'enabled',
    retryAttempts: 'retryAttempts',
    lastDelivery: 'lastDelivery',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    createdBy: 'createdBy'
  };

  export type WebhookSubscriptionScalarFieldEnum = (typeof WebhookSubscriptionScalarFieldEnum)[keyof typeof WebhookSubscriptionScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    url: 'url',
    payload: 'payload',
    headers: 'headers',
    status: 'status',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    response: 'response',
    error: 'error',
    deliveredAt: 'deliveredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    eventType: 'eventType',
    projectId: 'projectId',
    webhookId: 'webhookId',
    failedWebhookId: 'failedWebhookId'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    provider: 'provider',
    keyHash: 'keyHash',
    isActive: 'isActive',
    lastUsed: 'lastUsed',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const EnvironmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    config: 'config',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type EnvironmentScalarFieldEnum = (typeof EnvironmentScalarFieldEnum)[keyof typeof EnvironmentScalarFieldEnum]


  export const DeploymentScalarFieldEnum: {
    id: 'id',
    version: 'version',
    status: 'status',
    deployedUrl: 'deployedUrl',
    config: 'config',
    metadata: 'metadata',
    deployedAt: 'deployedAt',
    rollbackAt: 'rollbackAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    promptId: 'promptId',
    environmentId: 'environmentId',
    deployedBy: 'deployedBy'
  };

  export type DeploymentScalarFieldEnum = (typeof DeploymentScalarFieldEnum)[keyof typeof DeploymentScalarFieldEnum]


  export const DeploymentHistoryScalarFieldEnum: {
    id: 'id',
    action: 'action',
    status: 'status',
    metadata: 'metadata',
    timestamp: 'timestamp',
    deploymentId: 'deploymentId',
    performedBy: 'performedBy'
  };

  export type DeploymentHistoryScalarFieldEnum = (typeof DeploymentHistoryScalarFieldEnum)[keyof typeof DeploymentHistoryScalarFieldEnum]


  export const ImpactAnalysisScalarFieldEnum: {
    id: 'id',
    impactPercentage: 'impactPercentage',
    diffAnalysis: 'diffAnalysis',
    sampleComparisons: 'sampleComparisons',
    createdAt: 'createdAt',
    deploymentId: 'deploymentId',
    baselinePromptId: 'baselinePromptId'
  };

  export type ImpactAnalysisScalarFieldEnum = (typeof ImpactAnalysisScalarFieldEnum)[keyof typeof ImpactAnalysisScalarFieldEnum]


  export const CostTrackingScalarFieldEnum: {
    id: 'id',
    period: 'period',
    totalCost: 'totalCost',
    tokenUsage: 'tokenUsage',
    requestCount: 'requestCount',
    breakdown: 'breakdown',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    userId: 'userId'
  };

  export type CostTrackingScalarFieldEnum = (typeof CostTrackingScalarFieldEnum)[keyof typeof CostTrackingScalarFieldEnum]


  export const UserBillingScalarFieldEnum: {
    id: 'id',
    billingEmail: 'billingEmail',
    plan: 'plan',
    monthlyLimit: 'monthlyLimit',
    currentUsage: 'currentUsage',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type UserBillingScalarFieldEnum = (typeof UserBillingScalarFieldEnum)[keyof typeof UserBillingScalarFieldEnum]


  export const AppIntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    baseUrl: 'baseUrl',
    apiKeyHash: 'apiKeyHash',
    syncConfig: 'syncConfig',
    isActive: 'isActive',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    createdBy: 'createdBy'
  };

  export type AppIntegrationScalarFieldEnum = (typeof AppIntegrationScalarFieldEnum)[keyof typeof AppIntegrationScalarFieldEnum]


  export const TestPipelineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    config: 'config',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    createdBy: 'createdBy'
  };

  export type TestPipelineScalarFieldEnum = (typeof TestPipelineScalarFieldEnum)[keyof typeof TestPipelineScalarFieldEnum]


  export const PipelineStageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    config: 'config',
    order: 'order',
    status: 'status',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pipelineId: 'pipelineId'
  };

  export type PipelineStageScalarFieldEnum = (typeof PipelineStageScalarFieldEnum)[keyof typeof PipelineStageScalarFieldEnum]


  export const PipelineExecutionScalarFieldEnum: {
    id: 'id',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    result: 'result',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pipelineId: 'pipelineId',
    promptId: 'promptId',
    baselinePromptId: 'baselinePromptId',
    executedBy: 'executedBy'
  };

  export type PipelineExecutionScalarFieldEnum = (typeof PipelineExecutionScalarFieldEnum)[keyof typeof PipelineExecutionScalarFieldEnum]


  export const DependencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    provider: 'provider',
    config: 'config',
    status: 'status',
    version: 'version',
    healthScore: 'healthScore',
    lastCheck: 'lastCheck',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    createdBy: 'createdBy'
  };

  export type DependencyScalarFieldEnum = (typeof DependencyScalarFieldEnum)[keyof typeof DependencyScalarFieldEnum]


  export const UpdatePlanScalarFieldEnum: {
    id: 'id',
    planData: 'planData',
    status: 'status',
    executionResult: 'executionResult',
    executedAt: 'executedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    createdBy: 'createdBy',
    executedBy: 'executedBy'
  };

  export type UpdatePlanScalarFieldEnum = (typeof UpdatePlanScalarFieldEnum)[keyof typeof UpdatePlanScalarFieldEnum]


  export const DeploymentPlanScalarFieldEnum: {
    id: 'id',
    planData: 'planData',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    promptId: 'promptId',
    createdBy: 'createdBy'
  };

  export type DeploymentPlanScalarFieldEnum = (typeof DeploymentPlanScalarFieldEnum)[keyof typeof DeploymentPlanScalarFieldEnum]


  export const DeploymentExecutionScalarFieldEnum: {
    id: 'id',
    status: 'status',
    currentStage: 'currentStage',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    metrics: 'metrics',
    error: 'error',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    planId: 'planId',
    executedBy: 'executedBy'
  };

  export type DeploymentExecutionScalarFieldEnum = (typeof DeploymentExecutionScalarFieldEnum)[keyof typeof DeploymentExecutionScalarFieldEnum]


  export const DeploymentApprovalScalarFieldEnum: {
    id: 'id',
    status: 'status',
    comments: 'comments',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    planId: 'planId',
    approvedBy: 'approvedBy'
  };

  export type DeploymentApprovalScalarFieldEnum = (typeof DeploymentApprovalScalarFieldEnum)[keyof typeof DeploymentApprovalScalarFieldEnum]


  export const ApprovalRequestScalarFieldEnum: {
    id: 'id',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    promptId: 'promptId',
    appId: 'appId',
    requestedBy: 'requestedBy',
    impactAnalysisId: 'impactAnalysisId'
  };

  export type ApprovalRequestScalarFieldEnum = (typeof ApprovalRequestScalarFieldEnum)[keyof typeof ApprovalRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projectMemberships?: ProjectMemberListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    testRuns?: TestRunListRelationFilter
    deployments?: DeploymentListRelationFilter
    deploymentActions?: DeploymentHistoryListRelationFilter
    costTracking?: CostTrackingListRelationFilter
    billing?: XOR<UserBillingNullableRelationFilter, UserBillingWhereInput> | null
    createdIntegrations?: AppIntegrationListRelationFilter
    createdPipelines?: TestPipelineListRelationFilter
    executedPipelines?: PipelineExecutionListRelationFilter
    createdDependencies?: DependencyListRelationFilter
    createdUpdatePlans?: UpdatePlanListRelationFilter
    executedUpdatePlans?: UpdatePlanListRelationFilter
    createdDeploymentPlans?: DeploymentPlanListRelationFilter
    executedDeployments?: DeploymentExecutionListRelationFilter
    deploymentApprovals?: DeploymentApprovalListRelationFilter
    requestedApprovals?: ApprovalRequestListRelationFilter
    initiatedSyncs?: SyncOperationListRelationFilter
    createdWebhooks?: WebhookSubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectMemberships?: ProjectMemberOrderByRelationAggregateInput
    ownedProjects?: ProjectOrderByRelationAggregateInput
    testRuns?: TestRunOrderByRelationAggregateInput
    deployments?: DeploymentOrderByRelationAggregateInput
    deploymentActions?: DeploymentHistoryOrderByRelationAggregateInput
    costTracking?: CostTrackingOrderByRelationAggregateInput
    billing?: UserBillingOrderByWithRelationInput
    createdIntegrations?: AppIntegrationOrderByRelationAggregateInput
    createdPipelines?: TestPipelineOrderByRelationAggregateInput
    executedPipelines?: PipelineExecutionOrderByRelationAggregateInput
    createdDependencies?: DependencyOrderByRelationAggregateInput
    createdUpdatePlans?: UpdatePlanOrderByRelationAggregateInput
    executedUpdatePlans?: UpdatePlanOrderByRelationAggregateInput
    createdDeploymentPlans?: DeploymentPlanOrderByRelationAggregateInput
    executedDeployments?: DeploymentExecutionOrderByRelationAggregateInput
    deploymentApprovals?: DeploymentApprovalOrderByRelationAggregateInput
    requestedApprovals?: ApprovalRequestOrderByRelationAggregateInput
    initiatedSyncs?: SyncOperationOrderByRelationAggregateInput
    createdWebhooks?: WebhookSubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projectMemberships?: ProjectMemberListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    testRuns?: TestRunListRelationFilter
    deployments?: DeploymentListRelationFilter
    deploymentActions?: DeploymentHistoryListRelationFilter
    costTracking?: CostTrackingListRelationFilter
    billing?: XOR<UserBillingNullableRelationFilter, UserBillingWhereInput> | null
    createdIntegrations?: AppIntegrationListRelationFilter
    createdPipelines?: TestPipelineListRelationFilter
    executedPipelines?: PipelineExecutionListRelationFilter
    createdDependencies?: DependencyListRelationFilter
    createdUpdatePlans?: UpdatePlanListRelationFilter
    executedUpdatePlans?: UpdatePlanListRelationFilter
    createdDeploymentPlans?: DeploymentPlanListRelationFilter
    executedDeployments?: DeploymentExecutionListRelationFilter
    deploymentApprovals?: DeploymentApprovalListRelationFilter
    requestedApprovals?: ApprovalRequestListRelationFilter
    initiatedSyncs?: SyncOperationListRelationFilter
    createdWebhooks?: WebhookSubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    settings?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    prompts?: PromptListRelationFilter
    testRuns?: TestRunListRelationFilter
    ApiKey?: ApiKeyListRelationFilter
    environments?: EnvironmentListRelationFilter
    costTracking?: CostTrackingListRelationFilter
    appIntegrations?: AppIntegrationListRelationFilter
    testPipelines?: TestPipelineListRelationFilter
    dependencies?: DependencyListRelationFilter
    updatePlans?: UpdatePlanListRelationFilter
    deploymentPlans?: DeploymentPlanListRelationFilter
    approvalRequests?: ApprovalRequestListRelationFilter
    syncOperations?: SyncOperationListRelationFilter
    webhookDeliveries?: WebhookDeliveryListRelationFilter
    webhookSubscriptions?: WebhookSubscriptionListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    owner?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    prompts?: PromptOrderByRelationAggregateInput
    testRuns?: TestRunOrderByRelationAggregateInput
    ApiKey?: ApiKeyOrderByRelationAggregateInput
    environments?: EnvironmentOrderByRelationAggregateInput
    costTracking?: CostTrackingOrderByRelationAggregateInput
    appIntegrations?: AppIntegrationOrderByRelationAggregateInput
    testPipelines?: TestPipelineOrderByRelationAggregateInput
    dependencies?: DependencyOrderByRelationAggregateInput
    updatePlans?: UpdatePlanOrderByRelationAggregateInput
    deploymentPlans?: DeploymentPlanOrderByRelationAggregateInput
    approvalRequests?: ApprovalRequestOrderByRelationAggregateInput
    syncOperations?: SyncOperationOrderByRelationAggregateInput
    webhookDeliveries?: WebhookDeliveryOrderByRelationAggregateInput
    webhookSubscriptions?: WebhookSubscriptionOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    settings?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    prompts?: PromptListRelationFilter
    testRuns?: TestRunListRelationFilter
    ApiKey?: ApiKeyListRelationFilter
    environments?: EnvironmentListRelationFilter
    costTracking?: CostTrackingListRelationFilter
    appIntegrations?: AppIntegrationListRelationFilter
    testPipelines?: TestPipelineListRelationFilter
    dependencies?: DependencyListRelationFilter
    updatePlans?: UpdatePlanListRelationFilter
    deploymentPlans?: DeploymentPlanListRelationFilter
    approvalRequests?: ApprovalRequestListRelationFilter
    syncOperations?: SyncOperationListRelationFilter
    webhookDeliveries?: WebhookDeliveryListRelationFilter
    webhookSubscriptions?: WebhookSubscriptionListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    settings?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Project"> | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    role?: StringFilter<"ProjectMember"> | string
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: StringWithAggregatesFilter<"ProjectMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
  }

  export type PromptWhereInput = {
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    id?: StringFilter<"Prompt"> | string
    name?: StringFilter<"Prompt"> | string
    description?: StringNullableFilter<"Prompt"> | string | null
    content?: StringFilter<"Prompt"> | string
    version?: IntFilter<"Prompt"> | number
    isArchived?: BoolFilter<"Prompt"> | boolean
    tags?: StringFilter<"Prompt"> | string
    metadata?: StringNullableFilter<"Prompt"> | string | null
    outputSchema?: StringNullableFilter<"Prompt"> | string | null
    outputFormat?: StringNullableFilter<"Prompt"> | string | null
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    projectId?: StringFilter<"Prompt"> | string
    parentId?: StringNullableFilter<"Prompt"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    parent?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    versions?: PromptListRelationFilter
    testRuns?: TestRunListRelationFilter
    deployments?: DeploymentListRelationFilter
    impactAnalysis?: ImpactAnalysisListRelationFilter
    pipelineExecutions?: PipelineExecutionListRelationFilter
    baselinePipelineExecutions?: PipelineExecutionListRelationFilter
    deploymentPlans?: DeploymentPlanListRelationFilter
    approvalRequests?: ApprovalRequestListRelationFilter
  }

  export type PromptOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    version?: SortOrder
    isArchived?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    outputSchema?: SortOrderInput | SortOrder
    outputFormat?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    parent?: PromptOrderByWithRelationInput
    versions?: PromptOrderByRelationAggregateInput
    testRuns?: TestRunOrderByRelationAggregateInput
    deployments?: DeploymentOrderByRelationAggregateInput
    impactAnalysis?: ImpactAnalysisOrderByRelationAggregateInput
    pipelineExecutions?: PipelineExecutionOrderByRelationAggregateInput
    baselinePipelineExecutions?: PipelineExecutionOrderByRelationAggregateInput
    deploymentPlans?: DeploymentPlanOrderByRelationAggregateInput
    approvalRequests?: ApprovalRequestOrderByRelationAggregateInput
  }

  export type PromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    name?: StringFilter<"Prompt"> | string
    description?: StringNullableFilter<"Prompt"> | string | null
    content?: StringFilter<"Prompt"> | string
    version?: IntFilter<"Prompt"> | number
    isArchived?: BoolFilter<"Prompt"> | boolean
    tags?: StringFilter<"Prompt"> | string
    metadata?: StringNullableFilter<"Prompt"> | string | null
    outputSchema?: StringNullableFilter<"Prompt"> | string | null
    outputFormat?: StringNullableFilter<"Prompt"> | string | null
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    projectId?: StringFilter<"Prompt"> | string
    parentId?: StringNullableFilter<"Prompt"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    parent?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    versions?: PromptListRelationFilter
    testRuns?: TestRunListRelationFilter
    deployments?: DeploymentListRelationFilter
    impactAnalysis?: ImpactAnalysisListRelationFilter
    pipelineExecutions?: PipelineExecutionListRelationFilter
    baselinePipelineExecutions?: PipelineExecutionListRelationFilter
    deploymentPlans?: DeploymentPlanListRelationFilter
    approvalRequests?: ApprovalRequestListRelationFilter
  }, "id">

  export type PromptOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    version?: SortOrder
    isArchived?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    outputSchema?: SortOrderInput | SortOrder
    outputFormat?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: PromptCountOrderByAggregateInput
    _avg?: PromptAvgOrderByAggregateInput
    _max?: PromptMaxOrderByAggregateInput
    _min?: PromptMinOrderByAggregateInput
    _sum?: PromptSumOrderByAggregateInput
  }

  export type PromptScalarWhereWithAggregatesInput = {
    AND?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    OR?: PromptScalarWhereWithAggregatesInput[]
    NOT?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prompt"> | string
    name?: StringWithAggregatesFilter<"Prompt"> | string
    description?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    content?: StringWithAggregatesFilter<"Prompt"> | string
    version?: IntWithAggregatesFilter<"Prompt"> | number
    isArchived?: BoolWithAggregatesFilter<"Prompt"> | boolean
    tags?: StringWithAggregatesFilter<"Prompt"> | string
    metadata?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    outputSchema?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    outputFormat?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    projectId?: StringWithAggregatesFilter<"Prompt"> | string
    parentId?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
  }

  export type TestRunWhereInput = {
    AND?: TestRunWhereInput | TestRunWhereInput[]
    OR?: TestRunWhereInput[]
    NOT?: TestRunWhereInput | TestRunWhereInput[]
    id?: StringFilter<"TestRun"> | string
    name?: StringFilter<"TestRun"> | string
    description?: StringNullableFilter<"TestRun"> | string | null
    status?: StringFilter<"TestRun"> | string
    config?: StringFilter<"TestRun"> | string
    metadata?: StringNullableFilter<"TestRun"> | string | null
    startedAt?: DateTimeNullableFilter<"TestRun"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestRun"> | Date | string | null
    createdAt?: DateTimeFilter<"TestRun"> | Date | string
    updatedAt?: DateTimeFilter<"TestRun"> | Date | string
    projectId?: StringFilter<"TestRun"> | string
    userId?: StringFilter<"TestRun"> | string
    promptId?: StringFilter<"TestRun"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    responses?: TestResponseListRelationFilter
    metrics?: TestMetricListRelationFilter
  }

  export type TestRunOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    responses?: TestResponseOrderByRelationAggregateInput
    metrics?: TestMetricOrderByRelationAggregateInput
  }

  export type TestRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestRunWhereInput | TestRunWhereInput[]
    OR?: TestRunWhereInput[]
    NOT?: TestRunWhereInput | TestRunWhereInput[]
    name?: StringFilter<"TestRun"> | string
    description?: StringNullableFilter<"TestRun"> | string | null
    status?: StringFilter<"TestRun"> | string
    config?: StringFilter<"TestRun"> | string
    metadata?: StringNullableFilter<"TestRun"> | string | null
    startedAt?: DateTimeNullableFilter<"TestRun"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestRun"> | Date | string | null
    createdAt?: DateTimeFilter<"TestRun"> | Date | string
    updatedAt?: DateTimeFilter<"TestRun"> | Date | string
    projectId?: StringFilter<"TestRun"> | string
    userId?: StringFilter<"TestRun"> | string
    promptId?: StringFilter<"TestRun"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    responses?: TestResponseListRelationFilter
    metrics?: TestMetricListRelationFilter
  }, "id">

  export type TestRunOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
    _count?: TestRunCountOrderByAggregateInput
    _max?: TestRunMaxOrderByAggregateInput
    _min?: TestRunMinOrderByAggregateInput
  }

  export type TestRunScalarWhereWithAggregatesInput = {
    AND?: TestRunScalarWhereWithAggregatesInput | TestRunScalarWhereWithAggregatesInput[]
    OR?: TestRunScalarWhereWithAggregatesInput[]
    NOT?: TestRunScalarWhereWithAggregatesInput | TestRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestRun"> | string
    name?: StringWithAggregatesFilter<"TestRun"> | string
    description?: StringNullableWithAggregatesFilter<"TestRun"> | string | null
    status?: StringWithAggregatesFilter<"TestRun"> | string
    config?: StringWithAggregatesFilter<"TestRun"> | string
    metadata?: StringNullableWithAggregatesFilter<"TestRun"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"TestRun"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TestRun"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestRun"> | Date | string
    projectId?: StringWithAggregatesFilter<"TestRun"> | string
    userId?: StringWithAggregatesFilter<"TestRun"> | string
    promptId?: StringWithAggregatesFilter<"TestRun"> | string
  }

  export type TestResponseWhereInput = {
    AND?: TestResponseWhereInput | TestResponseWhereInput[]
    OR?: TestResponseWhereInput[]
    NOT?: TestResponseWhereInput | TestResponseWhereInput[]
    id?: StringFilter<"TestResponse"> | string
    modelProvider?: StringFilter<"TestResponse"> | string
    modelName?: StringFilter<"TestResponse"> | string
    input?: StringFilter<"TestResponse"> | string
    output?: StringFilter<"TestResponse"> | string
    parsedOutput?: StringNullableFilter<"TestResponse"> | string | null
    outputStructure?: StringNullableFilter<"TestResponse"> | string | null
    tokenUsage?: StringNullableFilter<"TestResponse"> | string | null
    latencyMs?: IntNullableFilter<"TestResponse"> | number | null
    cost?: FloatNullableFilter<"TestResponse"> | number | null
    error?: StringNullableFilter<"TestResponse"> | string | null
    rawResponse?: StringNullableFilter<"TestResponse"> | string | null
    evaluationData?: StringNullableFilter<"TestResponse"> | string | null
    createdAt?: DateTimeFilter<"TestResponse"> | Date | string
    testRunId?: StringFilter<"TestResponse"> | string
    testRun?: XOR<TestRunRelationFilter, TestRunWhereInput>
  }

  export type TestResponseOrderByWithRelationInput = {
    id?: SortOrder
    modelProvider?: SortOrder
    modelName?: SortOrder
    input?: SortOrder
    output?: SortOrder
    parsedOutput?: SortOrderInput | SortOrder
    outputStructure?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    rawResponse?: SortOrderInput | SortOrder
    evaluationData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
    testRun?: TestRunOrderByWithRelationInput
  }

  export type TestResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestResponseWhereInput | TestResponseWhereInput[]
    OR?: TestResponseWhereInput[]
    NOT?: TestResponseWhereInput | TestResponseWhereInput[]
    modelProvider?: StringFilter<"TestResponse"> | string
    modelName?: StringFilter<"TestResponse"> | string
    input?: StringFilter<"TestResponse"> | string
    output?: StringFilter<"TestResponse"> | string
    parsedOutput?: StringNullableFilter<"TestResponse"> | string | null
    outputStructure?: StringNullableFilter<"TestResponse"> | string | null
    tokenUsage?: StringNullableFilter<"TestResponse"> | string | null
    latencyMs?: IntNullableFilter<"TestResponse"> | number | null
    cost?: FloatNullableFilter<"TestResponse"> | number | null
    error?: StringNullableFilter<"TestResponse"> | string | null
    rawResponse?: StringNullableFilter<"TestResponse"> | string | null
    evaluationData?: StringNullableFilter<"TestResponse"> | string | null
    createdAt?: DateTimeFilter<"TestResponse"> | Date | string
    testRunId?: StringFilter<"TestResponse"> | string
    testRun?: XOR<TestRunRelationFilter, TestRunWhereInput>
  }, "id">

  export type TestResponseOrderByWithAggregationInput = {
    id?: SortOrder
    modelProvider?: SortOrder
    modelName?: SortOrder
    input?: SortOrder
    output?: SortOrder
    parsedOutput?: SortOrderInput | SortOrder
    outputStructure?: SortOrderInput | SortOrder
    tokenUsage?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    rawResponse?: SortOrderInput | SortOrder
    evaluationData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
    _count?: TestResponseCountOrderByAggregateInput
    _avg?: TestResponseAvgOrderByAggregateInput
    _max?: TestResponseMaxOrderByAggregateInput
    _min?: TestResponseMinOrderByAggregateInput
    _sum?: TestResponseSumOrderByAggregateInput
  }

  export type TestResponseScalarWhereWithAggregatesInput = {
    AND?: TestResponseScalarWhereWithAggregatesInput | TestResponseScalarWhereWithAggregatesInput[]
    OR?: TestResponseScalarWhereWithAggregatesInput[]
    NOT?: TestResponseScalarWhereWithAggregatesInput | TestResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestResponse"> | string
    modelProvider?: StringWithAggregatesFilter<"TestResponse"> | string
    modelName?: StringWithAggregatesFilter<"TestResponse"> | string
    input?: StringWithAggregatesFilter<"TestResponse"> | string
    output?: StringWithAggregatesFilter<"TestResponse"> | string
    parsedOutput?: StringNullableWithAggregatesFilter<"TestResponse"> | string | null
    outputStructure?: StringNullableWithAggregatesFilter<"TestResponse"> | string | null
    tokenUsage?: StringNullableWithAggregatesFilter<"TestResponse"> | string | null
    latencyMs?: IntNullableWithAggregatesFilter<"TestResponse"> | number | null
    cost?: FloatNullableWithAggregatesFilter<"TestResponse"> | number | null
    error?: StringNullableWithAggregatesFilter<"TestResponse"> | string | null
    rawResponse?: StringNullableWithAggregatesFilter<"TestResponse"> | string | null
    evaluationData?: StringNullableWithAggregatesFilter<"TestResponse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestResponse"> | Date | string
    testRunId?: StringWithAggregatesFilter<"TestResponse"> | string
  }

  export type TestMetricWhereInput = {
    AND?: TestMetricWhereInput | TestMetricWhereInput[]
    OR?: TestMetricWhereInput[]
    NOT?: TestMetricWhereInput | TestMetricWhereInput[]
    id?: StringFilter<"TestMetric"> | string
    name?: StringFilter<"TestMetric"> | string
    value?: FloatFilter<"TestMetric"> | number
    unit?: StringNullableFilter<"TestMetric"> | string | null
    metadata?: StringNullableFilter<"TestMetric"> | string | null
    createdAt?: DateTimeFilter<"TestMetric"> | Date | string
    testRunId?: StringFilter<"TestMetric"> | string
    testRun?: XOR<TestRunRelationFilter, TestRunWhereInput>
  }

  export type TestMetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
    testRun?: TestRunOrderByWithRelationInput
  }

  export type TestMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestMetricWhereInput | TestMetricWhereInput[]
    OR?: TestMetricWhereInput[]
    NOT?: TestMetricWhereInput | TestMetricWhereInput[]
    name?: StringFilter<"TestMetric"> | string
    value?: FloatFilter<"TestMetric"> | number
    unit?: StringNullableFilter<"TestMetric"> | string | null
    metadata?: StringNullableFilter<"TestMetric"> | string | null
    createdAt?: DateTimeFilter<"TestMetric"> | Date | string
    testRunId?: StringFilter<"TestMetric"> | string
    testRun?: XOR<TestRunRelationFilter, TestRunWhereInput>
  }, "id">

  export type TestMetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
    _count?: TestMetricCountOrderByAggregateInput
    _avg?: TestMetricAvgOrderByAggregateInput
    _max?: TestMetricMaxOrderByAggregateInput
    _min?: TestMetricMinOrderByAggregateInput
    _sum?: TestMetricSumOrderByAggregateInput
  }

  export type TestMetricScalarWhereWithAggregatesInput = {
    AND?: TestMetricScalarWhereWithAggregatesInput | TestMetricScalarWhereWithAggregatesInput[]
    OR?: TestMetricScalarWhereWithAggregatesInput[]
    NOT?: TestMetricScalarWhereWithAggregatesInput | TestMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestMetric"> | string
    name?: StringWithAggregatesFilter<"TestMetric"> | string
    value?: FloatWithAggregatesFilter<"TestMetric"> | number
    unit?: StringNullableWithAggregatesFilter<"TestMetric"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"TestMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TestMetric"> | Date | string
    testRunId?: StringWithAggregatesFilter<"TestMetric"> | string
  }

  export type EvaluationPluginWhereInput = {
    AND?: EvaluationPluginWhereInput | EvaluationPluginWhereInput[]
    OR?: EvaluationPluginWhereInput[]
    NOT?: EvaluationPluginWhereInput | EvaluationPluginWhereInput[]
    id?: StringFilter<"EvaluationPlugin"> | string
    name?: StringFilter<"EvaluationPlugin"> | string
    version?: StringFilter<"EvaluationPlugin"> | string
    description?: StringNullableFilter<"EvaluationPlugin"> | string | null
    config?: StringFilter<"EvaluationPlugin"> | string
    code?: StringNullableFilter<"EvaluationPlugin"> | string | null
    isActive?: BoolFilter<"EvaluationPlugin"> | boolean
    createdAt?: DateTimeFilter<"EvaluationPlugin"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationPlugin"> | Date | string
  }

  export type EvaluationPluginOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationPluginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EvaluationPluginWhereInput | EvaluationPluginWhereInput[]
    OR?: EvaluationPluginWhereInput[]
    NOT?: EvaluationPluginWhereInput | EvaluationPluginWhereInput[]
    version?: StringFilter<"EvaluationPlugin"> | string
    description?: StringNullableFilter<"EvaluationPlugin"> | string | null
    config?: StringFilter<"EvaluationPlugin"> | string
    code?: StringNullableFilter<"EvaluationPlugin"> | string | null
    isActive?: BoolFilter<"EvaluationPlugin"> | boolean
    createdAt?: DateTimeFilter<"EvaluationPlugin"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationPlugin"> | Date | string
  }, "id" | "name">

  export type EvaluationPluginOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationPluginCountOrderByAggregateInput
    _max?: EvaluationPluginMaxOrderByAggregateInput
    _min?: EvaluationPluginMinOrderByAggregateInput
  }

  export type EvaluationPluginScalarWhereWithAggregatesInput = {
    AND?: EvaluationPluginScalarWhereWithAggregatesInput | EvaluationPluginScalarWhereWithAggregatesInput[]
    OR?: EvaluationPluginScalarWhereWithAggregatesInput[]
    NOT?: EvaluationPluginScalarWhereWithAggregatesInput | EvaluationPluginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationPlugin"> | string
    name?: StringWithAggregatesFilter<"EvaluationPlugin"> | string
    version?: StringWithAggregatesFilter<"EvaluationPlugin"> | string
    description?: StringNullableWithAggregatesFilter<"EvaluationPlugin"> | string | null
    config?: StringWithAggregatesFilter<"EvaluationPlugin"> | string
    code?: StringNullableWithAggregatesFilter<"EvaluationPlugin"> | string | null
    isActive?: BoolWithAggregatesFilter<"EvaluationPlugin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationPlugin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvaluationPlugin"> | Date | string
  }

  export type QueueJobWhereInput = {
    AND?: QueueJobWhereInput | QueueJobWhereInput[]
    OR?: QueueJobWhereInput[]
    NOT?: QueueJobWhereInput | QueueJobWhereInput[]
    id?: StringFilter<"QueueJob"> | string
    type?: StringFilter<"QueueJob"> | string
    data?: StringFilter<"QueueJob"> | string
    priority?: IntFilter<"QueueJob"> | number
    attempts?: IntFilter<"QueueJob"> | number
    maxAttempts?: IntFilter<"QueueJob"> | number
    status?: StringFilter<"QueueJob"> | string
    error?: StringNullableFilter<"QueueJob"> | string | null
    metadata?: StringNullableFilter<"QueueJob"> | string | null
    createdAt?: DateTimeFilter<"QueueJob"> | Date | string
    updatedAt?: DateTimeFilter<"QueueJob"> | Date | string
    processedAt?: DateTimeNullableFilter<"QueueJob"> | Date | string | null
  }

  export type QueueJobOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
  }

  export type QueueJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueueJobWhereInput | QueueJobWhereInput[]
    OR?: QueueJobWhereInput[]
    NOT?: QueueJobWhereInput | QueueJobWhereInput[]
    type?: StringFilter<"QueueJob"> | string
    data?: StringFilter<"QueueJob"> | string
    priority?: IntFilter<"QueueJob"> | number
    attempts?: IntFilter<"QueueJob"> | number
    maxAttempts?: IntFilter<"QueueJob"> | number
    status?: StringFilter<"QueueJob"> | string
    error?: StringNullableFilter<"QueueJob"> | string | null
    metadata?: StringNullableFilter<"QueueJob"> | string | null
    createdAt?: DateTimeFilter<"QueueJob"> | Date | string
    updatedAt?: DateTimeFilter<"QueueJob"> | Date | string
    processedAt?: DateTimeNullableFilter<"QueueJob"> | Date | string | null
  }, "id">

  export type QueueJobOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: QueueJobCountOrderByAggregateInput
    _avg?: QueueJobAvgOrderByAggregateInput
    _max?: QueueJobMaxOrderByAggregateInput
    _min?: QueueJobMinOrderByAggregateInput
    _sum?: QueueJobSumOrderByAggregateInput
  }

  export type QueueJobScalarWhereWithAggregatesInput = {
    AND?: QueueJobScalarWhereWithAggregatesInput | QueueJobScalarWhereWithAggregatesInput[]
    OR?: QueueJobScalarWhereWithAggregatesInput[]
    NOT?: QueueJobScalarWhereWithAggregatesInput | QueueJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QueueJob"> | string
    type?: StringWithAggregatesFilter<"QueueJob"> | string
    data?: StringWithAggregatesFilter<"QueueJob"> | string
    priority?: IntWithAggregatesFilter<"QueueJob"> | number
    attempts?: IntWithAggregatesFilter<"QueueJob"> | number
    maxAttempts?: IntWithAggregatesFilter<"QueueJob"> | number
    status?: StringWithAggregatesFilter<"QueueJob"> | string
    error?: StringNullableWithAggregatesFilter<"QueueJob"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"QueueJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QueueJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QueueJob"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"QueueJob"> | Date | string | null
  }

  export type RecurringJobWhereInput = {
    AND?: RecurringJobWhereInput | RecurringJobWhereInput[]
    OR?: RecurringJobWhereInput[]
    NOT?: RecurringJobWhereInput | RecurringJobWhereInput[]
    id?: StringFilter<"RecurringJob"> | string
    type?: StringFilter<"RecurringJob"> | string
    data?: StringFilter<"RecurringJob"> | string
    interval?: IntFilter<"RecurringJob"> | number
    priority?: IntFilter<"RecurringJob"> | number
    enabled?: BoolFilter<"RecurringJob"> | boolean
    nextRun?: DateTimeFilter<"RecurringJob"> | Date | string
    lastRun?: DateTimeNullableFilter<"RecurringJob"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringJob"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringJob"> | Date | string
  }

  export type RecurringJobOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    interval?: SortOrder
    priority?: SortOrder
    enabled?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringJobWhereInput | RecurringJobWhereInput[]
    OR?: RecurringJobWhereInput[]
    NOT?: RecurringJobWhereInput | RecurringJobWhereInput[]
    type?: StringFilter<"RecurringJob"> | string
    data?: StringFilter<"RecurringJob"> | string
    interval?: IntFilter<"RecurringJob"> | number
    priority?: IntFilter<"RecurringJob"> | number
    enabled?: BoolFilter<"RecurringJob"> | boolean
    nextRun?: DateTimeFilter<"RecurringJob"> | Date | string
    lastRun?: DateTimeNullableFilter<"RecurringJob"> | Date | string | null
    createdAt?: DateTimeFilter<"RecurringJob"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringJob"> | Date | string
  }, "id">

  export type RecurringJobOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    interval?: SortOrder
    priority?: SortOrder
    enabled?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringJobCountOrderByAggregateInput
    _avg?: RecurringJobAvgOrderByAggregateInput
    _max?: RecurringJobMaxOrderByAggregateInput
    _min?: RecurringJobMinOrderByAggregateInput
    _sum?: RecurringJobSumOrderByAggregateInput
  }

  export type RecurringJobScalarWhereWithAggregatesInput = {
    AND?: RecurringJobScalarWhereWithAggregatesInput | RecurringJobScalarWhereWithAggregatesInput[]
    OR?: RecurringJobScalarWhereWithAggregatesInput[]
    NOT?: RecurringJobScalarWhereWithAggregatesInput | RecurringJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringJob"> | string
    type?: StringWithAggregatesFilter<"RecurringJob"> | string
    data?: StringWithAggregatesFilter<"RecurringJob"> | string
    interval?: IntWithAggregatesFilter<"RecurringJob"> | number
    priority?: IntWithAggregatesFilter<"RecurringJob"> | number
    enabled?: BoolWithAggregatesFilter<"RecurringJob"> | boolean
    nextRun?: DateTimeWithAggregatesFilter<"RecurringJob"> | Date | string
    lastRun?: DateTimeNullableWithAggregatesFilter<"RecurringJob"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RecurringJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringJob"> | Date | string
  }

  export type SyncOperationWhereInput = {
    AND?: SyncOperationWhereInput | SyncOperationWhereInput[]
    OR?: SyncOperationWhereInput[]
    NOT?: SyncOperationWhereInput | SyncOperationWhereInput[]
    id?: StringFilter<"SyncOperation"> | string
    direction?: StringFilter<"SyncOperation"> | string
    strategy?: StringFilter<"SyncOperation"> | string
    status?: StringFilter<"SyncOperation"> | string
    progress?: StringFilter<"SyncOperation"> | string
    result?: StringNullableFilter<"SyncOperation"> | string | null
    error?: StringNullableFilter<"SyncOperation"> | string | null
    config?: StringFilter<"SyncOperation"> | string
    startedAt?: DateTimeNullableFilter<"SyncOperation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SyncOperation"> | Date | string | null
    createdAt?: DateTimeFilter<"SyncOperation"> | Date | string
    updatedAt?: DateTimeFilter<"SyncOperation"> | Date | string
    projectId?: StringFilter<"SyncOperation"> | string
    connectionId?: StringFilter<"SyncOperation"> | string
    initiatedBy?: StringFilter<"SyncOperation"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    connection?: XOR<AppIntegrationRelationFilter, AppIntegrationWhereInput>
    initiator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SyncOperationOrderByWithRelationInput = {
    id?: SortOrder
    direction?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    config?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    connectionId?: SortOrder
    initiatedBy?: SortOrder
    project?: ProjectOrderByWithRelationInput
    connection?: AppIntegrationOrderByWithRelationInput
    initiator?: UserOrderByWithRelationInput
  }

  export type SyncOperationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncOperationWhereInput | SyncOperationWhereInput[]
    OR?: SyncOperationWhereInput[]
    NOT?: SyncOperationWhereInput | SyncOperationWhereInput[]
    direction?: StringFilter<"SyncOperation"> | string
    strategy?: StringFilter<"SyncOperation"> | string
    status?: StringFilter<"SyncOperation"> | string
    progress?: StringFilter<"SyncOperation"> | string
    result?: StringNullableFilter<"SyncOperation"> | string | null
    error?: StringNullableFilter<"SyncOperation"> | string | null
    config?: StringFilter<"SyncOperation"> | string
    startedAt?: DateTimeNullableFilter<"SyncOperation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SyncOperation"> | Date | string | null
    createdAt?: DateTimeFilter<"SyncOperation"> | Date | string
    updatedAt?: DateTimeFilter<"SyncOperation"> | Date | string
    projectId?: StringFilter<"SyncOperation"> | string
    connectionId?: StringFilter<"SyncOperation"> | string
    initiatedBy?: StringFilter<"SyncOperation"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    connection?: XOR<AppIntegrationRelationFilter, AppIntegrationWhereInput>
    initiator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SyncOperationOrderByWithAggregationInput = {
    id?: SortOrder
    direction?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    config?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    connectionId?: SortOrder
    initiatedBy?: SortOrder
    _count?: SyncOperationCountOrderByAggregateInput
    _max?: SyncOperationMaxOrderByAggregateInput
    _min?: SyncOperationMinOrderByAggregateInput
  }

  export type SyncOperationScalarWhereWithAggregatesInput = {
    AND?: SyncOperationScalarWhereWithAggregatesInput | SyncOperationScalarWhereWithAggregatesInput[]
    OR?: SyncOperationScalarWhereWithAggregatesInput[]
    NOT?: SyncOperationScalarWhereWithAggregatesInput | SyncOperationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncOperation"> | string
    direction?: StringWithAggregatesFilter<"SyncOperation"> | string
    strategy?: StringWithAggregatesFilter<"SyncOperation"> | string
    status?: StringWithAggregatesFilter<"SyncOperation"> | string
    progress?: StringWithAggregatesFilter<"SyncOperation"> | string
    result?: StringNullableWithAggregatesFilter<"SyncOperation"> | string | null
    error?: StringNullableWithAggregatesFilter<"SyncOperation"> | string | null
    config?: StringWithAggregatesFilter<"SyncOperation"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"SyncOperation"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncOperation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncOperation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SyncOperation"> | Date | string
    projectId?: StringWithAggregatesFilter<"SyncOperation"> | string
    connectionId?: StringWithAggregatesFilter<"SyncOperation"> | string
    initiatedBy?: StringWithAggregatesFilter<"SyncOperation"> | string
  }

  export type WebhookSubscriptionWhereInput = {
    AND?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    OR?: WebhookSubscriptionWhereInput[]
    NOT?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    id?: StringFilter<"WebhookSubscription"> | string
    url?: StringFilter<"WebhookSubscription"> | string
    events?: StringFilter<"WebhookSubscription"> | string
    headers?: StringFilter<"WebhookSubscription"> | string
    secret?: StringNullableFilter<"WebhookSubscription"> | string | null
    enabled?: BoolFilter<"WebhookSubscription"> | boolean
    retryAttempts?: IntFilter<"WebhookSubscription"> | number
    lastDelivery?: DateTimeNullableFilter<"WebhookSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    projectId?: StringNullableFilter<"WebhookSubscription"> | string | null
    createdBy?: StringFilter<"WebhookSubscription"> | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
    failedDeliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    events?: SortOrder
    headers?: SortOrder
    secret?: SortOrderInput | SortOrder
    enabled?: SortOrder
    retryAttempts?: SortOrder
    lastDelivery?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
    failedDeliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    OR?: WebhookSubscriptionWhereInput[]
    NOT?: WebhookSubscriptionWhereInput | WebhookSubscriptionWhereInput[]
    url?: StringFilter<"WebhookSubscription"> | string
    events?: StringFilter<"WebhookSubscription"> | string
    headers?: StringFilter<"WebhookSubscription"> | string
    secret?: StringNullableFilter<"WebhookSubscription"> | string | null
    enabled?: BoolFilter<"WebhookSubscription"> | boolean
    retryAttempts?: IntFilter<"WebhookSubscription"> | number
    lastDelivery?: DateTimeNullableFilter<"WebhookSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    projectId?: StringNullableFilter<"WebhookSubscription"> | string | null
    createdBy?: StringFilter<"WebhookSubscription"> | string
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    deliveries?: WebhookDeliveryListRelationFilter
    failedDeliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    events?: SortOrder
    headers?: SortOrder
    secret?: SortOrderInput | SortOrder
    enabled?: SortOrder
    retryAttempts?: SortOrder
    lastDelivery?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    _count?: WebhookSubscriptionCountOrderByAggregateInput
    _avg?: WebhookSubscriptionAvgOrderByAggregateInput
    _max?: WebhookSubscriptionMaxOrderByAggregateInput
    _min?: WebhookSubscriptionMinOrderByAggregateInput
    _sum?: WebhookSubscriptionSumOrderByAggregateInput
  }

  export type WebhookSubscriptionScalarWhereWithAggregatesInput = {
    AND?: WebhookSubscriptionScalarWhereWithAggregatesInput | WebhookSubscriptionScalarWhereWithAggregatesInput[]
    OR?: WebhookSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: WebhookSubscriptionScalarWhereWithAggregatesInput | WebhookSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookSubscription"> | string
    url?: StringWithAggregatesFilter<"WebhookSubscription"> | string
    events?: StringWithAggregatesFilter<"WebhookSubscription"> | string
    headers?: StringWithAggregatesFilter<"WebhookSubscription"> | string
    secret?: StringNullableWithAggregatesFilter<"WebhookSubscription"> | string | null
    enabled?: BoolWithAggregatesFilter<"WebhookSubscription"> | boolean
    retryAttempts?: IntWithAggregatesFilter<"WebhookSubscription"> | number
    lastDelivery?: DateTimeNullableWithAggregatesFilter<"WebhookSubscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookSubscription"> | Date | string
    projectId?: StringNullableWithAggregatesFilter<"WebhookSubscription"> | string | null
    createdBy?: StringWithAggregatesFilter<"WebhookSubscription"> | string
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    url?: StringFilter<"WebhookDelivery"> | string
    payload?: StringFilter<"WebhookDelivery"> | string
    headers?: StringNullableFilter<"WebhookDelivery"> | string | null
    status?: StringFilter<"WebhookDelivery"> | string
    attempts?: IntFilter<"WebhookDelivery"> | number
    maxAttempts?: IntFilter<"WebhookDelivery"> | number
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    eventType?: StringFilter<"WebhookDelivery"> | string
    projectId?: StringNullableFilter<"WebhookDelivery"> | string | null
    webhookId?: StringNullableFilter<"WebhookDelivery"> | string | null
    failedWebhookId?: StringNullableFilter<"WebhookDelivery"> | string | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    webhook?: XOR<WebhookSubscriptionNullableRelationFilter, WebhookSubscriptionWhereInput> | null
    failedWebhook?: XOR<WebhookSubscriptionNullableRelationFilter, WebhookSubscriptionWhereInput> | null
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    payload?: SortOrder
    headers?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventType?: SortOrder
    projectId?: SortOrderInput | SortOrder
    webhookId?: SortOrderInput | SortOrder
    failedWebhookId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    webhook?: WebhookSubscriptionOrderByWithRelationInput
    failedWebhook?: WebhookSubscriptionOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    url?: StringFilter<"WebhookDelivery"> | string
    payload?: StringFilter<"WebhookDelivery"> | string
    headers?: StringNullableFilter<"WebhookDelivery"> | string | null
    status?: StringFilter<"WebhookDelivery"> | string
    attempts?: IntFilter<"WebhookDelivery"> | number
    maxAttempts?: IntFilter<"WebhookDelivery"> | number
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    eventType?: StringFilter<"WebhookDelivery"> | string
    projectId?: StringNullableFilter<"WebhookDelivery"> | string | null
    webhookId?: StringNullableFilter<"WebhookDelivery"> | string | null
    failedWebhookId?: StringNullableFilter<"WebhookDelivery"> | string | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    webhook?: XOR<WebhookSubscriptionNullableRelationFilter, WebhookSubscriptionWhereInput> | null
    failedWebhook?: XOR<WebhookSubscriptionNullableRelationFilter, WebhookSubscriptionWhereInput> | null
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    payload?: SortOrder
    headers?: SortOrderInput | SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventType?: SortOrder
    projectId?: SortOrderInput | SortOrder
    webhookId?: SortOrderInput | SortOrder
    failedWebhookId?: SortOrderInput | SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    url?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    payload?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    headers?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    status?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    attempts?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    maxAttempts?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    response?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    error?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
    eventType?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    projectId?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    webhookId?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    failedWebhookId?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    provider?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    isActive?: BoolFilter<"ApiKey"> | boolean
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    projectId?: StringFilter<"ApiKey"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    name?: StringFilter<"ApiKey"> | string
    provider?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    isActive?: BoolFilter<"ApiKey"> | boolean
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    projectId?: StringFilter<"ApiKey"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    provider?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    lastUsed?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    usageCount?: IntWithAggregatesFilter<"ApiKey"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    projectId?: StringWithAggregatesFilter<"ApiKey"> | string
  }

  export type EnvironmentWhereInput = {
    AND?: EnvironmentWhereInput | EnvironmentWhereInput[]
    OR?: EnvironmentWhereInput[]
    NOT?: EnvironmentWhereInput | EnvironmentWhereInput[]
    id?: StringFilter<"Environment"> | string
    name?: StringFilter<"Environment"> | string
    type?: StringFilter<"Environment"> | string
    description?: StringNullableFilter<"Environment"> | string | null
    config?: StringNullableFilter<"Environment"> | string | null
    isActive?: BoolFilter<"Environment"> | boolean
    createdAt?: DateTimeFilter<"Environment"> | Date | string
    updatedAt?: DateTimeFilter<"Environment"> | Date | string
    projectId?: StringFilter<"Environment"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    deployments?: DeploymentListRelationFilter
  }

  export type EnvironmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    deployments?: DeploymentOrderByRelationAggregateInput
  }

  export type EnvironmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name?: EnvironmentProjectIdNameCompoundUniqueInput
    AND?: EnvironmentWhereInput | EnvironmentWhereInput[]
    OR?: EnvironmentWhereInput[]
    NOT?: EnvironmentWhereInput | EnvironmentWhereInput[]
    name?: StringFilter<"Environment"> | string
    type?: StringFilter<"Environment"> | string
    description?: StringNullableFilter<"Environment"> | string | null
    config?: StringNullableFilter<"Environment"> | string | null
    isActive?: BoolFilter<"Environment"> | boolean
    createdAt?: DateTimeFilter<"Environment"> | Date | string
    updatedAt?: DateTimeFilter<"Environment"> | Date | string
    projectId?: StringFilter<"Environment"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    deployments?: DeploymentListRelationFilter
  }, "id" | "projectId_name">

  export type EnvironmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: EnvironmentCountOrderByAggregateInput
    _max?: EnvironmentMaxOrderByAggregateInput
    _min?: EnvironmentMinOrderByAggregateInput
  }

  export type EnvironmentScalarWhereWithAggregatesInput = {
    AND?: EnvironmentScalarWhereWithAggregatesInput | EnvironmentScalarWhereWithAggregatesInput[]
    OR?: EnvironmentScalarWhereWithAggregatesInput[]
    NOT?: EnvironmentScalarWhereWithAggregatesInput | EnvironmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Environment"> | string
    name?: StringWithAggregatesFilter<"Environment"> | string
    type?: StringWithAggregatesFilter<"Environment"> | string
    description?: StringNullableWithAggregatesFilter<"Environment"> | string | null
    config?: StringNullableWithAggregatesFilter<"Environment"> | string | null
    isActive?: BoolWithAggregatesFilter<"Environment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Environment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Environment"> | Date | string
    projectId?: StringWithAggregatesFilter<"Environment"> | string
  }

  export type DeploymentWhereInput = {
    AND?: DeploymentWhereInput | DeploymentWhereInput[]
    OR?: DeploymentWhereInput[]
    NOT?: DeploymentWhereInput | DeploymentWhereInput[]
    id?: StringFilter<"Deployment"> | string
    version?: StringFilter<"Deployment"> | string
    status?: StringFilter<"Deployment"> | string
    deployedUrl?: StringNullableFilter<"Deployment"> | string | null
    config?: StringNullableFilter<"Deployment"> | string | null
    metadata?: StringNullableFilter<"Deployment"> | string | null
    deployedAt?: DateTimeNullableFilter<"Deployment"> | Date | string | null
    rollbackAt?: DateTimeNullableFilter<"Deployment"> | Date | string | null
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    promptId?: StringFilter<"Deployment"> | string
    environmentId?: StringFilter<"Deployment"> | string
    deployedBy?: StringFilter<"Deployment"> | string
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    environment?: XOR<EnvironmentRelationFilter, EnvironmentWhereInput>
    deployedByUser?: XOR<UserRelationFilter, UserWhereInput>
    history?: DeploymentHistoryListRelationFilter
    impactAnalysis?: ImpactAnalysisListRelationFilter
  }

  export type DeploymentOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    status?: SortOrder
    deployedUrl?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    deployedAt?: SortOrderInput | SortOrder
    rollbackAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    promptId?: SortOrder
    environmentId?: SortOrder
    deployedBy?: SortOrder
    prompt?: PromptOrderByWithRelationInput
    environment?: EnvironmentOrderByWithRelationInput
    deployedByUser?: UserOrderByWithRelationInput
    history?: DeploymentHistoryOrderByRelationAggregateInput
    impactAnalysis?: ImpactAnalysisOrderByRelationAggregateInput
  }

  export type DeploymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentWhereInput | DeploymentWhereInput[]
    OR?: DeploymentWhereInput[]
    NOT?: DeploymentWhereInput | DeploymentWhereInput[]
    version?: StringFilter<"Deployment"> | string
    status?: StringFilter<"Deployment"> | string
    deployedUrl?: StringNullableFilter<"Deployment"> | string | null
    config?: StringNullableFilter<"Deployment"> | string | null
    metadata?: StringNullableFilter<"Deployment"> | string | null
    deployedAt?: DateTimeNullableFilter<"Deployment"> | Date | string | null
    rollbackAt?: DateTimeNullableFilter<"Deployment"> | Date | string | null
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    promptId?: StringFilter<"Deployment"> | string
    environmentId?: StringFilter<"Deployment"> | string
    deployedBy?: StringFilter<"Deployment"> | string
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    environment?: XOR<EnvironmentRelationFilter, EnvironmentWhereInput>
    deployedByUser?: XOR<UserRelationFilter, UserWhereInput>
    history?: DeploymentHistoryListRelationFilter
    impactAnalysis?: ImpactAnalysisListRelationFilter
  }, "id">

  export type DeploymentOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    status?: SortOrder
    deployedUrl?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    deployedAt?: SortOrderInput | SortOrder
    rollbackAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    promptId?: SortOrder
    environmentId?: SortOrder
    deployedBy?: SortOrder
    _count?: DeploymentCountOrderByAggregateInput
    _max?: DeploymentMaxOrderByAggregateInput
    _min?: DeploymentMinOrderByAggregateInput
  }

  export type DeploymentScalarWhereWithAggregatesInput = {
    AND?: DeploymentScalarWhereWithAggregatesInput | DeploymentScalarWhereWithAggregatesInput[]
    OR?: DeploymentScalarWhereWithAggregatesInput[]
    NOT?: DeploymentScalarWhereWithAggregatesInput | DeploymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deployment"> | string
    version?: StringWithAggregatesFilter<"Deployment"> | string
    status?: StringWithAggregatesFilter<"Deployment"> | string
    deployedUrl?: StringNullableWithAggregatesFilter<"Deployment"> | string | null
    config?: StringNullableWithAggregatesFilter<"Deployment"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Deployment"> | string | null
    deployedAt?: DateTimeNullableWithAggregatesFilter<"Deployment"> | Date | string | null
    rollbackAt?: DateTimeNullableWithAggregatesFilter<"Deployment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deployment"> | Date | string
    promptId?: StringWithAggregatesFilter<"Deployment"> | string
    environmentId?: StringWithAggregatesFilter<"Deployment"> | string
    deployedBy?: StringWithAggregatesFilter<"Deployment"> | string
  }

  export type DeploymentHistoryWhereInput = {
    AND?: DeploymentHistoryWhereInput | DeploymentHistoryWhereInput[]
    OR?: DeploymentHistoryWhereInput[]
    NOT?: DeploymentHistoryWhereInput | DeploymentHistoryWhereInput[]
    id?: StringFilter<"DeploymentHistory"> | string
    action?: StringFilter<"DeploymentHistory"> | string
    status?: StringFilter<"DeploymentHistory"> | string
    metadata?: StringNullableFilter<"DeploymentHistory"> | string | null
    timestamp?: DateTimeFilter<"DeploymentHistory"> | Date | string
    deploymentId?: StringFilter<"DeploymentHistory"> | string
    performedBy?: StringFilter<"DeploymentHistory"> | string
    deployment?: XOR<DeploymentRelationFilter, DeploymentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeploymentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    deploymentId?: SortOrder
    performedBy?: SortOrder
    deployment?: DeploymentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DeploymentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentHistoryWhereInput | DeploymentHistoryWhereInput[]
    OR?: DeploymentHistoryWhereInput[]
    NOT?: DeploymentHistoryWhereInput | DeploymentHistoryWhereInput[]
    action?: StringFilter<"DeploymentHistory"> | string
    status?: StringFilter<"DeploymentHistory"> | string
    metadata?: StringNullableFilter<"DeploymentHistory"> | string | null
    timestamp?: DateTimeFilter<"DeploymentHistory"> | Date | string
    deploymentId?: StringFilter<"DeploymentHistory"> | string
    performedBy?: StringFilter<"DeploymentHistory"> | string
    deployment?: XOR<DeploymentRelationFilter, DeploymentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DeploymentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    deploymentId?: SortOrder
    performedBy?: SortOrder
    _count?: DeploymentHistoryCountOrderByAggregateInput
    _max?: DeploymentHistoryMaxOrderByAggregateInput
    _min?: DeploymentHistoryMinOrderByAggregateInput
  }

  export type DeploymentHistoryScalarWhereWithAggregatesInput = {
    AND?: DeploymentHistoryScalarWhereWithAggregatesInput | DeploymentHistoryScalarWhereWithAggregatesInput[]
    OR?: DeploymentHistoryScalarWhereWithAggregatesInput[]
    NOT?: DeploymentHistoryScalarWhereWithAggregatesInput | DeploymentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeploymentHistory"> | string
    action?: StringWithAggregatesFilter<"DeploymentHistory"> | string
    status?: StringWithAggregatesFilter<"DeploymentHistory"> | string
    metadata?: StringNullableWithAggregatesFilter<"DeploymentHistory"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"DeploymentHistory"> | Date | string
    deploymentId?: StringWithAggregatesFilter<"DeploymentHistory"> | string
    performedBy?: StringWithAggregatesFilter<"DeploymentHistory"> | string
  }

  export type ImpactAnalysisWhereInput = {
    AND?: ImpactAnalysisWhereInput | ImpactAnalysisWhereInput[]
    OR?: ImpactAnalysisWhereInput[]
    NOT?: ImpactAnalysisWhereInput | ImpactAnalysisWhereInput[]
    id?: StringFilter<"ImpactAnalysis"> | string
    impactPercentage?: FloatFilter<"ImpactAnalysis"> | number
    diffAnalysis?: StringFilter<"ImpactAnalysis"> | string
    sampleComparisons?: StringFilter<"ImpactAnalysis"> | string
    createdAt?: DateTimeFilter<"ImpactAnalysis"> | Date | string
    deploymentId?: StringFilter<"ImpactAnalysis"> | string
    baselinePromptId?: StringNullableFilter<"ImpactAnalysis"> | string | null
    deployment?: XOR<DeploymentRelationFilter, DeploymentWhereInput>
    baselinePrompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    approvalRequests?: ApprovalRequestListRelationFilter
  }

  export type ImpactAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    impactPercentage?: SortOrder
    diffAnalysis?: SortOrder
    sampleComparisons?: SortOrder
    createdAt?: SortOrder
    deploymentId?: SortOrder
    baselinePromptId?: SortOrderInput | SortOrder
    deployment?: DeploymentOrderByWithRelationInput
    baselinePrompt?: PromptOrderByWithRelationInput
    approvalRequests?: ApprovalRequestOrderByRelationAggregateInput
  }

  export type ImpactAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImpactAnalysisWhereInput | ImpactAnalysisWhereInput[]
    OR?: ImpactAnalysisWhereInput[]
    NOT?: ImpactAnalysisWhereInput | ImpactAnalysisWhereInput[]
    impactPercentage?: FloatFilter<"ImpactAnalysis"> | number
    diffAnalysis?: StringFilter<"ImpactAnalysis"> | string
    sampleComparisons?: StringFilter<"ImpactAnalysis"> | string
    createdAt?: DateTimeFilter<"ImpactAnalysis"> | Date | string
    deploymentId?: StringFilter<"ImpactAnalysis"> | string
    baselinePromptId?: StringNullableFilter<"ImpactAnalysis"> | string | null
    deployment?: XOR<DeploymentRelationFilter, DeploymentWhereInput>
    baselinePrompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    approvalRequests?: ApprovalRequestListRelationFilter
  }, "id">

  export type ImpactAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    impactPercentage?: SortOrder
    diffAnalysis?: SortOrder
    sampleComparisons?: SortOrder
    createdAt?: SortOrder
    deploymentId?: SortOrder
    baselinePromptId?: SortOrderInput | SortOrder
    _count?: ImpactAnalysisCountOrderByAggregateInput
    _avg?: ImpactAnalysisAvgOrderByAggregateInput
    _max?: ImpactAnalysisMaxOrderByAggregateInput
    _min?: ImpactAnalysisMinOrderByAggregateInput
    _sum?: ImpactAnalysisSumOrderByAggregateInput
  }

  export type ImpactAnalysisScalarWhereWithAggregatesInput = {
    AND?: ImpactAnalysisScalarWhereWithAggregatesInput | ImpactAnalysisScalarWhereWithAggregatesInput[]
    OR?: ImpactAnalysisScalarWhereWithAggregatesInput[]
    NOT?: ImpactAnalysisScalarWhereWithAggregatesInput | ImpactAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImpactAnalysis"> | string
    impactPercentage?: FloatWithAggregatesFilter<"ImpactAnalysis"> | number
    diffAnalysis?: StringWithAggregatesFilter<"ImpactAnalysis"> | string
    sampleComparisons?: StringWithAggregatesFilter<"ImpactAnalysis"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ImpactAnalysis"> | Date | string
    deploymentId?: StringWithAggregatesFilter<"ImpactAnalysis"> | string
    baselinePromptId?: StringNullableWithAggregatesFilter<"ImpactAnalysis"> | string | null
  }

  export type CostTrackingWhereInput = {
    AND?: CostTrackingWhereInput | CostTrackingWhereInput[]
    OR?: CostTrackingWhereInput[]
    NOT?: CostTrackingWhereInput | CostTrackingWhereInput[]
    id?: StringFilter<"CostTracking"> | string
    period?: StringFilter<"CostTracking"> | string
    totalCost?: FloatFilter<"CostTracking"> | number
    tokenUsage?: IntFilter<"CostTracking"> | number
    requestCount?: IntFilter<"CostTracking"> | number
    breakdown?: StringFilter<"CostTracking"> | string
    createdAt?: DateTimeFilter<"CostTracking"> | Date | string
    updatedAt?: DateTimeFilter<"CostTracking"> | Date | string
    projectId?: StringFilter<"CostTracking"> | string
    userId?: StringNullableFilter<"CostTracking"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CostTrackingOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CostTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId_period?: CostTrackingProjectIdUserIdPeriodCompoundUniqueInput
    AND?: CostTrackingWhereInput | CostTrackingWhereInput[]
    OR?: CostTrackingWhereInput[]
    NOT?: CostTrackingWhereInput | CostTrackingWhereInput[]
    period?: StringFilter<"CostTracking"> | string
    totalCost?: FloatFilter<"CostTracking"> | number
    tokenUsage?: IntFilter<"CostTracking"> | number
    requestCount?: IntFilter<"CostTracking"> | number
    breakdown?: StringFilter<"CostTracking"> | string
    createdAt?: DateTimeFilter<"CostTracking"> | Date | string
    updatedAt?: DateTimeFilter<"CostTracking"> | Date | string
    projectId?: StringFilter<"CostTracking"> | string
    userId?: StringNullableFilter<"CostTracking"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "projectId_userId_period">

  export type CostTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CostTrackingCountOrderByAggregateInput
    _avg?: CostTrackingAvgOrderByAggregateInput
    _max?: CostTrackingMaxOrderByAggregateInput
    _min?: CostTrackingMinOrderByAggregateInput
    _sum?: CostTrackingSumOrderByAggregateInput
  }

  export type CostTrackingScalarWhereWithAggregatesInput = {
    AND?: CostTrackingScalarWhereWithAggregatesInput | CostTrackingScalarWhereWithAggregatesInput[]
    OR?: CostTrackingScalarWhereWithAggregatesInput[]
    NOT?: CostTrackingScalarWhereWithAggregatesInput | CostTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostTracking"> | string
    period?: StringWithAggregatesFilter<"CostTracking"> | string
    totalCost?: FloatWithAggregatesFilter<"CostTracking"> | number
    tokenUsage?: IntWithAggregatesFilter<"CostTracking"> | number
    requestCount?: IntWithAggregatesFilter<"CostTracking"> | number
    breakdown?: StringWithAggregatesFilter<"CostTracking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CostTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostTracking"> | Date | string
    projectId?: StringWithAggregatesFilter<"CostTracking"> | string
    userId?: StringNullableWithAggregatesFilter<"CostTracking"> | string | null
  }

  export type UserBillingWhereInput = {
    AND?: UserBillingWhereInput | UserBillingWhereInput[]
    OR?: UserBillingWhereInput[]
    NOT?: UserBillingWhereInput | UserBillingWhereInput[]
    id?: StringFilter<"UserBilling"> | string
    billingEmail?: StringNullableFilter<"UserBilling"> | string | null
    plan?: StringFilter<"UserBilling"> | string
    monthlyLimit?: FloatFilter<"UserBilling"> | number
    currentUsage?: FloatFilter<"UserBilling"> | number
    isActive?: BoolFilter<"UserBilling"> | boolean
    createdAt?: DateTimeFilter<"UserBilling"> | Date | string
    updatedAt?: DateTimeFilter<"UserBilling"> | Date | string
    userId?: StringFilter<"UserBilling"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserBillingOrderByWithRelationInput = {
    id?: SortOrder
    billingEmail?: SortOrderInput | SortOrder
    plan?: SortOrder
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserBillingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserBillingWhereInput | UserBillingWhereInput[]
    OR?: UserBillingWhereInput[]
    NOT?: UserBillingWhereInput | UserBillingWhereInput[]
    billingEmail?: StringNullableFilter<"UserBilling"> | string | null
    plan?: StringFilter<"UserBilling"> | string
    monthlyLimit?: FloatFilter<"UserBilling"> | number
    currentUsage?: FloatFilter<"UserBilling"> | number
    isActive?: BoolFilter<"UserBilling"> | boolean
    createdAt?: DateTimeFilter<"UserBilling"> | Date | string
    updatedAt?: DateTimeFilter<"UserBilling"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserBillingOrderByWithAggregationInput = {
    id?: SortOrder
    billingEmail?: SortOrderInput | SortOrder
    plan?: SortOrder
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: UserBillingCountOrderByAggregateInput
    _avg?: UserBillingAvgOrderByAggregateInput
    _max?: UserBillingMaxOrderByAggregateInput
    _min?: UserBillingMinOrderByAggregateInput
    _sum?: UserBillingSumOrderByAggregateInput
  }

  export type UserBillingScalarWhereWithAggregatesInput = {
    AND?: UserBillingScalarWhereWithAggregatesInput | UserBillingScalarWhereWithAggregatesInput[]
    OR?: UserBillingScalarWhereWithAggregatesInput[]
    NOT?: UserBillingScalarWhereWithAggregatesInput | UserBillingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBilling"> | string
    billingEmail?: StringNullableWithAggregatesFilter<"UserBilling"> | string | null
    plan?: StringWithAggregatesFilter<"UserBilling"> | string
    monthlyLimit?: FloatWithAggregatesFilter<"UserBilling"> | number
    currentUsage?: FloatWithAggregatesFilter<"UserBilling"> | number
    isActive?: BoolWithAggregatesFilter<"UserBilling"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserBilling"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBilling"> | Date | string
    userId?: StringWithAggregatesFilter<"UserBilling"> | string
  }

  export type AppIntegrationWhereInput = {
    AND?: AppIntegrationWhereInput | AppIntegrationWhereInput[]
    OR?: AppIntegrationWhereInput[]
    NOT?: AppIntegrationWhereInput | AppIntegrationWhereInput[]
    id?: StringFilter<"AppIntegration"> | string
    name?: StringFilter<"AppIntegration"> | string
    type?: StringFilter<"AppIntegration"> | string
    baseUrl?: StringFilter<"AppIntegration"> | string
    apiKeyHash?: StringFilter<"AppIntegration"> | string
    syncConfig?: StringFilter<"AppIntegration"> | string
    isActive?: BoolFilter<"AppIntegration"> | boolean
    lastSync?: DateTimeNullableFilter<"AppIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"AppIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"AppIntegration"> | Date | string
    projectId?: StringFilter<"AppIntegration"> | string
    createdBy?: StringFilter<"AppIntegration"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    syncOperations?: SyncOperationListRelationFilter
  }

  export type AppIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    apiKeyHash?: SortOrder
    syncConfig?: SortOrder
    isActive?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    syncOperations?: SyncOperationOrderByRelationAggregateInput
  }

  export type AppIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppIntegrationWhereInput | AppIntegrationWhereInput[]
    OR?: AppIntegrationWhereInput[]
    NOT?: AppIntegrationWhereInput | AppIntegrationWhereInput[]
    name?: StringFilter<"AppIntegration"> | string
    type?: StringFilter<"AppIntegration"> | string
    baseUrl?: StringFilter<"AppIntegration"> | string
    apiKeyHash?: StringFilter<"AppIntegration"> | string
    syncConfig?: StringFilter<"AppIntegration"> | string
    isActive?: BoolFilter<"AppIntegration"> | boolean
    lastSync?: DateTimeNullableFilter<"AppIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"AppIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"AppIntegration"> | Date | string
    projectId?: StringFilter<"AppIntegration"> | string
    createdBy?: StringFilter<"AppIntegration"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    syncOperations?: SyncOperationListRelationFilter
  }, "id">

  export type AppIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    apiKeyHash?: SortOrder
    syncConfig?: SortOrder
    isActive?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    _count?: AppIntegrationCountOrderByAggregateInput
    _max?: AppIntegrationMaxOrderByAggregateInput
    _min?: AppIntegrationMinOrderByAggregateInput
  }

  export type AppIntegrationScalarWhereWithAggregatesInput = {
    AND?: AppIntegrationScalarWhereWithAggregatesInput | AppIntegrationScalarWhereWithAggregatesInput[]
    OR?: AppIntegrationScalarWhereWithAggregatesInput[]
    NOT?: AppIntegrationScalarWhereWithAggregatesInput | AppIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppIntegration"> | string
    name?: StringWithAggregatesFilter<"AppIntegration"> | string
    type?: StringWithAggregatesFilter<"AppIntegration"> | string
    baseUrl?: StringWithAggregatesFilter<"AppIntegration"> | string
    apiKeyHash?: StringWithAggregatesFilter<"AppIntegration"> | string
    syncConfig?: StringWithAggregatesFilter<"AppIntegration"> | string
    isActive?: BoolWithAggregatesFilter<"AppIntegration"> | boolean
    lastSync?: DateTimeNullableWithAggregatesFilter<"AppIntegration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AppIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppIntegration"> | Date | string
    projectId?: StringWithAggregatesFilter<"AppIntegration"> | string
    createdBy?: StringWithAggregatesFilter<"AppIntegration"> | string
  }

  export type TestPipelineWhereInput = {
    AND?: TestPipelineWhereInput | TestPipelineWhereInput[]
    OR?: TestPipelineWhereInput[]
    NOT?: TestPipelineWhereInput | TestPipelineWhereInput[]
    id?: StringFilter<"TestPipeline"> | string
    name?: StringFilter<"TestPipeline"> | string
    description?: StringNullableFilter<"TestPipeline"> | string | null
    config?: StringFilter<"TestPipeline"> | string
    status?: StringFilter<"TestPipeline"> | string
    createdAt?: DateTimeFilter<"TestPipeline"> | Date | string
    updatedAt?: DateTimeFilter<"TestPipeline"> | Date | string
    projectId?: StringFilter<"TestPipeline"> | string
    createdBy?: StringFilter<"TestPipeline"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    stages?: PipelineStageListRelationFilter
    executions?: PipelineExecutionListRelationFilter
  }

  export type TestPipelineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    stages?: PipelineStageOrderByRelationAggregateInput
    executions?: PipelineExecutionOrderByRelationAggregateInput
  }

  export type TestPipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestPipelineWhereInput | TestPipelineWhereInput[]
    OR?: TestPipelineWhereInput[]
    NOT?: TestPipelineWhereInput | TestPipelineWhereInput[]
    name?: StringFilter<"TestPipeline"> | string
    description?: StringNullableFilter<"TestPipeline"> | string | null
    config?: StringFilter<"TestPipeline"> | string
    status?: StringFilter<"TestPipeline"> | string
    createdAt?: DateTimeFilter<"TestPipeline"> | Date | string
    updatedAt?: DateTimeFilter<"TestPipeline"> | Date | string
    projectId?: StringFilter<"TestPipeline"> | string
    createdBy?: StringFilter<"TestPipeline"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    stages?: PipelineStageListRelationFilter
    executions?: PipelineExecutionListRelationFilter
  }, "id">

  export type TestPipelineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    _count?: TestPipelineCountOrderByAggregateInput
    _max?: TestPipelineMaxOrderByAggregateInput
    _min?: TestPipelineMinOrderByAggregateInput
  }

  export type TestPipelineScalarWhereWithAggregatesInput = {
    AND?: TestPipelineScalarWhereWithAggregatesInput | TestPipelineScalarWhereWithAggregatesInput[]
    OR?: TestPipelineScalarWhereWithAggregatesInput[]
    NOT?: TestPipelineScalarWhereWithAggregatesInput | TestPipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestPipeline"> | string
    name?: StringWithAggregatesFilter<"TestPipeline"> | string
    description?: StringNullableWithAggregatesFilter<"TestPipeline"> | string | null
    config?: StringWithAggregatesFilter<"TestPipeline"> | string
    status?: StringWithAggregatesFilter<"TestPipeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TestPipeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestPipeline"> | Date | string
    projectId?: StringWithAggregatesFilter<"TestPipeline"> | string
    createdBy?: StringWithAggregatesFilter<"TestPipeline"> | string
  }

  export type PipelineStageWhereInput = {
    AND?: PipelineStageWhereInput | PipelineStageWhereInput[]
    OR?: PipelineStageWhereInput[]
    NOT?: PipelineStageWhereInput | PipelineStageWhereInput[]
    id?: StringFilter<"PipelineStage"> | string
    name?: StringFilter<"PipelineStage"> | string
    type?: StringFilter<"PipelineStage"> | string
    config?: StringFilter<"PipelineStage"> | string
    order?: IntFilter<"PipelineStage"> | number
    status?: StringFilter<"PipelineStage"> | string
    result?: StringNullableFilter<"PipelineStage"> | string | null
    createdAt?: DateTimeFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineStage"> | Date | string
    pipelineId?: StringFilter<"PipelineStage"> | string
    pipeline?: XOR<TestPipelineRelationFilter, TestPipelineWhereInput>
  }

  export type PipelineStageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    order?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    pipeline?: TestPipelineOrderByWithRelationInput
  }

  export type PipelineStageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineStageWhereInput | PipelineStageWhereInput[]
    OR?: PipelineStageWhereInput[]
    NOT?: PipelineStageWhereInput | PipelineStageWhereInput[]
    name?: StringFilter<"PipelineStage"> | string
    type?: StringFilter<"PipelineStage"> | string
    config?: StringFilter<"PipelineStage"> | string
    order?: IntFilter<"PipelineStage"> | number
    status?: StringFilter<"PipelineStage"> | string
    result?: StringNullableFilter<"PipelineStage"> | string | null
    createdAt?: DateTimeFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineStage"> | Date | string
    pipelineId?: StringFilter<"PipelineStage"> | string
    pipeline?: XOR<TestPipelineRelationFilter, TestPipelineWhereInput>
  }, "id">

  export type PipelineStageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    order?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    _count?: PipelineStageCountOrderByAggregateInput
    _avg?: PipelineStageAvgOrderByAggregateInput
    _max?: PipelineStageMaxOrderByAggregateInput
    _min?: PipelineStageMinOrderByAggregateInput
    _sum?: PipelineStageSumOrderByAggregateInput
  }

  export type PipelineStageScalarWhereWithAggregatesInput = {
    AND?: PipelineStageScalarWhereWithAggregatesInput | PipelineStageScalarWhereWithAggregatesInput[]
    OR?: PipelineStageScalarWhereWithAggregatesInput[]
    NOT?: PipelineStageScalarWhereWithAggregatesInput | PipelineStageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PipelineStage"> | string
    name?: StringWithAggregatesFilter<"PipelineStage"> | string
    type?: StringWithAggregatesFilter<"PipelineStage"> | string
    config?: StringWithAggregatesFilter<"PipelineStage"> | string
    order?: IntWithAggregatesFilter<"PipelineStage"> | number
    status?: StringWithAggregatesFilter<"PipelineStage"> | string
    result?: StringNullableWithAggregatesFilter<"PipelineStage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PipelineStage"> | Date | string
    pipelineId?: StringWithAggregatesFilter<"PipelineStage"> | string
  }

  export type PipelineExecutionWhereInput = {
    AND?: PipelineExecutionWhereInput | PipelineExecutionWhereInput[]
    OR?: PipelineExecutionWhereInput[]
    NOT?: PipelineExecutionWhereInput | PipelineExecutionWhereInput[]
    id?: StringFilter<"PipelineExecution"> | string
    status?: StringFilter<"PipelineExecution"> | string
    startedAt?: DateTimeNullableFilter<"PipelineExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PipelineExecution"> | Date | string | null
    result?: StringNullableFilter<"PipelineExecution"> | string | null
    error?: StringNullableFilter<"PipelineExecution"> | string | null
    metadata?: StringNullableFilter<"PipelineExecution"> | string | null
    createdAt?: DateTimeFilter<"PipelineExecution"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineExecution"> | Date | string
    pipelineId?: StringFilter<"PipelineExecution"> | string
    promptId?: StringFilter<"PipelineExecution"> | string
    baselinePromptId?: StringNullableFilter<"PipelineExecution"> | string | null
    executedBy?: StringFilter<"PipelineExecution"> | string
    pipeline?: XOR<TestPipelineRelationFilter, TestPipelineWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    baselinePrompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    executor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PipelineExecutionOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    promptId?: SortOrder
    baselinePromptId?: SortOrderInput | SortOrder
    executedBy?: SortOrder
    pipeline?: TestPipelineOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    baselinePrompt?: PromptOrderByWithRelationInput
    executor?: UserOrderByWithRelationInput
  }

  export type PipelineExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineExecutionWhereInput | PipelineExecutionWhereInput[]
    OR?: PipelineExecutionWhereInput[]
    NOT?: PipelineExecutionWhereInput | PipelineExecutionWhereInput[]
    status?: StringFilter<"PipelineExecution"> | string
    startedAt?: DateTimeNullableFilter<"PipelineExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PipelineExecution"> | Date | string | null
    result?: StringNullableFilter<"PipelineExecution"> | string | null
    error?: StringNullableFilter<"PipelineExecution"> | string | null
    metadata?: StringNullableFilter<"PipelineExecution"> | string | null
    createdAt?: DateTimeFilter<"PipelineExecution"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineExecution"> | Date | string
    pipelineId?: StringFilter<"PipelineExecution"> | string
    promptId?: StringFilter<"PipelineExecution"> | string
    baselinePromptId?: StringNullableFilter<"PipelineExecution"> | string | null
    executedBy?: StringFilter<"PipelineExecution"> | string
    pipeline?: XOR<TestPipelineRelationFilter, TestPipelineWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    baselinePrompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    executor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PipelineExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    promptId?: SortOrder
    baselinePromptId?: SortOrderInput | SortOrder
    executedBy?: SortOrder
    _count?: PipelineExecutionCountOrderByAggregateInput
    _max?: PipelineExecutionMaxOrderByAggregateInput
    _min?: PipelineExecutionMinOrderByAggregateInput
  }

  export type PipelineExecutionScalarWhereWithAggregatesInput = {
    AND?: PipelineExecutionScalarWhereWithAggregatesInput | PipelineExecutionScalarWhereWithAggregatesInput[]
    OR?: PipelineExecutionScalarWhereWithAggregatesInput[]
    NOT?: PipelineExecutionScalarWhereWithAggregatesInput | PipelineExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PipelineExecution"> | string
    status?: StringWithAggregatesFilter<"PipelineExecution"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"PipelineExecution"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PipelineExecution"> | Date | string | null
    result?: StringNullableWithAggregatesFilter<"PipelineExecution"> | string | null
    error?: StringNullableWithAggregatesFilter<"PipelineExecution"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"PipelineExecution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PipelineExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PipelineExecution"> | Date | string
    pipelineId?: StringWithAggregatesFilter<"PipelineExecution"> | string
    promptId?: StringWithAggregatesFilter<"PipelineExecution"> | string
    baselinePromptId?: StringNullableWithAggregatesFilter<"PipelineExecution"> | string | null
    executedBy?: StringWithAggregatesFilter<"PipelineExecution"> | string
  }

  export type DependencyWhereInput = {
    AND?: DependencyWhereInput | DependencyWhereInput[]
    OR?: DependencyWhereInput[]
    NOT?: DependencyWhereInput | DependencyWhereInput[]
    id?: StringFilter<"Dependency"> | string
    name?: StringFilter<"Dependency"> | string
    type?: StringFilter<"Dependency"> | string
    provider?: StringFilter<"Dependency"> | string
    config?: StringFilter<"Dependency"> | string
    status?: StringFilter<"Dependency"> | string
    version?: StringNullableFilter<"Dependency"> | string | null
    healthScore?: IntFilter<"Dependency"> | number
    lastCheck?: DateTimeFilter<"Dependency"> | Date | string
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    updatedAt?: DateTimeFilter<"Dependency"> | Date | string
    projectId?: StringFilter<"Dependency"> | string
    createdBy?: StringFilter<"Dependency"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DependencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    status?: SortOrder
    version?: SortOrderInput | SortOrder
    healthScore?: SortOrder
    lastCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type DependencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DependencyWhereInput | DependencyWhereInput[]
    OR?: DependencyWhereInput[]
    NOT?: DependencyWhereInput | DependencyWhereInput[]
    name?: StringFilter<"Dependency"> | string
    type?: StringFilter<"Dependency"> | string
    provider?: StringFilter<"Dependency"> | string
    config?: StringFilter<"Dependency"> | string
    status?: StringFilter<"Dependency"> | string
    version?: StringNullableFilter<"Dependency"> | string | null
    healthScore?: IntFilter<"Dependency"> | number
    lastCheck?: DateTimeFilter<"Dependency"> | Date | string
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    updatedAt?: DateTimeFilter<"Dependency"> | Date | string
    projectId?: StringFilter<"Dependency"> | string
    createdBy?: StringFilter<"Dependency"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DependencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    status?: SortOrder
    version?: SortOrderInput | SortOrder
    healthScore?: SortOrder
    lastCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    _count?: DependencyCountOrderByAggregateInput
    _avg?: DependencyAvgOrderByAggregateInput
    _max?: DependencyMaxOrderByAggregateInput
    _min?: DependencyMinOrderByAggregateInput
    _sum?: DependencySumOrderByAggregateInput
  }

  export type DependencyScalarWhereWithAggregatesInput = {
    AND?: DependencyScalarWhereWithAggregatesInput | DependencyScalarWhereWithAggregatesInput[]
    OR?: DependencyScalarWhereWithAggregatesInput[]
    NOT?: DependencyScalarWhereWithAggregatesInput | DependencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dependency"> | string
    name?: StringWithAggregatesFilter<"Dependency"> | string
    type?: StringWithAggregatesFilter<"Dependency"> | string
    provider?: StringWithAggregatesFilter<"Dependency"> | string
    config?: StringWithAggregatesFilter<"Dependency"> | string
    status?: StringWithAggregatesFilter<"Dependency"> | string
    version?: StringNullableWithAggregatesFilter<"Dependency"> | string | null
    healthScore?: IntWithAggregatesFilter<"Dependency"> | number
    lastCheck?: DateTimeWithAggregatesFilter<"Dependency"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Dependency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dependency"> | Date | string
    projectId?: StringWithAggregatesFilter<"Dependency"> | string
    createdBy?: StringWithAggregatesFilter<"Dependency"> | string
  }

  export type UpdatePlanWhereInput = {
    AND?: UpdatePlanWhereInput | UpdatePlanWhereInput[]
    OR?: UpdatePlanWhereInput[]
    NOT?: UpdatePlanWhereInput | UpdatePlanWhereInput[]
    id?: StringFilter<"UpdatePlan"> | string
    planData?: StringFilter<"UpdatePlan"> | string
    status?: StringFilter<"UpdatePlan"> | string
    executionResult?: StringNullableFilter<"UpdatePlan"> | string | null
    executedAt?: DateTimeNullableFilter<"UpdatePlan"> | Date | string | null
    createdAt?: DateTimeFilter<"UpdatePlan"> | Date | string
    updatedAt?: DateTimeFilter<"UpdatePlan"> | Date | string
    projectId?: StringFilter<"UpdatePlan"> | string
    createdBy?: StringFilter<"UpdatePlan"> | string
    executedBy?: StringNullableFilter<"UpdatePlan"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type UpdatePlanOrderByWithRelationInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    executionResult?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    executedBy?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    executor?: UserOrderByWithRelationInput
  }

  export type UpdatePlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UpdatePlanWhereInput | UpdatePlanWhereInput[]
    OR?: UpdatePlanWhereInput[]
    NOT?: UpdatePlanWhereInput | UpdatePlanWhereInput[]
    planData?: StringFilter<"UpdatePlan"> | string
    status?: StringFilter<"UpdatePlan"> | string
    executionResult?: StringNullableFilter<"UpdatePlan"> | string | null
    executedAt?: DateTimeNullableFilter<"UpdatePlan"> | Date | string | null
    createdAt?: DateTimeFilter<"UpdatePlan"> | Date | string
    updatedAt?: DateTimeFilter<"UpdatePlan"> | Date | string
    projectId?: StringFilter<"UpdatePlan"> | string
    createdBy?: StringFilter<"UpdatePlan"> | string
    executedBy?: StringNullableFilter<"UpdatePlan"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type UpdatePlanOrderByWithAggregationInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    executionResult?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    executedBy?: SortOrderInput | SortOrder
    _count?: UpdatePlanCountOrderByAggregateInput
    _max?: UpdatePlanMaxOrderByAggregateInput
    _min?: UpdatePlanMinOrderByAggregateInput
  }

  export type UpdatePlanScalarWhereWithAggregatesInput = {
    AND?: UpdatePlanScalarWhereWithAggregatesInput | UpdatePlanScalarWhereWithAggregatesInput[]
    OR?: UpdatePlanScalarWhereWithAggregatesInput[]
    NOT?: UpdatePlanScalarWhereWithAggregatesInput | UpdatePlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UpdatePlan"> | string
    planData?: StringWithAggregatesFilter<"UpdatePlan"> | string
    status?: StringWithAggregatesFilter<"UpdatePlan"> | string
    executionResult?: StringNullableWithAggregatesFilter<"UpdatePlan"> | string | null
    executedAt?: DateTimeNullableWithAggregatesFilter<"UpdatePlan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UpdatePlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UpdatePlan"> | Date | string
    projectId?: StringWithAggregatesFilter<"UpdatePlan"> | string
    createdBy?: StringWithAggregatesFilter<"UpdatePlan"> | string
    executedBy?: StringNullableWithAggregatesFilter<"UpdatePlan"> | string | null
  }

  export type DeploymentPlanWhereInput = {
    AND?: DeploymentPlanWhereInput | DeploymentPlanWhereInput[]
    OR?: DeploymentPlanWhereInput[]
    NOT?: DeploymentPlanWhereInput | DeploymentPlanWhereInput[]
    id?: StringFilter<"DeploymentPlan"> | string
    planData?: StringFilter<"DeploymentPlan"> | string
    status?: StringFilter<"DeploymentPlan"> | string
    createdAt?: DateTimeFilter<"DeploymentPlan"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentPlan"> | Date | string
    projectId?: StringFilter<"DeploymentPlan"> | string
    promptId?: StringFilter<"DeploymentPlan"> | string
    createdBy?: StringFilter<"DeploymentPlan"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executions?: DeploymentExecutionListRelationFilter
    approvals?: DeploymentApprovalListRelationFilter
  }

  export type DeploymentPlanOrderByWithRelationInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    createdBy?: SortOrder
    project?: ProjectOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    executions?: DeploymentExecutionOrderByRelationAggregateInput
    approvals?: DeploymentApprovalOrderByRelationAggregateInput
  }

  export type DeploymentPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentPlanWhereInput | DeploymentPlanWhereInput[]
    OR?: DeploymentPlanWhereInput[]
    NOT?: DeploymentPlanWhereInput | DeploymentPlanWhereInput[]
    planData?: StringFilter<"DeploymentPlan"> | string
    status?: StringFilter<"DeploymentPlan"> | string
    createdAt?: DateTimeFilter<"DeploymentPlan"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentPlan"> | Date | string
    projectId?: StringFilter<"DeploymentPlan"> | string
    promptId?: StringFilter<"DeploymentPlan"> | string
    createdBy?: StringFilter<"DeploymentPlan"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
    executions?: DeploymentExecutionListRelationFilter
    approvals?: DeploymentApprovalListRelationFilter
  }, "id">

  export type DeploymentPlanOrderByWithAggregationInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    createdBy?: SortOrder
    _count?: DeploymentPlanCountOrderByAggregateInput
    _max?: DeploymentPlanMaxOrderByAggregateInput
    _min?: DeploymentPlanMinOrderByAggregateInput
  }

  export type DeploymentPlanScalarWhereWithAggregatesInput = {
    AND?: DeploymentPlanScalarWhereWithAggregatesInput | DeploymentPlanScalarWhereWithAggregatesInput[]
    OR?: DeploymentPlanScalarWhereWithAggregatesInput[]
    NOT?: DeploymentPlanScalarWhereWithAggregatesInput | DeploymentPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeploymentPlan"> | string
    planData?: StringWithAggregatesFilter<"DeploymentPlan"> | string
    status?: StringWithAggregatesFilter<"DeploymentPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeploymentPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeploymentPlan"> | Date | string
    projectId?: StringWithAggregatesFilter<"DeploymentPlan"> | string
    promptId?: StringWithAggregatesFilter<"DeploymentPlan"> | string
    createdBy?: StringWithAggregatesFilter<"DeploymentPlan"> | string
  }

  export type DeploymentExecutionWhereInput = {
    AND?: DeploymentExecutionWhereInput | DeploymentExecutionWhereInput[]
    OR?: DeploymentExecutionWhereInput[]
    NOT?: DeploymentExecutionWhereInput | DeploymentExecutionWhereInput[]
    id?: StringFilter<"DeploymentExecution"> | string
    status?: StringFilter<"DeploymentExecution"> | string
    currentStage?: IntFilter<"DeploymentExecution"> | number
    startedAt?: DateTimeNullableFilter<"DeploymentExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeploymentExecution"> | Date | string | null
    metrics?: StringNullableFilter<"DeploymentExecution"> | string | null
    error?: StringNullableFilter<"DeploymentExecution"> | string | null
    metadata?: StringNullableFilter<"DeploymentExecution"> | string | null
    createdAt?: DateTimeFilter<"DeploymentExecution"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentExecution"> | Date | string
    planId?: StringFilter<"DeploymentExecution"> | string
    executedBy?: StringFilter<"DeploymentExecution"> | string
    plan?: XOR<DeploymentPlanRelationFilter, DeploymentPlanWhereInput>
    executor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeploymentExecutionOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    executedBy?: SortOrder
    plan?: DeploymentPlanOrderByWithRelationInput
    executor?: UserOrderByWithRelationInput
  }

  export type DeploymentExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentExecutionWhereInput | DeploymentExecutionWhereInput[]
    OR?: DeploymentExecutionWhereInput[]
    NOT?: DeploymentExecutionWhereInput | DeploymentExecutionWhereInput[]
    status?: StringFilter<"DeploymentExecution"> | string
    currentStage?: IntFilter<"DeploymentExecution"> | number
    startedAt?: DateTimeNullableFilter<"DeploymentExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeploymentExecution"> | Date | string | null
    metrics?: StringNullableFilter<"DeploymentExecution"> | string | null
    error?: StringNullableFilter<"DeploymentExecution"> | string | null
    metadata?: StringNullableFilter<"DeploymentExecution"> | string | null
    createdAt?: DateTimeFilter<"DeploymentExecution"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentExecution"> | Date | string
    planId?: StringFilter<"DeploymentExecution"> | string
    executedBy?: StringFilter<"DeploymentExecution"> | string
    plan?: XOR<DeploymentPlanRelationFilter, DeploymentPlanWhereInput>
    executor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DeploymentExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    executedBy?: SortOrder
    _count?: DeploymentExecutionCountOrderByAggregateInput
    _avg?: DeploymentExecutionAvgOrderByAggregateInput
    _max?: DeploymentExecutionMaxOrderByAggregateInput
    _min?: DeploymentExecutionMinOrderByAggregateInput
    _sum?: DeploymentExecutionSumOrderByAggregateInput
  }

  export type DeploymentExecutionScalarWhereWithAggregatesInput = {
    AND?: DeploymentExecutionScalarWhereWithAggregatesInput | DeploymentExecutionScalarWhereWithAggregatesInput[]
    OR?: DeploymentExecutionScalarWhereWithAggregatesInput[]
    NOT?: DeploymentExecutionScalarWhereWithAggregatesInput | DeploymentExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeploymentExecution"> | string
    status?: StringWithAggregatesFilter<"DeploymentExecution"> | string
    currentStage?: IntWithAggregatesFilter<"DeploymentExecution"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"DeploymentExecution"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"DeploymentExecution"> | Date | string | null
    metrics?: StringNullableWithAggregatesFilter<"DeploymentExecution"> | string | null
    error?: StringNullableWithAggregatesFilter<"DeploymentExecution"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"DeploymentExecution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeploymentExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeploymentExecution"> | Date | string
    planId?: StringWithAggregatesFilter<"DeploymentExecution"> | string
    executedBy?: StringWithAggregatesFilter<"DeploymentExecution"> | string
  }

  export type DeploymentApprovalWhereInput = {
    AND?: DeploymentApprovalWhereInput | DeploymentApprovalWhereInput[]
    OR?: DeploymentApprovalWhereInput[]
    NOT?: DeploymentApprovalWhereInput | DeploymentApprovalWhereInput[]
    id?: StringFilter<"DeploymentApproval"> | string
    status?: StringFilter<"DeploymentApproval"> | string
    comments?: StringNullableFilter<"DeploymentApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"DeploymentApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"DeploymentApproval"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentApproval"> | Date | string
    planId?: StringFilter<"DeploymentApproval"> | string
    approvedBy?: StringFilter<"DeploymentApproval"> | string
    plan?: XOR<DeploymentPlanRelationFilter, DeploymentPlanWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeploymentApprovalOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    approvedBy?: SortOrder
    plan?: DeploymentPlanOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type DeploymentApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeploymentApprovalWhereInput | DeploymentApprovalWhereInput[]
    OR?: DeploymentApprovalWhereInput[]
    NOT?: DeploymentApprovalWhereInput | DeploymentApprovalWhereInput[]
    status?: StringFilter<"DeploymentApproval"> | string
    comments?: StringNullableFilter<"DeploymentApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"DeploymentApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"DeploymentApproval"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentApproval"> | Date | string
    planId?: StringFilter<"DeploymentApproval"> | string
    approvedBy?: StringFilter<"DeploymentApproval"> | string
    plan?: XOR<DeploymentPlanRelationFilter, DeploymentPlanWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DeploymentApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    approvedBy?: SortOrder
    _count?: DeploymentApprovalCountOrderByAggregateInput
    _max?: DeploymentApprovalMaxOrderByAggregateInput
    _min?: DeploymentApprovalMinOrderByAggregateInput
  }

  export type DeploymentApprovalScalarWhereWithAggregatesInput = {
    AND?: DeploymentApprovalScalarWhereWithAggregatesInput | DeploymentApprovalScalarWhereWithAggregatesInput[]
    OR?: DeploymentApprovalScalarWhereWithAggregatesInput[]
    NOT?: DeploymentApprovalScalarWhereWithAggregatesInput | DeploymentApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeploymentApproval"> | string
    status?: StringWithAggregatesFilter<"DeploymentApproval"> | string
    comments?: StringNullableWithAggregatesFilter<"DeploymentApproval"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"DeploymentApproval"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeploymentApproval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeploymentApproval"> | Date | string
    planId?: StringWithAggregatesFilter<"DeploymentApproval"> | string
    approvedBy?: StringWithAggregatesFilter<"DeploymentApproval"> | string
  }

  export type ApprovalRequestWhereInput = {
    AND?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    OR?: ApprovalRequestWhereInput[]
    NOT?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    id?: StringFilter<"ApprovalRequest"> | string
    status?: StringFilter<"ApprovalRequest"> | string
    metadata?: StringNullableFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    projectId?: StringFilter<"ApprovalRequest"> | string
    promptId?: StringFilter<"ApprovalRequest"> | string
    appId?: StringFilter<"ApprovalRequest"> | string
    requestedBy?: StringFilter<"ApprovalRequest"> | string
    impactAnalysisId?: StringNullableFilter<"ApprovalRequest"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
    impactAnalysis?: XOR<ImpactAnalysisNullableRelationFilter, ImpactAnalysisWhereInput> | null
  }

  export type ApprovalRequestOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    appId?: SortOrder
    requestedBy?: SortOrder
    impactAnalysisId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
    impactAnalysis?: ImpactAnalysisOrderByWithRelationInput
  }

  export type ApprovalRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    OR?: ApprovalRequestWhereInput[]
    NOT?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    status?: StringFilter<"ApprovalRequest"> | string
    metadata?: StringNullableFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    projectId?: StringFilter<"ApprovalRequest"> | string
    promptId?: StringFilter<"ApprovalRequest"> | string
    appId?: StringFilter<"ApprovalRequest"> | string
    requestedBy?: StringFilter<"ApprovalRequest"> | string
    impactAnalysisId?: StringNullableFilter<"ApprovalRequest"> | string | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    prompt?: XOR<PromptRelationFilter, PromptWhereInput>
    requester?: XOR<UserRelationFilter, UserWhereInput>
    impactAnalysis?: XOR<ImpactAnalysisNullableRelationFilter, ImpactAnalysisWhereInput> | null
  }, "id">

  export type ApprovalRequestOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    appId?: SortOrder
    requestedBy?: SortOrder
    impactAnalysisId?: SortOrderInput | SortOrder
    _count?: ApprovalRequestCountOrderByAggregateInput
    _max?: ApprovalRequestMaxOrderByAggregateInput
    _min?: ApprovalRequestMinOrderByAggregateInput
  }

  export type ApprovalRequestScalarWhereWithAggregatesInput = {
    AND?: ApprovalRequestScalarWhereWithAggregatesInput | ApprovalRequestScalarWhereWithAggregatesInput[]
    OR?: ApprovalRequestScalarWhereWithAggregatesInput[]
    NOT?: ApprovalRequestScalarWhereWithAggregatesInput | ApprovalRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    status?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    metadata?: StringNullableWithAggregatesFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
    projectId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    promptId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    appId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    requestedBy?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    impactAnalysisId?: StringNullableWithAggregatesFilter<"ApprovalRequest"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMemberCreateInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PromptCreateInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
  }

  export type PromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestRunCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestRunsInput
    user: UserCreateNestedOneWithoutTestRunsInput
    prompt: PromptCreateNestedOneWithoutTestRunsInput
    responses?: TestResponseCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    promptId: string
    responses?: TestResponseUncheckedCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricUncheckedCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestRunsNestedInput
    user?: UserUpdateOneRequiredWithoutTestRunsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutTestRunsNestedInput
    responses?: TestResponseUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    responses?: TestResponseUncheckedUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUncheckedUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    promptId: string
  }

  export type TestRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
  }

  export type TestResponseCreateInput = {
    id?: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput?: string | null
    outputStructure?: string | null
    tokenUsage?: string | null
    latencyMs?: number | null
    cost?: number | null
    error?: string | null
    rawResponse?: string | null
    evaluationData?: string | null
    createdAt?: Date | string
    testRun: TestRunCreateNestedOneWithoutResponsesInput
  }

  export type TestResponseUncheckedCreateInput = {
    id?: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput?: string | null
    outputStructure?: string | null
    tokenUsage?: string | null
    latencyMs?: number | null
    cost?: number | null
    error?: string | null
    rawResponse?: string | null
    evaluationData?: string | null
    createdAt?: Date | string
    testRunId: string
  }

  export type TestResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testRun?: TestRunUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type TestResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testRunId?: StringFieldUpdateOperationsInput | string
  }

  export type TestResponseCreateManyInput = {
    id?: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput?: string | null
    outputStructure?: string | null
    tokenUsage?: string | null
    latencyMs?: number | null
    cost?: number | null
    error?: string | null
    rawResponse?: string | null
    evaluationData?: string | null
    createdAt?: Date | string
    testRunId: string
  }

  export type TestResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testRunId?: StringFieldUpdateOperationsInput | string
  }

  export type TestMetricCreateInput = {
    id?: string
    name: string
    value: number
    unit?: string | null
    metadata?: string | null
    createdAt?: Date | string
    testRun: TestRunCreateNestedOneWithoutMetricsInput
  }

  export type TestMetricUncheckedCreateInput = {
    id?: string
    name: string
    value: number
    unit?: string | null
    metadata?: string | null
    createdAt?: Date | string
    testRunId: string
  }

  export type TestMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testRun?: TestRunUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type TestMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testRunId?: StringFieldUpdateOperationsInput | string
  }

  export type TestMetricCreateManyInput = {
    id?: string
    name: string
    value: number
    unit?: string | null
    metadata?: string | null
    createdAt?: Date | string
    testRunId: string
  }

  export type TestMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testRunId?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationPluginCreateInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    config: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationPluginUncheckedCreateInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    config: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationPluginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationPluginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationPluginCreateManyInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    config: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationPluginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationPluginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueJobCreateInput = {
    id?: string
    type: string
    data: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    status?: string
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type QueueJobUncheckedCreateInput = {
    id?: string
    type: string
    data: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    status?: string
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type QueueJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QueueJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QueueJobCreateManyInput = {
    id?: string
    type: string
    data: string
    priority?: number
    attempts?: number
    maxAttempts?: number
    status?: string
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
  }

  export type QueueJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QueueJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringJobCreateInput = {
    id?: string
    type: string
    data: string
    interval: number
    priority?: number
    enabled?: boolean
    nextRun: Date | string
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringJobUncheckedCreateInput = {
    id?: string
    type: string
    data: string
    interval: number
    priority?: number
    enabled?: boolean
    nextRun: Date | string
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextRun?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextRun?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringJobCreateManyInput = {
    id?: string
    type: string
    data: string
    interval: number
    priority?: number
    enabled?: boolean
    nextRun: Date | string
    lastRun?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextRun?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    interval?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextRun?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRun?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncOperationCreateInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSyncOperationsInput
    connection: AppIntegrationCreateNestedOneWithoutSyncOperationsInput
    initiator: UserCreateNestedOneWithoutInitiatedSyncsInput
  }

  export type SyncOperationUncheckedCreateInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    connectionId: string
    initiatedBy: string
  }

  export type SyncOperationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSyncOperationsNestedInput
    connection?: AppIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedSyncsNestedInput
  }

  export type SyncOperationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SyncOperationCreateManyInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    connectionId: string
    initiatedBy: string
  }

  export type SyncOperationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncOperationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookSubscriptionCreateInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWebhookSubscriptionsInput
    creator: UserCreateNestedOneWithoutCreatedWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
    failedDeliveries?: WebhookDeliveryCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionUncheckedCreateInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    createdBy: string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
    failedDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWebhookSubscriptionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
    failedDeliveries?: WebhookDeliveryUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
    failedDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionCreateManyInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    createdBy: string
  }

  export type WebhookSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    project?: ProjectCreateNestedOneWithoutWebhookDeliveriesInput
    webhook?: WebhookSubscriptionCreateNestedOneWithoutDeliveriesInput
    failedWebhook?: WebhookSubscriptionCreateNestedOneWithoutFailedDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    projectId?: string | null
    webhookId?: string | null
    failedWebhookId?: string | null
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutWebhookDeliveriesNestedInput
    webhook?: WebhookSubscriptionUpdateOneWithoutDeliveriesNestedInput
    failedWebhook?: WebhookSubscriptionUpdateOneWithoutFailedDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookId?: NullableStringFieldUpdateOperationsInput | string | null
    failedWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    projectId?: string | null
    webhookId?: string | null
    failedWebhookId?: string | null
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookId?: NullableStringFieldUpdateOperationsInput | string | null
    failedWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    provider: string
    keyHash: string
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    name: string
    provider: string
    keyHash: string
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    name: string
    provider: string
    keyHash: string
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type EnvironmentCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEnvironmentsInput
    deployments?: DeploymentCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    deployments?: DeploymentUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEnvironmentsNestedInput
    deployments?: DeploymentUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    deployments?: DeploymentUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentCreateManyInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type EnvironmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentCreateInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutDeploymentsInput
    environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
    deployedByUser: UserCreateNestedOneWithoutDeploymentsInput
    history?: DeploymentHistoryCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    environmentId: string
    deployedBy: string
    history?: DeploymentHistoryUncheckedCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutDeploymentsNestedInput
    environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsNestedInput
    deployedByUser?: UserUpdateOneRequiredWithoutDeploymentsNestedInput
    history?: DeploymentHistoryUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
    history?: DeploymentHistoryUncheckedUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentCreateManyInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    environmentId: string
    deployedBy: string
  }

  export type DeploymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentHistoryCreateInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    deployment: DeploymentCreateNestedOneWithoutHistoryInput
    user: UserCreateNestedOneWithoutDeploymentActionsInput
  }

  export type DeploymentHistoryUncheckedCreateInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    deploymentId: string
    performedBy: string
  }

  export type DeploymentHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeploymentUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutDeploymentActionsNestedInput
  }

  export type DeploymentHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentHistoryCreateManyInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    deploymentId: string
    performedBy: string
  }

  export type DeploymentHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ImpactAnalysisCreateInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deployment: DeploymentCreateNestedOneWithoutImpactAnalysisInput
    baselinePrompt?: PromptCreateNestedOneWithoutImpactAnalysisInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisUncheckedCreateInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deploymentId: string
    baselinePromptId?: string | null
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeploymentUpdateOneRequiredWithoutImpactAnalysisNestedInput
    baselinePrompt?: PromptUpdateOneWithoutImpactAnalysisNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisCreateManyInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deploymentId: string
    baselinePromptId?: string | null
  }

  export type ImpactAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostTrackingCreateInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCostTrackingInput
    user?: UserCreateNestedOneWithoutCostTrackingInput
  }

  export type CostTrackingUncheckedCreateInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId?: string | null
  }

  export type CostTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCostTrackingNestedInput
    user?: UserUpdateOneWithoutCostTrackingNestedInput
  }

  export type CostTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostTrackingCreateManyInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId?: string | null
  }

  export type CostTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBillingCreateInput = {
    id?: string
    billingEmail?: string | null
    plan?: string
    monthlyLimit?: number
    currentUsage?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBillingInput
  }

  export type UserBillingUncheckedCreateInput = {
    id?: string
    billingEmail?: string | null
    plan?: string
    monthlyLimit?: number
    currentUsage?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserBillingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    monthlyLimit?: FloatFieldUpdateOperationsInput | number
    currentUsage?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBillingNestedInput
  }

  export type UserBillingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    monthlyLimit?: FloatFieldUpdateOperationsInput | number
    currentUsage?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserBillingCreateManyInput = {
    id?: string
    billingEmail?: string | null
    plan?: string
    monthlyLimit?: number
    currentUsage?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserBillingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    monthlyLimit?: FloatFieldUpdateOperationsInput | number
    currentUsage?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBillingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    monthlyLimit?: FloatFieldUpdateOperationsInput | number
    currentUsage?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AppIntegrationCreateInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAppIntegrationsInput
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
    syncOperations?: SyncOperationCreateNestedManyWithoutConnectionInput
  }

  export type AppIntegrationUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type AppIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAppIntegrationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutConnectionNestedInput
  }

  export type AppIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type AppIntegrationCreateManyInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type AppIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type TestPipelineCreateInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestPipelinesInput
    creator: UserCreateNestedOneWithoutCreatedPipelinesInput
    stages?: PipelineStageCreateNestedManyWithoutPipelineInput
    executions?: PipelineExecutionCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    stages?: PipelineStageUncheckedCreateNestedManyWithoutPipelineInput
    executions?: PipelineExecutionUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestPipelinesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPipelinesNestedInput
    stages?: PipelineStageUpdateManyWithoutPipelineNestedInput
    executions?: PipelineExecutionUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    stages?: PipelineStageUncheckedUpdateManyWithoutPipelineNestedInput
    executions?: PipelineExecutionUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type TestPipelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestPipelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineStageCreateInput = {
    id?: string
    name: string
    type: string
    config: string
    order: number
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: TestPipelineCreateNestedOneWithoutStagesInput
  }

  export type PipelineStageUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    config: string
    order: number
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
  }

  export type PipelineStageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: TestPipelineUpdateOneRequiredWithoutStagesNestedInput
  }

  export type PipelineStageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineStageCreateManyInput = {
    id?: string
    name: string
    type: string
    config: string
    order: number
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
  }

  export type PipelineStageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineStageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionCreateInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: TestPipelineCreateNestedOneWithoutExecutionsInput
    prompt: PromptCreateNestedOneWithoutPipelineExecutionsInput
    baselinePrompt?: PromptCreateNestedOneWithoutBaselinePipelineExecutionsInput
    executor: UserCreateNestedOneWithoutExecutedPipelinesInput
  }

  export type PipelineExecutionUncheckedCreateInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    promptId: string
    baselinePromptId?: string | null
    executedBy: string
  }

  export type PipelineExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: TestPipelineUpdateOneRequiredWithoutExecutionsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutPipelineExecutionsNestedInput
    baselinePrompt?: PromptUpdateOneWithoutBaselinePipelineExecutionsNestedInput
    executor?: UserUpdateOneRequiredWithoutExecutedPipelinesNestedInput
  }

  export type PipelineExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionCreateManyInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    promptId: string
    baselinePromptId?: string | null
    executedBy: string
  }

  export type PipelineExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyCreateInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDependenciesInput
    creator: UserCreateNestedOneWithoutCreatedDependenciesInput
  }

  export type DependencyUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type DependencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDependenciesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDependenciesNestedInput
  }

  export type DependencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyCreateManyInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type DependencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UpdatePlanCreateInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatePlansInput
    creator: UserCreateNestedOneWithoutCreatedUpdatePlansInput
    executor?: UserCreateNestedOneWithoutExecutedUpdatePlansInput
  }

  export type UpdatePlanUncheckedCreateInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    executedBy?: string | null
  }

  export type UpdatePlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatePlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedUpdatePlansNestedInput
    executor?: UserUpdateOneWithoutExecutedUpdatePlansNestedInput
  }

  export type UpdatePlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdatePlanCreateManyInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    executedBy?: string | null
  }

  export type UpdatePlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdatePlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeploymentPlanCreateInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeploymentPlansInput
    prompt: PromptCreateNestedOneWithoutDeploymentPlansInput
    creator: UserCreateNestedOneWithoutCreatedDeploymentPlansInput
    executions?: DeploymentExecutionCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUncheckedCreateInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    createdBy: string
    executions?: DeploymentExecutionUncheckedCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalUncheckedCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeploymentPlansNestedInput
    prompt?: PromptUpdateOneRequiredWithoutDeploymentPlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDeploymentPlansNestedInput
    executions?: DeploymentExecutionUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executions?: DeploymentExecutionUncheckedUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanCreateManyInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    createdBy: string
  }

  export type DeploymentPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentExecutionCreateInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: DeploymentPlanCreateNestedOneWithoutExecutionsInput
    executor: UserCreateNestedOneWithoutExecutedDeploymentsInput
  }

  export type DeploymentExecutionUncheckedCreateInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
    executedBy: string
  }

  export type DeploymentExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: DeploymentPlanUpdateOneRequiredWithoutExecutionsNestedInput
    executor?: UserUpdateOneRequiredWithoutExecutedDeploymentsNestedInput
  }

  export type DeploymentExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentExecutionCreateManyInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
    executedBy: string
  }

  export type DeploymentExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentApprovalCreateInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: DeploymentPlanCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutDeploymentApprovalsInput
  }

  export type DeploymentApprovalUncheckedCreateInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
    approvedBy: string
  }

  export type DeploymentApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: DeploymentPlanUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutDeploymentApprovalsNestedInput
  }

  export type DeploymentApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
    approvedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentApprovalCreateManyInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
    approvedBy: string
  }

  export type DeploymentApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeploymentApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
    approvedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalRequestCreateInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appId: string
    project: ProjectCreateNestedOneWithoutApprovalRequestsInput
    prompt: PromptCreateNestedOneWithoutApprovalRequestsInput
    requester: UserCreateNestedOneWithoutRequestedApprovalsInput
    impactAnalysis?: ImpactAnalysisCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalRequestUncheckedCreateInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    appId: string
    requestedBy: string
    impactAnalysisId?: string | null
  }

  export type ApprovalRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appId?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutApprovalRequestsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutApprovalRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutRequestedApprovalsNestedInput
    impactAnalysis?: ImpactAnalysisUpdateOneWithoutApprovalRequestsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApprovalRequestCreateManyInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    appId: string
    requestedBy: string
    impactAnalysisId?: string | null
  }

  export type ApprovalRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appId?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type TestRunListRelationFilter = {
    every?: TestRunWhereInput
    some?: TestRunWhereInput
    none?: TestRunWhereInput
  }

  export type DeploymentListRelationFilter = {
    every?: DeploymentWhereInput
    some?: DeploymentWhereInput
    none?: DeploymentWhereInput
  }

  export type DeploymentHistoryListRelationFilter = {
    every?: DeploymentHistoryWhereInput
    some?: DeploymentHistoryWhereInput
    none?: DeploymentHistoryWhereInput
  }

  export type CostTrackingListRelationFilter = {
    every?: CostTrackingWhereInput
    some?: CostTrackingWhereInput
    none?: CostTrackingWhereInput
  }

  export type UserBillingNullableRelationFilter = {
    is?: UserBillingWhereInput | null
    isNot?: UserBillingWhereInput | null
  }

  export type AppIntegrationListRelationFilter = {
    every?: AppIntegrationWhereInput
    some?: AppIntegrationWhereInput
    none?: AppIntegrationWhereInput
  }

  export type TestPipelineListRelationFilter = {
    every?: TestPipelineWhereInput
    some?: TestPipelineWhereInput
    none?: TestPipelineWhereInput
  }

  export type PipelineExecutionListRelationFilter = {
    every?: PipelineExecutionWhereInput
    some?: PipelineExecutionWhereInput
    none?: PipelineExecutionWhereInput
  }

  export type DependencyListRelationFilter = {
    every?: DependencyWhereInput
    some?: DependencyWhereInput
    none?: DependencyWhereInput
  }

  export type UpdatePlanListRelationFilter = {
    every?: UpdatePlanWhereInput
    some?: UpdatePlanWhereInput
    none?: UpdatePlanWhereInput
  }

  export type DeploymentPlanListRelationFilter = {
    every?: DeploymentPlanWhereInput
    some?: DeploymentPlanWhereInput
    none?: DeploymentPlanWhereInput
  }

  export type DeploymentExecutionListRelationFilter = {
    every?: DeploymentExecutionWhereInput
    some?: DeploymentExecutionWhereInput
    none?: DeploymentExecutionWhereInput
  }

  export type DeploymentApprovalListRelationFilter = {
    every?: DeploymentApprovalWhereInput
    some?: DeploymentApprovalWhereInput
    none?: DeploymentApprovalWhereInput
  }

  export type ApprovalRequestListRelationFilter = {
    every?: ApprovalRequestWhereInput
    some?: ApprovalRequestWhereInput
    none?: ApprovalRequestWhereInput
  }

  export type SyncOperationListRelationFilter = {
    every?: SyncOperationWhereInput
    some?: SyncOperationWhereInput
    none?: SyncOperationWhereInput
  }

  export type WebhookSubscriptionListRelationFilter = {
    every?: WebhookSubscriptionWhereInput
    some?: WebhookSubscriptionWhereInput
    none?: WebhookSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestPipelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UpdatePlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeploymentApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyncOperationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PromptListRelationFilter = {
    every?: PromptWhereInput
    some?: PromptWhereInput
    none?: PromptWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type EnvironmentListRelationFilter = {
    every?: EnvironmentWhereInput
    some?: EnvironmentWhereInput
    none?: EnvironmentWhereInput
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type PromptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvironmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PromptNullableRelationFilter = {
    is?: PromptWhereInput | null
    isNot?: PromptWhereInput | null
  }

  export type ImpactAnalysisListRelationFilter = {
    every?: ImpactAnalysisWhereInput
    some?: ImpactAnalysisWhereInput
    none?: ImpactAnalysisWhereInput
  }

  export type ImpactAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    version?: SortOrder
    isArchived?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    outputSchema?: SortOrder
    outputFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    parentId?: SortOrder
  }

  export type PromptAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type PromptMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    version?: SortOrder
    isArchived?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    outputSchema?: SortOrder
    outputFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    parentId?: SortOrder
  }

  export type PromptMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    version?: SortOrder
    isArchived?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    outputSchema?: SortOrder
    outputFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    parentId?: SortOrder
  }

  export type PromptSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PromptRelationFilter = {
    is?: PromptWhereInput
    isNot?: PromptWhereInput
  }

  export type TestResponseListRelationFilter = {
    every?: TestResponseWhereInput
    some?: TestResponseWhereInput
    none?: TestResponseWhereInput
  }

  export type TestMetricListRelationFilter = {
    every?: TestMetricWhereInput
    some?: TestMetricWhereInput
    none?: TestMetricWhereInput
  }

  export type TestResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestRunCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
  }

  export type TestRunMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
  }

  export type TestRunMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    promptId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TestRunRelationFilter = {
    is?: TestRunWhereInput
    isNot?: TestRunWhereInput
  }

  export type TestResponseCountOrderByAggregateInput = {
    id?: SortOrder
    modelProvider?: SortOrder
    modelName?: SortOrder
    input?: SortOrder
    output?: SortOrder
    parsedOutput?: SortOrder
    outputStructure?: SortOrder
    tokenUsage?: SortOrder
    latencyMs?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    rawResponse?: SortOrder
    evaluationData?: SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
  }

  export type TestResponseAvgOrderByAggregateInput = {
    latencyMs?: SortOrder
    cost?: SortOrder
  }

  export type TestResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    modelProvider?: SortOrder
    modelName?: SortOrder
    input?: SortOrder
    output?: SortOrder
    parsedOutput?: SortOrder
    outputStructure?: SortOrder
    tokenUsage?: SortOrder
    latencyMs?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    rawResponse?: SortOrder
    evaluationData?: SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
  }

  export type TestResponseMinOrderByAggregateInput = {
    id?: SortOrder
    modelProvider?: SortOrder
    modelName?: SortOrder
    input?: SortOrder
    output?: SortOrder
    parsedOutput?: SortOrder
    outputStructure?: SortOrder
    tokenUsage?: SortOrder
    latencyMs?: SortOrder
    cost?: SortOrder
    error?: SortOrder
    rawResponse?: SortOrder
    evaluationData?: SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
  }

  export type TestResponseSumOrderByAggregateInput = {
    latencyMs?: SortOrder
    cost?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TestMetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
  }

  export type TestMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TestMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
  }

  export type TestMetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    testRunId?: SortOrder
  }

  export type TestMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EvaluationPluginCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    config?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationPluginMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    config?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationPluginMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    config?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueJobCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    status?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type QueueJobAvgOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type QueueJobMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    status?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type QueueJobMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    status?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
  }

  export type QueueJobSumOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type RecurringJobCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    interval?: SortOrder
    priority?: SortOrder
    enabled?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringJobAvgOrderByAggregateInput = {
    interval?: SortOrder
    priority?: SortOrder
  }

  export type RecurringJobMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    interval?: SortOrder
    priority?: SortOrder
    enabled?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringJobMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    interval?: SortOrder
    priority?: SortOrder
    enabled?: SortOrder
    nextRun?: SortOrder
    lastRun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringJobSumOrderByAggregateInput = {
    interval?: SortOrder
    priority?: SortOrder
  }

  export type AppIntegrationRelationFilter = {
    is?: AppIntegrationWhereInput
    isNot?: AppIntegrationWhereInput
  }

  export type SyncOperationCountOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    result?: SortOrder
    error?: SortOrder
    config?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    connectionId?: SortOrder
    initiatedBy?: SortOrder
  }

  export type SyncOperationMaxOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    result?: SortOrder
    error?: SortOrder
    config?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    connectionId?: SortOrder
    initiatedBy?: SortOrder
  }

  export type SyncOperationMinOrderByAggregateInput = {
    id?: SortOrder
    direction?: SortOrder
    strategy?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    result?: SortOrder
    error?: SortOrder
    config?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    connectionId?: SortOrder
    initiatedBy?: SortOrder
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type WebhookSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    events?: SortOrder
    headers?: SortOrder
    secret?: SortOrder
    enabled?: SortOrder
    retryAttempts?: SortOrder
    lastDelivery?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type WebhookSubscriptionAvgOrderByAggregateInput = {
    retryAttempts?: SortOrder
  }

  export type WebhookSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    events?: SortOrder
    headers?: SortOrder
    secret?: SortOrder
    enabled?: SortOrder
    retryAttempts?: SortOrder
    lastDelivery?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type WebhookSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    events?: SortOrder
    headers?: SortOrder
    secret?: SortOrder
    enabled?: SortOrder
    retryAttempts?: SortOrder
    lastDelivery?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type WebhookSubscriptionSumOrderByAggregateInput = {
    retryAttempts?: SortOrder
  }

  export type WebhookSubscriptionNullableRelationFilter = {
    is?: WebhookSubscriptionWhereInput | null
    isNot?: WebhookSubscriptionWhereInput | null
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    payload?: SortOrder
    headers?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    response?: SortOrder
    error?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventType?: SortOrder
    projectId?: SortOrder
    webhookId?: SortOrder
    failedWebhookId?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    payload?: SortOrder
    headers?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    response?: SortOrder
    error?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventType?: SortOrder
    projectId?: SortOrder
    webhookId?: SortOrder
    failedWebhookId?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    payload?: SortOrder
    headers?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    response?: SortOrder
    error?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eventType?: SortOrder
    projectId?: SortOrder
    webhookId?: SortOrder
    failedWebhookId?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EnvironmentProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type EnvironmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnvironmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnvironmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnvironmentRelationFilter = {
    is?: EnvironmentWhereInput
    isNot?: EnvironmentWhereInput
  }

  export type DeploymentCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    status?: SortOrder
    deployedUrl?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    deployedAt?: SortOrder
    rollbackAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    promptId?: SortOrder
    environmentId?: SortOrder
    deployedBy?: SortOrder
  }

  export type DeploymentMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    status?: SortOrder
    deployedUrl?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    deployedAt?: SortOrder
    rollbackAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    promptId?: SortOrder
    environmentId?: SortOrder
    deployedBy?: SortOrder
  }

  export type DeploymentMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    status?: SortOrder
    deployedUrl?: SortOrder
    config?: SortOrder
    metadata?: SortOrder
    deployedAt?: SortOrder
    rollbackAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    promptId?: SortOrder
    environmentId?: SortOrder
    deployedBy?: SortOrder
  }

  export type DeploymentRelationFilter = {
    is?: DeploymentWhereInput
    isNot?: DeploymentWhereInput
  }

  export type DeploymentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    deploymentId?: SortOrder
    performedBy?: SortOrder
  }

  export type DeploymentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    deploymentId?: SortOrder
    performedBy?: SortOrder
  }

  export type DeploymentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    deploymentId?: SortOrder
    performedBy?: SortOrder
  }

  export type ImpactAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    impactPercentage?: SortOrder
    diffAnalysis?: SortOrder
    sampleComparisons?: SortOrder
    createdAt?: SortOrder
    deploymentId?: SortOrder
    baselinePromptId?: SortOrder
  }

  export type ImpactAnalysisAvgOrderByAggregateInput = {
    impactPercentage?: SortOrder
  }

  export type ImpactAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    impactPercentage?: SortOrder
    diffAnalysis?: SortOrder
    sampleComparisons?: SortOrder
    createdAt?: SortOrder
    deploymentId?: SortOrder
    baselinePromptId?: SortOrder
  }

  export type ImpactAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    impactPercentage?: SortOrder
    diffAnalysis?: SortOrder
    sampleComparisons?: SortOrder
    createdAt?: SortOrder
    deploymentId?: SortOrder
    baselinePromptId?: SortOrder
  }

  export type ImpactAnalysisSumOrderByAggregateInput = {
    impactPercentage?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CostTrackingProjectIdUserIdPeriodCompoundUniqueInput = {
    projectId: string
    userId: string
    period: string
  }

  export type CostTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type CostTrackingAvgOrderByAggregateInput = {
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
  }

  export type CostTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type CostTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type CostTrackingSumOrderByAggregateInput = {
    totalCost?: SortOrder
    tokenUsage?: SortOrder
    requestCount?: SortOrder
  }

  export type UserBillingCountOrderByAggregateInput = {
    id?: SortOrder
    billingEmail?: SortOrder
    plan?: SortOrder
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserBillingAvgOrderByAggregateInput = {
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
  }

  export type UserBillingMaxOrderByAggregateInput = {
    id?: SortOrder
    billingEmail?: SortOrder
    plan?: SortOrder
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserBillingMinOrderByAggregateInput = {
    id?: SortOrder
    billingEmail?: SortOrder
    plan?: SortOrder
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserBillingSumOrderByAggregateInput = {
    monthlyLimit?: SortOrder
    currentUsage?: SortOrder
  }

  export type AppIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    apiKeyHash?: SortOrder
    syncConfig?: SortOrder
    isActive?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type AppIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    apiKeyHash?: SortOrder
    syncConfig?: SortOrder
    isActive?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type AppIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    baseUrl?: SortOrder
    apiKeyHash?: SortOrder
    syncConfig?: SortOrder
    isActive?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type PipelineStageListRelationFilter = {
    every?: PipelineStageWhereInput
    some?: PipelineStageWhereInput
    none?: PipelineStageWhereInput
  }

  export type PipelineStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestPipelineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type TestPipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type TestPipelineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    config?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type TestPipelineRelationFilter = {
    is?: TestPipelineWhereInput
    isNot?: TestPipelineWhereInput
  }

  export type PipelineStageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    order?: SortOrder
    status?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
  }

  export type PipelineStageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PipelineStageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    order?: SortOrder
    status?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
  }

  export type PipelineStageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    config?: SortOrder
    order?: SortOrder
    status?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
  }

  export type PipelineStageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PipelineExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    result?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    promptId?: SortOrder
    baselinePromptId?: SortOrder
    executedBy?: SortOrder
  }

  export type PipelineExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    result?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    promptId?: SortOrder
    baselinePromptId?: SortOrder
    executedBy?: SortOrder
  }

  export type PipelineExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    result?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    promptId?: SortOrder
    baselinePromptId?: SortOrder
    executedBy?: SortOrder
  }

  export type DependencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    status?: SortOrder
    version?: SortOrder
    healthScore?: SortOrder
    lastCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type DependencyAvgOrderByAggregateInput = {
    healthScore?: SortOrder
  }

  export type DependencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    status?: SortOrder
    version?: SortOrder
    healthScore?: SortOrder
    lastCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type DependencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    config?: SortOrder
    status?: SortOrder
    version?: SortOrder
    healthScore?: SortOrder
    lastCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
  }

  export type DependencySumOrderByAggregateInput = {
    healthScore?: SortOrder
  }

  export type UpdatePlanCountOrderByAggregateInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    executionResult?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    executedBy?: SortOrder
  }

  export type UpdatePlanMaxOrderByAggregateInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    executionResult?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    executedBy?: SortOrder
  }

  export type UpdatePlanMinOrderByAggregateInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    executionResult?: SortOrder
    executedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    createdBy?: SortOrder
    executedBy?: SortOrder
  }

  export type DeploymentPlanCountOrderByAggregateInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    createdBy?: SortOrder
  }

  export type DeploymentPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    createdBy?: SortOrder
  }

  export type DeploymentPlanMinOrderByAggregateInput = {
    id?: SortOrder
    planData?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    createdBy?: SortOrder
  }

  export type DeploymentPlanRelationFilter = {
    is?: DeploymentPlanWhereInput
    isNot?: DeploymentPlanWhereInput
  }

  export type DeploymentExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metrics?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    executedBy?: SortOrder
  }

  export type DeploymentExecutionAvgOrderByAggregateInput = {
    currentStage?: SortOrder
  }

  export type DeploymentExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metrics?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    executedBy?: SortOrder
  }

  export type DeploymentExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    currentStage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metrics?: SortOrder
    error?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    executedBy?: SortOrder
  }

  export type DeploymentExecutionSumOrderByAggregateInput = {
    currentStage?: SortOrder
  }

  export type DeploymentApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    approvedBy?: SortOrder
  }

  export type DeploymentApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    approvedBy?: SortOrder
  }

  export type DeploymentApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    comments?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planId?: SortOrder
    approvedBy?: SortOrder
  }

  export type ImpactAnalysisNullableRelationFilter = {
    is?: ImpactAnalysisWhereInput | null
    isNot?: ImpactAnalysisWhereInput | null
  }

  export type ApprovalRequestCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    appId?: SortOrder
    requestedBy?: SortOrder
    impactAnalysisId?: SortOrder
  }

  export type ApprovalRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    appId?: SortOrder
    requestedBy?: SortOrder
    impactAnalysisId?: SortOrder
  }

  export type ApprovalRequestMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    promptId?: SortOrder
    appId?: SortOrder
    requestedBy?: SortOrder
    impactAnalysisId?: SortOrder
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TestRunCreateNestedManyWithoutUserInput = {
    create?: XOR<TestRunCreateWithoutUserInput, TestRunUncheckedCreateWithoutUserInput> | TestRunCreateWithoutUserInput[] | TestRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutUserInput | TestRunCreateOrConnectWithoutUserInput[]
    createMany?: TestRunCreateManyUserInputEnvelope
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
  }

  export type DeploymentCreateNestedManyWithoutDeployedByUserInput = {
    create?: XOR<DeploymentCreateWithoutDeployedByUserInput, DeploymentUncheckedCreateWithoutDeployedByUserInput> | DeploymentCreateWithoutDeployedByUserInput[] | DeploymentUncheckedCreateWithoutDeployedByUserInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutDeployedByUserInput | DeploymentCreateOrConnectWithoutDeployedByUserInput[]
    createMany?: DeploymentCreateManyDeployedByUserInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type DeploymentHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<DeploymentHistoryCreateWithoutUserInput, DeploymentHistoryUncheckedCreateWithoutUserInput> | DeploymentHistoryCreateWithoutUserInput[] | DeploymentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutUserInput | DeploymentHistoryCreateOrConnectWithoutUserInput[]
    createMany?: DeploymentHistoryCreateManyUserInputEnvelope
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
  }

  export type CostTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<CostTrackingCreateWithoutUserInput, CostTrackingUncheckedCreateWithoutUserInput> | CostTrackingCreateWithoutUserInput[] | CostTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutUserInput | CostTrackingCreateOrConnectWithoutUserInput[]
    createMany?: CostTrackingCreateManyUserInputEnvelope
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
  }

  export type UserBillingCreateNestedOneWithoutUserInput = {
    create?: XOR<UserBillingCreateWithoutUserInput, UserBillingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBillingCreateOrConnectWithoutUserInput
    connect?: UserBillingWhereUniqueInput
  }

  export type AppIntegrationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AppIntegrationCreateWithoutCreatorInput, AppIntegrationUncheckedCreateWithoutCreatorInput> | AppIntegrationCreateWithoutCreatorInput[] | AppIntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutCreatorInput | AppIntegrationCreateOrConnectWithoutCreatorInput[]
    createMany?: AppIntegrationCreateManyCreatorInputEnvelope
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
  }

  export type TestPipelineCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestPipelineCreateWithoutCreatorInput, TestPipelineUncheckedCreateWithoutCreatorInput> | TestPipelineCreateWithoutCreatorInput[] | TestPipelineUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutCreatorInput | TestPipelineCreateOrConnectWithoutCreatorInput[]
    createMany?: TestPipelineCreateManyCreatorInputEnvelope
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
  }

  export type PipelineExecutionCreateNestedManyWithoutExecutorInput = {
    create?: XOR<PipelineExecutionCreateWithoutExecutorInput, PipelineExecutionUncheckedCreateWithoutExecutorInput> | PipelineExecutionCreateWithoutExecutorInput[] | PipelineExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutExecutorInput | PipelineExecutionCreateOrConnectWithoutExecutorInput[]
    createMany?: PipelineExecutionCreateManyExecutorInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type DependencyCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DependencyCreateWithoutCreatorInput, DependencyUncheckedCreateWithoutCreatorInput> | DependencyCreateWithoutCreatorInput[] | DependencyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutCreatorInput | DependencyCreateOrConnectWithoutCreatorInput[]
    createMany?: DependencyCreateManyCreatorInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type UpdatePlanCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UpdatePlanCreateWithoutCreatorInput, UpdatePlanUncheckedCreateWithoutCreatorInput> | UpdatePlanCreateWithoutCreatorInput[] | UpdatePlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutCreatorInput | UpdatePlanCreateOrConnectWithoutCreatorInput[]
    createMany?: UpdatePlanCreateManyCreatorInputEnvelope
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
  }

  export type UpdatePlanCreateNestedManyWithoutExecutorInput = {
    create?: XOR<UpdatePlanCreateWithoutExecutorInput, UpdatePlanUncheckedCreateWithoutExecutorInput> | UpdatePlanCreateWithoutExecutorInput[] | UpdatePlanUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutExecutorInput | UpdatePlanCreateOrConnectWithoutExecutorInput[]
    createMany?: UpdatePlanCreateManyExecutorInputEnvelope
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
  }

  export type DeploymentPlanCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DeploymentPlanCreateWithoutCreatorInput, DeploymentPlanUncheckedCreateWithoutCreatorInput> | DeploymentPlanCreateWithoutCreatorInput[] | DeploymentPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutCreatorInput | DeploymentPlanCreateOrConnectWithoutCreatorInput[]
    createMany?: DeploymentPlanCreateManyCreatorInputEnvelope
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
  }

  export type DeploymentExecutionCreateNestedManyWithoutExecutorInput = {
    create?: XOR<DeploymentExecutionCreateWithoutExecutorInput, DeploymentExecutionUncheckedCreateWithoutExecutorInput> | DeploymentExecutionCreateWithoutExecutorInput[] | DeploymentExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutExecutorInput | DeploymentExecutionCreateOrConnectWithoutExecutorInput[]
    createMany?: DeploymentExecutionCreateManyExecutorInputEnvelope
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
  }

  export type DeploymentApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<DeploymentApprovalCreateWithoutApproverInput, DeploymentApprovalUncheckedCreateWithoutApproverInput> | DeploymentApprovalCreateWithoutApproverInput[] | DeploymentApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutApproverInput | DeploymentApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: DeploymentApprovalCreateManyApproverInputEnvelope
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
  }

  export type ApprovalRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type SyncOperationCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<SyncOperationCreateWithoutInitiatorInput, SyncOperationUncheckedCreateWithoutInitiatorInput> | SyncOperationCreateWithoutInitiatorInput[] | SyncOperationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutInitiatorInput | SyncOperationCreateOrConnectWithoutInitiatorInput[]
    createMany?: SyncOperationCreateManyInitiatorInputEnvelope
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
  }

  export type WebhookSubscriptionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCreatorInput, WebhookSubscriptionUncheckedCreateWithoutCreatorInput> | WebhookSubscriptionCreateWithoutCreatorInput[] | WebhookSubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCreatorInput | WebhookSubscriptionCreateOrConnectWithoutCreatorInput[]
    createMany?: WebhookSubscriptionCreateManyCreatorInputEnvelope
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type TestRunUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestRunCreateWithoutUserInput, TestRunUncheckedCreateWithoutUserInput> | TestRunCreateWithoutUserInput[] | TestRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutUserInput | TestRunCreateOrConnectWithoutUserInput[]
    createMany?: TestRunCreateManyUserInputEnvelope
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
  }

  export type DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput = {
    create?: XOR<DeploymentCreateWithoutDeployedByUserInput, DeploymentUncheckedCreateWithoutDeployedByUserInput> | DeploymentCreateWithoutDeployedByUserInput[] | DeploymentUncheckedCreateWithoutDeployedByUserInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutDeployedByUserInput | DeploymentCreateOrConnectWithoutDeployedByUserInput[]
    createMany?: DeploymentCreateManyDeployedByUserInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeploymentHistoryCreateWithoutUserInput, DeploymentHistoryUncheckedCreateWithoutUserInput> | DeploymentHistoryCreateWithoutUserInput[] | DeploymentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutUserInput | DeploymentHistoryCreateOrConnectWithoutUserInput[]
    createMany?: DeploymentHistoryCreateManyUserInputEnvelope
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
  }

  export type CostTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CostTrackingCreateWithoutUserInput, CostTrackingUncheckedCreateWithoutUserInput> | CostTrackingCreateWithoutUserInput[] | CostTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutUserInput | CostTrackingCreateOrConnectWithoutUserInput[]
    createMany?: CostTrackingCreateManyUserInputEnvelope
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
  }

  export type UserBillingUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserBillingCreateWithoutUserInput, UserBillingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBillingCreateOrConnectWithoutUserInput
    connect?: UserBillingWhereUniqueInput
  }

  export type AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AppIntegrationCreateWithoutCreatorInput, AppIntegrationUncheckedCreateWithoutCreatorInput> | AppIntegrationCreateWithoutCreatorInput[] | AppIntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutCreatorInput | AppIntegrationCreateOrConnectWithoutCreatorInput[]
    createMany?: AppIntegrationCreateManyCreatorInputEnvelope
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
  }

  export type TestPipelineUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TestPipelineCreateWithoutCreatorInput, TestPipelineUncheckedCreateWithoutCreatorInput> | TestPipelineCreateWithoutCreatorInput[] | TestPipelineUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutCreatorInput | TestPipelineCreateOrConnectWithoutCreatorInput[]
    createMany?: TestPipelineCreateManyCreatorInputEnvelope
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
  }

  export type PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput = {
    create?: XOR<PipelineExecutionCreateWithoutExecutorInput, PipelineExecutionUncheckedCreateWithoutExecutorInput> | PipelineExecutionCreateWithoutExecutorInput[] | PipelineExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutExecutorInput | PipelineExecutionCreateOrConnectWithoutExecutorInput[]
    createMany?: PipelineExecutionCreateManyExecutorInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type DependencyUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DependencyCreateWithoutCreatorInput, DependencyUncheckedCreateWithoutCreatorInput> | DependencyCreateWithoutCreatorInput[] | DependencyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutCreatorInput | DependencyCreateOrConnectWithoutCreatorInput[]
    createMany?: DependencyCreateManyCreatorInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UpdatePlanCreateWithoutCreatorInput, UpdatePlanUncheckedCreateWithoutCreatorInput> | UpdatePlanCreateWithoutCreatorInput[] | UpdatePlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutCreatorInput | UpdatePlanCreateOrConnectWithoutCreatorInput[]
    createMany?: UpdatePlanCreateManyCreatorInputEnvelope
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
  }

  export type UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput = {
    create?: XOR<UpdatePlanCreateWithoutExecutorInput, UpdatePlanUncheckedCreateWithoutExecutorInput> | UpdatePlanCreateWithoutExecutorInput[] | UpdatePlanUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutExecutorInput | UpdatePlanCreateOrConnectWithoutExecutorInput[]
    createMany?: UpdatePlanCreateManyExecutorInputEnvelope
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
  }

  export type DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<DeploymentPlanCreateWithoutCreatorInput, DeploymentPlanUncheckedCreateWithoutCreatorInput> | DeploymentPlanCreateWithoutCreatorInput[] | DeploymentPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutCreatorInput | DeploymentPlanCreateOrConnectWithoutCreatorInput[]
    createMany?: DeploymentPlanCreateManyCreatorInputEnvelope
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
  }

  export type DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput = {
    create?: XOR<DeploymentExecutionCreateWithoutExecutorInput, DeploymentExecutionUncheckedCreateWithoutExecutorInput> | DeploymentExecutionCreateWithoutExecutorInput[] | DeploymentExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutExecutorInput | DeploymentExecutionCreateOrConnectWithoutExecutorInput[]
    createMany?: DeploymentExecutionCreateManyExecutorInputEnvelope
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
  }

  export type DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<DeploymentApprovalCreateWithoutApproverInput, DeploymentApprovalUncheckedCreateWithoutApproverInput> | DeploymentApprovalCreateWithoutApproverInput[] | DeploymentApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutApproverInput | DeploymentApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: DeploymentApprovalCreateManyApproverInputEnvelope
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<SyncOperationCreateWithoutInitiatorInput, SyncOperationUncheckedCreateWithoutInitiatorInput> | SyncOperationCreateWithoutInitiatorInput[] | SyncOperationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutInitiatorInput | SyncOperationCreateOrConnectWithoutInitiatorInput[]
    createMany?: SyncOperationCreateManyInitiatorInputEnvelope
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
  }

  export type WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCreatorInput, WebhookSubscriptionUncheckedCreateWithoutCreatorInput> | WebhookSubscriptionCreateWithoutCreatorInput[] | WebhookSubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCreatorInput | WebhookSubscriptionCreateOrConnectWithoutCreatorInput[]
    createMany?: WebhookSubscriptionCreateManyCreatorInputEnvelope
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TestRunUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestRunCreateWithoutUserInput, TestRunUncheckedCreateWithoutUserInput> | TestRunCreateWithoutUserInput[] | TestRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutUserInput | TestRunCreateOrConnectWithoutUserInput[]
    upsert?: TestRunUpsertWithWhereUniqueWithoutUserInput | TestRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestRunCreateManyUserInputEnvelope
    set?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    disconnect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    delete?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    update?: TestRunUpdateWithWhereUniqueWithoutUserInput | TestRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestRunUpdateManyWithWhereWithoutUserInput | TestRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
  }

  export type DeploymentUpdateManyWithoutDeployedByUserNestedInput = {
    create?: XOR<DeploymentCreateWithoutDeployedByUserInput, DeploymentUncheckedCreateWithoutDeployedByUserInput> | DeploymentCreateWithoutDeployedByUserInput[] | DeploymentUncheckedCreateWithoutDeployedByUserInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutDeployedByUserInput | DeploymentCreateOrConnectWithoutDeployedByUserInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutDeployedByUserInput | DeploymentUpsertWithWhereUniqueWithoutDeployedByUserInput[]
    createMany?: DeploymentCreateManyDeployedByUserInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutDeployedByUserInput | DeploymentUpdateWithWhereUniqueWithoutDeployedByUserInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutDeployedByUserInput | DeploymentUpdateManyWithWhereWithoutDeployedByUserInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type DeploymentHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeploymentHistoryCreateWithoutUserInput, DeploymentHistoryUncheckedCreateWithoutUserInput> | DeploymentHistoryCreateWithoutUserInput[] | DeploymentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutUserInput | DeploymentHistoryCreateOrConnectWithoutUserInput[]
    upsert?: DeploymentHistoryUpsertWithWhereUniqueWithoutUserInput | DeploymentHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeploymentHistoryCreateManyUserInputEnvelope
    set?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    disconnect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    delete?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    update?: DeploymentHistoryUpdateWithWhereUniqueWithoutUserInput | DeploymentHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeploymentHistoryUpdateManyWithWhereWithoutUserInput | DeploymentHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeploymentHistoryScalarWhereInput | DeploymentHistoryScalarWhereInput[]
  }

  export type CostTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<CostTrackingCreateWithoutUserInput, CostTrackingUncheckedCreateWithoutUserInput> | CostTrackingCreateWithoutUserInput[] | CostTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutUserInput | CostTrackingCreateOrConnectWithoutUserInput[]
    upsert?: CostTrackingUpsertWithWhereUniqueWithoutUserInput | CostTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CostTrackingCreateManyUserInputEnvelope
    set?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    disconnect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    delete?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    update?: CostTrackingUpdateWithWhereUniqueWithoutUserInput | CostTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CostTrackingUpdateManyWithWhereWithoutUserInput | CostTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CostTrackingScalarWhereInput | CostTrackingScalarWhereInput[]
  }

  export type UserBillingUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserBillingCreateWithoutUserInput, UserBillingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBillingCreateOrConnectWithoutUserInput
    upsert?: UserBillingUpsertWithoutUserInput
    disconnect?: UserBillingWhereInput | boolean
    delete?: UserBillingWhereInput | boolean
    connect?: UserBillingWhereUniqueInput
    update?: XOR<XOR<UserBillingUpdateToOneWithWhereWithoutUserInput, UserBillingUpdateWithoutUserInput>, UserBillingUncheckedUpdateWithoutUserInput>
  }

  export type AppIntegrationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AppIntegrationCreateWithoutCreatorInput, AppIntegrationUncheckedCreateWithoutCreatorInput> | AppIntegrationCreateWithoutCreatorInput[] | AppIntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutCreatorInput | AppIntegrationCreateOrConnectWithoutCreatorInput[]
    upsert?: AppIntegrationUpsertWithWhereUniqueWithoutCreatorInput | AppIntegrationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AppIntegrationCreateManyCreatorInputEnvelope
    set?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    disconnect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    delete?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    update?: AppIntegrationUpdateWithWhereUniqueWithoutCreatorInput | AppIntegrationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AppIntegrationUpdateManyWithWhereWithoutCreatorInput | AppIntegrationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AppIntegrationScalarWhereInput | AppIntegrationScalarWhereInput[]
  }

  export type TestPipelineUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestPipelineCreateWithoutCreatorInput, TestPipelineUncheckedCreateWithoutCreatorInput> | TestPipelineCreateWithoutCreatorInput[] | TestPipelineUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutCreatorInput | TestPipelineCreateOrConnectWithoutCreatorInput[]
    upsert?: TestPipelineUpsertWithWhereUniqueWithoutCreatorInput | TestPipelineUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestPipelineCreateManyCreatorInputEnvelope
    set?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    disconnect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    delete?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    update?: TestPipelineUpdateWithWhereUniqueWithoutCreatorInput | TestPipelineUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestPipelineUpdateManyWithWhereWithoutCreatorInput | TestPipelineUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestPipelineScalarWhereInput | TestPipelineScalarWhereInput[]
  }

  export type PipelineExecutionUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutExecutorInput, PipelineExecutionUncheckedCreateWithoutExecutorInput> | PipelineExecutionCreateWithoutExecutorInput[] | PipelineExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutExecutorInput | PipelineExecutionCreateOrConnectWithoutExecutorInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutExecutorInput | PipelineExecutionUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: PipelineExecutionCreateManyExecutorInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutExecutorInput | PipelineExecutionUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutExecutorInput | PipelineExecutionUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type DependencyUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DependencyCreateWithoutCreatorInput, DependencyUncheckedCreateWithoutCreatorInput> | DependencyCreateWithoutCreatorInput[] | DependencyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutCreatorInput | DependencyCreateOrConnectWithoutCreatorInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutCreatorInput | DependencyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DependencyCreateManyCreatorInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutCreatorInput | DependencyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutCreatorInput | DependencyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type UpdatePlanUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UpdatePlanCreateWithoutCreatorInput, UpdatePlanUncheckedCreateWithoutCreatorInput> | UpdatePlanCreateWithoutCreatorInput[] | UpdatePlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutCreatorInput | UpdatePlanCreateOrConnectWithoutCreatorInput[]
    upsert?: UpdatePlanUpsertWithWhereUniqueWithoutCreatorInput | UpdatePlanUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UpdatePlanCreateManyCreatorInputEnvelope
    set?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    disconnect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    delete?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    update?: UpdatePlanUpdateWithWhereUniqueWithoutCreatorInput | UpdatePlanUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UpdatePlanUpdateManyWithWhereWithoutCreatorInput | UpdatePlanUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
  }

  export type UpdatePlanUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<UpdatePlanCreateWithoutExecutorInput, UpdatePlanUncheckedCreateWithoutExecutorInput> | UpdatePlanCreateWithoutExecutorInput[] | UpdatePlanUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutExecutorInput | UpdatePlanCreateOrConnectWithoutExecutorInput[]
    upsert?: UpdatePlanUpsertWithWhereUniqueWithoutExecutorInput | UpdatePlanUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: UpdatePlanCreateManyExecutorInputEnvelope
    set?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    disconnect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    delete?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    update?: UpdatePlanUpdateWithWhereUniqueWithoutExecutorInput | UpdatePlanUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: UpdatePlanUpdateManyWithWhereWithoutExecutorInput | UpdatePlanUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
  }

  export type DeploymentPlanUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutCreatorInput, DeploymentPlanUncheckedCreateWithoutCreatorInput> | DeploymentPlanCreateWithoutCreatorInput[] | DeploymentPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutCreatorInput | DeploymentPlanCreateOrConnectWithoutCreatorInput[]
    upsert?: DeploymentPlanUpsertWithWhereUniqueWithoutCreatorInput | DeploymentPlanUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DeploymentPlanCreateManyCreatorInputEnvelope
    set?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    disconnect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    delete?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    update?: DeploymentPlanUpdateWithWhereUniqueWithoutCreatorInput | DeploymentPlanUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DeploymentPlanUpdateManyWithWhereWithoutCreatorInput | DeploymentPlanUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
  }

  export type DeploymentExecutionUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<DeploymentExecutionCreateWithoutExecutorInput, DeploymentExecutionUncheckedCreateWithoutExecutorInput> | DeploymentExecutionCreateWithoutExecutorInput[] | DeploymentExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutExecutorInput | DeploymentExecutionCreateOrConnectWithoutExecutorInput[]
    upsert?: DeploymentExecutionUpsertWithWhereUniqueWithoutExecutorInput | DeploymentExecutionUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: DeploymentExecutionCreateManyExecutorInputEnvelope
    set?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    disconnect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    delete?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    update?: DeploymentExecutionUpdateWithWhereUniqueWithoutExecutorInput | DeploymentExecutionUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: DeploymentExecutionUpdateManyWithWhereWithoutExecutorInput | DeploymentExecutionUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: DeploymentExecutionScalarWhereInput | DeploymentExecutionScalarWhereInput[]
  }

  export type DeploymentApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<DeploymentApprovalCreateWithoutApproverInput, DeploymentApprovalUncheckedCreateWithoutApproverInput> | DeploymentApprovalCreateWithoutApproverInput[] | DeploymentApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutApproverInput | DeploymentApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: DeploymentApprovalUpsertWithWhereUniqueWithoutApproverInput | DeploymentApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: DeploymentApprovalCreateManyApproverInputEnvelope
    set?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    disconnect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    delete?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    update?: DeploymentApprovalUpdateWithWhereUniqueWithoutApproverInput | DeploymentApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: DeploymentApprovalUpdateManyWithWhereWithoutApproverInput | DeploymentApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: DeploymentApprovalScalarWhereInput | DeploymentApprovalScalarWhereInput[]
  }

  export type ApprovalRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutRequesterInput | ApprovalRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type SyncOperationUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<SyncOperationCreateWithoutInitiatorInput, SyncOperationUncheckedCreateWithoutInitiatorInput> | SyncOperationCreateWithoutInitiatorInput[] | SyncOperationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutInitiatorInput | SyncOperationCreateOrConnectWithoutInitiatorInput[]
    upsert?: SyncOperationUpsertWithWhereUniqueWithoutInitiatorInput | SyncOperationUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: SyncOperationCreateManyInitiatorInputEnvelope
    set?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    disconnect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    delete?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    update?: SyncOperationUpdateWithWhereUniqueWithoutInitiatorInput | SyncOperationUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: SyncOperationUpdateManyWithWhereWithoutInitiatorInput | SyncOperationUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
  }

  export type WebhookSubscriptionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCreatorInput, WebhookSubscriptionUncheckedCreateWithoutCreatorInput> | WebhookSubscriptionCreateWithoutCreatorInput[] | WebhookSubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCreatorInput | WebhookSubscriptionCreateOrConnectWithoutCreatorInput[]
    upsert?: WebhookSubscriptionUpsertWithWhereUniqueWithoutCreatorInput | WebhookSubscriptionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WebhookSubscriptionCreateManyCreatorInputEnvelope
    set?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    disconnect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    delete?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    update?: WebhookSubscriptionUpdateWithWhereUniqueWithoutCreatorInput | WebhookSubscriptionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WebhookSubscriptionUpdateManyWithWhereWithoutCreatorInput | WebhookSubscriptionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TestRunUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestRunCreateWithoutUserInput, TestRunUncheckedCreateWithoutUserInput> | TestRunCreateWithoutUserInput[] | TestRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutUserInput | TestRunCreateOrConnectWithoutUserInput[]
    upsert?: TestRunUpsertWithWhereUniqueWithoutUserInput | TestRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestRunCreateManyUserInputEnvelope
    set?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    disconnect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    delete?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    update?: TestRunUpdateWithWhereUniqueWithoutUserInput | TestRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestRunUpdateManyWithWhereWithoutUserInput | TestRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
  }

  export type DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput = {
    create?: XOR<DeploymentCreateWithoutDeployedByUserInput, DeploymentUncheckedCreateWithoutDeployedByUserInput> | DeploymentCreateWithoutDeployedByUserInput[] | DeploymentUncheckedCreateWithoutDeployedByUserInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutDeployedByUserInput | DeploymentCreateOrConnectWithoutDeployedByUserInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutDeployedByUserInput | DeploymentUpsertWithWhereUniqueWithoutDeployedByUserInput[]
    createMany?: DeploymentCreateManyDeployedByUserInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutDeployedByUserInput | DeploymentUpdateWithWhereUniqueWithoutDeployedByUserInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutDeployedByUserInput | DeploymentUpdateManyWithWhereWithoutDeployedByUserInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeploymentHistoryCreateWithoutUserInput, DeploymentHistoryUncheckedCreateWithoutUserInput> | DeploymentHistoryCreateWithoutUserInput[] | DeploymentHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutUserInput | DeploymentHistoryCreateOrConnectWithoutUserInput[]
    upsert?: DeploymentHistoryUpsertWithWhereUniqueWithoutUserInput | DeploymentHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeploymentHistoryCreateManyUserInputEnvelope
    set?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    disconnect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    delete?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    update?: DeploymentHistoryUpdateWithWhereUniqueWithoutUserInput | DeploymentHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeploymentHistoryUpdateManyWithWhereWithoutUserInput | DeploymentHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeploymentHistoryScalarWhereInput | DeploymentHistoryScalarWhereInput[]
  }

  export type CostTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CostTrackingCreateWithoutUserInput, CostTrackingUncheckedCreateWithoutUserInput> | CostTrackingCreateWithoutUserInput[] | CostTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutUserInput | CostTrackingCreateOrConnectWithoutUserInput[]
    upsert?: CostTrackingUpsertWithWhereUniqueWithoutUserInput | CostTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CostTrackingCreateManyUserInputEnvelope
    set?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    disconnect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    delete?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    update?: CostTrackingUpdateWithWhereUniqueWithoutUserInput | CostTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CostTrackingUpdateManyWithWhereWithoutUserInput | CostTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CostTrackingScalarWhereInput | CostTrackingScalarWhereInput[]
  }

  export type UserBillingUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserBillingCreateWithoutUserInput, UserBillingUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserBillingCreateOrConnectWithoutUserInput
    upsert?: UserBillingUpsertWithoutUserInput
    disconnect?: UserBillingWhereInput | boolean
    delete?: UserBillingWhereInput | boolean
    connect?: UserBillingWhereUniqueInput
    update?: XOR<XOR<UserBillingUpdateToOneWithWhereWithoutUserInput, UserBillingUpdateWithoutUserInput>, UserBillingUncheckedUpdateWithoutUserInput>
  }

  export type AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AppIntegrationCreateWithoutCreatorInput, AppIntegrationUncheckedCreateWithoutCreatorInput> | AppIntegrationCreateWithoutCreatorInput[] | AppIntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutCreatorInput | AppIntegrationCreateOrConnectWithoutCreatorInput[]
    upsert?: AppIntegrationUpsertWithWhereUniqueWithoutCreatorInput | AppIntegrationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AppIntegrationCreateManyCreatorInputEnvelope
    set?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    disconnect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    delete?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    update?: AppIntegrationUpdateWithWhereUniqueWithoutCreatorInput | AppIntegrationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AppIntegrationUpdateManyWithWhereWithoutCreatorInput | AppIntegrationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AppIntegrationScalarWhereInput | AppIntegrationScalarWhereInput[]
  }

  export type TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TestPipelineCreateWithoutCreatorInput, TestPipelineUncheckedCreateWithoutCreatorInput> | TestPipelineCreateWithoutCreatorInput[] | TestPipelineUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutCreatorInput | TestPipelineCreateOrConnectWithoutCreatorInput[]
    upsert?: TestPipelineUpsertWithWhereUniqueWithoutCreatorInput | TestPipelineUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TestPipelineCreateManyCreatorInputEnvelope
    set?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    disconnect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    delete?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    update?: TestPipelineUpdateWithWhereUniqueWithoutCreatorInput | TestPipelineUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TestPipelineUpdateManyWithWhereWithoutCreatorInput | TestPipelineUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TestPipelineScalarWhereInput | TestPipelineScalarWhereInput[]
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutExecutorInput, PipelineExecutionUncheckedCreateWithoutExecutorInput> | PipelineExecutionCreateWithoutExecutorInput[] | PipelineExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutExecutorInput | PipelineExecutionCreateOrConnectWithoutExecutorInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutExecutorInput | PipelineExecutionUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: PipelineExecutionCreateManyExecutorInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutExecutorInput | PipelineExecutionUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutExecutorInput | PipelineExecutionUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type DependencyUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DependencyCreateWithoutCreatorInput, DependencyUncheckedCreateWithoutCreatorInput> | DependencyCreateWithoutCreatorInput[] | DependencyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutCreatorInput | DependencyCreateOrConnectWithoutCreatorInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutCreatorInput | DependencyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DependencyCreateManyCreatorInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutCreatorInput | DependencyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutCreatorInput | DependencyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UpdatePlanCreateWithoutCreatorInput, UpdatePlanUncheckedCreateWithoutCreatorInput> | UpdatePlanCreateWithoutCreatorInput[] | UpdatePlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutCreatorInput | UpdatePlanCreateOrConnectWithoutCreatorInput[]
    upsert?: UpdatePlanUpsertWithWhereUniqueWithoutCreatorInput | UpdatePlanUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UpdatePlanCreateManyCreatorInputEnvelope
    set?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    disconnect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    delete?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    update?: UpdatePlanUpdateWithWhereUniqueWithoutCreatorInput | UpdatePlanUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UpdatePlanUpdateManyWithWhereWithoutCreatorInput | UpdatePlanUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
  }

  export type UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<UpdatePlanCreateWithoutExecutorInput, UpdatePlanUncheckedCreateWithoutExecutorInput> | UpdatePlanCreateWithoutExecutorInput[] | UpdatePlanUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutExecutorInput | UpdatePlanCreateOrConnectWithoutExecutorInput[]
    upsert?: UpdatePlanUpsertWithWhereUniqueWithoutExecutorInput | UpdatePlanUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: UpdatePlanCreateManyExecutorInputEnvelope
    set?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    disconnect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    delete?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    update?: UpdatePlanUpdateWithWhereUniqueWithoutExecutorInput | UpdatePlanUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: UpdatePlanUpdateManyWithWhereWithoutExecutorInput | UpdatePlanUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
  }

  export type DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutCreatorInput, DeploymentPlanUncheckedCreateWithoutCreatorInput> | DeploymentPlanCreateWithoutCreatorInput[] | DeploymentPlanUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutCreatorInput | DeploymentPlanCreateOrConnectWithoutCreatorInput[]
    upsert?: DeploymentPlanUpsertWithWhereUniqueWithoutCreatorInput | DeploymentPlanUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: DeploymentPlanCreateManyCreatorInputEnvelope
    set?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    disconnect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    delete?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    update?: DeploymentPlanUpdateWithWhereUniqueWithoutCreatorInput | DeploymentPlanUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: DeploymentPlanUpdateManyWithWhereWithoutCreatorInput | DeploymentPlanUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
  }

  export type DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput = {
    create?: XOR<DeploymentExecutionCreateWithoutExecutorInput, DeploymentExecutionUncheckedCreateWithoutExecutorInput> | DeploymentExecutionCreateWithoutExecutorInput[] | DeploymentExecutionUncheckedCreateWithoutExecutorInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutExecutorInput | DeploymentExecutionCreateOrConnectWithoutExecutorInput[]
    upsert?: DeploymentExecutionUpsertWithWhereUniqueWithoutExecutorInput | DeploymentExecutionUpsertWithWhereUniqueWithoutExecutorInput[]
    createMany?: DeploymentExecutionCreateManyExecutorInputEnvelope
    set?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    disconnect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    delete?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    update?: DeploymentExecutionUpdateWithWhereUniqueWithoutExecutorInput | DeploymentExecutionUpdateWithWhereUniqueWithoutExecutorInput[]
    updateMany?: DeploymentExecutionUpdateManyWithWhereWithoutExecutorInput | DeploymentExecutionUpdateManyWithWhereWithoutExecutorInput[]
    deleteMany?: DeploymentExecutionScalarWhereInput | DeploymentExecutionScalarWhereInput[]
  }

  export type DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<DeploymentApprovalCreateWithoutApproverInput, DeploymentApprovalUncheckedCreateWithoutApproverInput> | DeploymentApprovalCreateWithoutApproverInput[] | DeploymentApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutApproverInput | DeploymentApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: DeploymentApprovalUpsertWithWhereUniqueWithoutApproverInput | DeploymentApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: DeploymentApprovalCreateManyApproverInputEnvelope
    set?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    disconnect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    delete?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    update?: DeploymentApprovalUpdateWithWhereUniqueWithoutApproverInput | DeploymentApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: DeploymentApprovalUpdateManyWithWhereWithoutApproverInput | DeploymentApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: DeploymentApprovalScalarWhereInput | DeploymentApprovalScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput> | ApprovalRequestCreateWithoutRequesterInput[] | ApprovalRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequesterInput | ApprovalRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ApprovalRequestCreateManyRequesterInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput | ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutRequesterInput | ApprovalRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<SyncOperationCreateWithoutInitiatorInput, SyncOperationUncheckedCreateWithoutInitiatorInput> | SyncOperationCreateWithoutInitiatorInput[] | SyncOperationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutInitiatorInput | SyncOperationCreateOrConnectWithoutInitiatorInput[]
    upsert?: SyncOperationUpsertWithWhereUniqueWithoutInitiatorInput | SyncOperationUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: SyncOperationCreateManyInitiatorInputEnvelope
    set?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    disconnect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    delete?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    update?: SyncOperationUpdateWithWhereUniqueWithoutInitiatorInput | SyncOperationUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: SyncOperationUpdateManyWithWhereWithoutInitiatorInput | SyncOperationUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
  }

  export type WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutCreatorInput, WebhookSubscriptionUncheckedCreateWithoutCreatorInput> | WebhookSubscriptionCreateWithoutCreatorInput[] | WebhookSubscriptionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutCreatorInput | WebhookSubscriptionCreateOrConnectWithoutCreatorInput[]
    upsert?: WebhookSubscriptionUpsertWithWhereUniqueWithoutCreatorInput | WebhookSubscriptionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WebhookSubscriptionCreateManyCreatorInputEnvelope
    set?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    disconnect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    delete?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    update?: WebhookSubscriptionUpdateWithWhereUniqueWithoutCreatorInput | WebhookSubscriptionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WebhookSubscriptionUpdateManyWithWhereWithoutCreatorInput | WebhookSubscriptionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PromptCreateNestedManyWithoutProjectInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type TestRunCreateNestedManyWithoutProjectInput = {
    create?: XOR<TestRunCreateWithoutProjectInput, TestRunUncheckedCreateWithoutProjectInput> | TestRunCreateWithoutProjectInput[] | TestRunUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutProjectInput | TestRunCreateOrConnectWithoutProjectInput[]
    createMany?: TestRunCreateManyProjectInputEnvelope
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type EnvironmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<EnvironmentCreateWithoutProjectInput, EnvironmentUncheckedCreateWithoutProjectInput> | EnvironmentCreateWithoutProjectInput[] | EnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnvironmentCreateOrConnectWithoutProjectInput | EnvironmentCreateOrConnectWithoutProjectInput[]
    createMany?: EnvironmentCreateManyProjectInputEnvelope
    connect?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
  }

  export type CostTrackingCreateNestedManyWithoutProjectInput = {
    create?: XOR<CostTrackingCreateWithoutProjectInput, CostTrackingUncheckedCreateWithoutProjectInput> | CostTrackingCreateWithoutProjectInput[] | CostTrackingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutProjectInput | CostTrackingCreateOrConnectWithoutProjectInput[]
    createMany?: CostTrackingCreateManyProjectInputEnvelope
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
  }

  export type AppIntegrationCreateNestedManyWithoutProjectInput = {
    create?: XOR<AppIntegrationCreateWithoutProjectInput, AppIntegrationUncheckedCreateWithoutProjectInput> | AppIntegrationCreateWithoutProjectInput[] | AppIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutProjectInput | AppIntegrationCreateOrConnectWithoutProjectInput[]
    createMany?: AppIntegrationCreateManyProjectInputEnvelope
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
  }

  export type TestPipelineCreateNestedManyWithoutProjectInput = {
    create?: XOR<TestPipelineCreateWithoutProjectInput, TestPipelineUncheckedCreateWithoutProjectInput> | TestPipelineCreateWithoutProjectInput[] | TestPipelineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutProjectInput | TestPipelineCreateOrConnectWithoutProjectInput[]
    createMany?: TestPipelineCreateManyProjectInputEnvelope
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
  }

  export type DependencyCreateNestedManyWithoutProjectInput = {
    create?: XOR<DependencyCreateWithoutProjectInput, DependencyUncheckedCreateWithoutProjectInput> | DependencyCreateWithoutProjectInput[] | DependencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutProjectInput | DependencyCreateOrConnectWithoutProjectInput[]
    createMany?: DependencyCreateManyProjectInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type UpdatePlanCreateNestedManyWithoutProjectInput = {
    create?: XOR<UpdatePlanCreateWithoutProjectInput, UpdatePlanUncheckedCreateWithoutProjectInput> | UpdatePlanCreateWithoutProjectInput[] | UpdatePlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutProjectInput | UpdatePlanCreateOrConnectWithoutProjectInput[]
    createMany?: UpdatePlanCreateManyProjectInputEnvelope
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
  }

  export type DeploymentPlanCreateNestedManyWithoutProjectInput = {
    create?: XOR<DeploymentPlanCreateWithoutProjectInput, DeploymentPlanUncheckedCreateWithoutProjectInput> | DeploymentPlanCreateWithoutProjectInput[] | DeploymentPlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutProjectInput | DeploymentPlanCreateOrConnectWithoutProjectInput[]
    createMany?: DeploymentPlanCreateManyProjectInputEnvelope
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
  }

  export type ApprovalRequestCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApprovalRequestCreateWithoutProjectInput, ApprovalRequestUncheckedCreateWithoutProjectInput> | ApprovalRequestCreateWithoutProjectInput[] | ApprovalRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutProjectInput | ApprovalRequestCreateOrConnectWithoutProjectInput[]
    createMany?: ApprovalRequestCreateManyProjectInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type SyncOperationCreateNestedManyWithoutProjectInput = {
    create?: XOR<SyncOperationCreateWithoutProjectInput, SyncOperationUncheckedCreateWithoutProjectInput> | SyncOperationCreateWithoutProjectInput[] | SyncOperationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutProjectInput | SyncOperationCreateOrConnectWithoutProjectInput[]
    createMany?: SyncOperationCreateManyProjectInputEnvelope
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
  }

  export type WebhookDeliveryCreateNestedManyWithoutProjectInput = {
    create?: XOR<WebhookDeliveryCreateWithoutProjectInput, WebhookDeliveryUncheckedCreateWithoutProjectInput> | WebhookDeliveryCreateWithoutProjectInput[] | WebhookDeliveryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutProjectInput | WebhookDeliveryCreateOrConnectWithoutProjectInput[]
    createMany?: WebhookDeliveryCreateManyProjectInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookSubscriptionCreateNestedManyWithoutProjectInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutProjectInput, WebhookSubscriptionUncheckedCreateWithoutProjectInput> | WebhookSubscriptionCreateWithoutProjectInput[] | WebhookSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutProjectInput | WebhookSubscriptionCreateOrConnectWithoutProjectInput[]
    createMany?: WebhookSubscriptionCreateManyProjectInputEnvelope
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PromptUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type TestRunUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TestRunCreateWithoutProjectInput, TestRunUncheckedCreateWithoutProjectInput> | TestRunCreateWithoutProjectInput[] | TestRunUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutProjectInput | TestRunCreateOrConnectWithoutProjectInput[]
    createMany?: TestRunCreateManyProjectInputEnvelope
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type EnvironmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<EnvironmentCreateWithoutProjectInput, EnvironmentUncheckedCreateWithoutProjectInput> | EnvironmentCreateWithoutProjectInput[] | EnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnvironmentCreateOrConnectWithoutProjectInput | EnvironmentCreateOrConnectWithoutProjectInput[]
    createMany?: EnvironmentCreateManyProjectInputEnvelope
    connect?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
  }

  export type CostTrackingUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CostTrackingCreateWithoutProjectInput, CostTrackingUncheckedCreateWithoutProjectInput> | CostTrackingCreateWithoutProjectInput[] | CostTrackingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutProjectInput | CostTrackingCreateOrConnectWithoutProjectInput[]
    createMany?: CostTrackingCreateManyProjectInputEnvelope
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
  }

  export type AppIntegrationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AppIntegrationCreateWithoutProjectInput, AppIntegrationUncheckedCreateWithoutProjectInput> | AppIntegrationCreateWithoutProjectInput[] | AppIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutProjectInput | AppIntegrationCreateOrConnectWithoutProjectInput[]
    createMany?: AppIntegrationCreateManyProjectInputEnvelope
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
  }

  export type TestPipelineUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TestPipelineCreateWithoutProjectInput, TestPipelineUncheckedCreateWithoutProjectInput> | TestPipelineCreateWithoutProjectInput[] | TestPipelineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutProjectInput | TestPipelineCreateOrConnectWithoutProjectInput[]
    createMany?: TestPipelineCreateManyProjectInputEnvelope
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
  }

  export type DependencyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DependencyCreateWithoutProjectInput, DependencyUncheckedCreateWithoutProjectInput> | DependencyCreateWithoutProjectInput[] | DependencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutProjectInput | DependencyCreateOrConnectWithoutProjectInput[]
    createMany?: DependencyCreateManyProjectInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type UpdatePlanUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UpdatePlanCreateWithoutProjectInput, UpdatePlanUncheckedCreateWithoutProjectInput> | UpdatePlanCreateWithoutProjectInput[] | UpdatePlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutProjectInput | UpdatePlanCreateOrConnectWithoutProjectInput[]
    createMany?: UpdatePlanCreateManyProjectInputEnvelope
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
  }

  export type DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DeploymentPlanCreateWithoutProjectInput, DeploymentPlanUncheckedCreateWithoutProjectInput> | DeploymentPlanCreateWithoutProjectInput[] | DeploymentPlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutProjectInput | DeploymentPlanCreateOrConnectWithoutProjectInput[]
    createMany?: DeploymentPlanCreateManyProjectInputEnvelope
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApprovalRequestCreateWithoutProjectInput, ApprovalRequestUncheckedCreateWithoutProjectInput> | ApprovalRequestCreateWithoutProjectInput[] | ApprovalRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutProjectInput | ApprovalRequestCreateOrConnectWithoutProjectInput[]
    createMany?: ApprovalRequestCreateManyProjectInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type SyncOperationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SyncOperationCreateWithoutProjectInput, SyncOperationUncheckedCreateWithoutProjectInput> | SyncOperationCreateWithoutProjectInput[] | SyncOperationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutProjectInput | SyncOperationCreateOrConnectWithoutProjectInput[]
    createMany?: SyncOperationCreateManyProjectInputEnvelope
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WebhookDeliveryCreateWithoutProjectInput, WebhookDeliveryUncheckedCreateWithoutProjectInput> | WebhookDeliveryCreateWithoutProjectInput[] | WebhookDeliveryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutProjectInput | WebhookDeliveryCreateOrConnectWithoutProjectInput[]
    createMany?: WebhookDeliveryCreateManyProjectInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutProjectInput, WebhookSubscriptionUncheckedCreateWithoutProjectInput> | WebhookSubscriptionCreateWithoutProjectInput[] | WebhookSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutProjectInput | WebhookSubscriptionCreateOrConnectWithoutProjectInput[]
    createMany?: WebhookSubscriptionCreateManyProjectInputEnvelope
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    upsert?: UserUpsertWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedProjectsInput, UserUpdateWithoutOwnedProjectsInput>, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PromptUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutProjectInput | PromptUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutProjectInput | PromptUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutProjectInput | PromptUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type TestRunUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TestRunCreateWithoutProjectInput, TestRunUncheckedCreateWithoutProjectInput> | TestRunCreateWithoutProjectInput[] | TestRunUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutProjectInput | TestRunCreateOrConnectWithoutProjectInput[]
    upsert?: TestRunUpsertWithWhereUniqueWithoutProjectInput | TestRunUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TestRunCreateManyProjectInputEnvelope
    set?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    disconnect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    delete?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    update?: TestRunUpdateWithWhereUniqueWithoutProjectInput | TestRunUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TestRunUpdateManyWithWhereWithoutProjectInput | TestRunUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutProjectInput | ApiKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutProjectInput | ApiKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutProjectInput | ApiKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type EnvironmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EnvironmentCreateWithoutProjectInput, EnvironmentUncheckedCreateWithoutProjectInput> | EnvironmentCreateWithoutProjectInput[] | EnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnvironmentCreateOrConnectWithoutProjectInput | EnvironmentCreateOrConnectWithoutProjectInput[]
    upsert?: EnvironmentUpsertWithWhereUniqueWithoutProjectInput | EnvironmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EnvironmentCreateManyProjectInputEnvelope
    set?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    disconnect?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    delete?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    connect?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    update?: EnvironmentUpdateWithWhereUniqueWithoutProjectInput | EnvironmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EnvironmentUpdateManyWithWhereWithoutProjectInput | EnvironmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EnvironmentScalarWhereInput | EnvironmentScalarWhereInput[]
  }

  export type CostTrackingUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CostTrackingCreateWithoutProjectInput, CostTrackingUncheckedCreateWithoutProjectInput> | CostTrackingCreateWithoutProjectInput[] | CostTrackingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutProjectInput | CostTrackingCreateOrConnectWithoutProjectInput[]
    upsert?: CostTrackingUpsertWithWhereUniqueWithoutProjectInput | CostTrackingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CostTrackingCreateManyProjectInputEnvelope
    set?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    disconnect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    delete?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    update?: CostTrackingUpdateWithWhereUniqueWithoutProjectInput | CostTrackingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CostTrackingUpdateManyWithWhereWithoutProjectInput | CostTrackingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CostTrackingScalarWhereInput | CostTrackingScalarWhereInput[]
  }

  export type AppIntegrationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AppIntegrationCreateWithoutProjectInput, AppIntegrationUncheckedCreateWithoutProjectInput> | AppIntegrationCreateWithoutProjectInput[] | AppIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutProjectInput | AppIntegrationCreateOrConnectWithoutProjectInput[]
    upsert?: AppIntegrationUpsertWithWhereUniqueWithoutProjectInput | AppIntegrationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AppIntegrationCreateManyProjectInputEnvelope
    set?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    disconnect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    delete?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    update?: AppIntegrationUpdateWithWhereUniqueWithoutProjectInput | AppIntegrationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AppIntegrationUpdateManyWithWhereWithoutProjectInput | AppIntegrationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AppIntegrationScalarWhereInput | AppIntegrationScalarWhereInput[]
  }

  export type TestPipelineUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TestPipelineCreateWithoutProjectInput, TestPipelineUncheckedCreateWithoutProjectInput> | TestPipelineCreateWithoutProjectInput[] | TestPipelineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutProjectInput | TestPipelineCreateOrConnectWithoutProjectInput[]
    upsert?: TestPipelineUpsertWithWhereUniqueWithoutProjectInput | TestPipelineUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TestPipelineCreateManyProjectInputEnvelope
    set?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    disconnect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    delete?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    update?: TestPipelineUpdateWithWhereUniqueWithoutProjectInput | TestPipelineUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TestPipelineUpdateManyWithWhereWithoutProjectInput | TestPipelineUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TestPipelineScalarWhereInput | TestPipelineScalarWhereInput[]
  }

  export type DependencyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DependencyCreateWithoutProjectInput, DependencyUncheckedCreateWithoutProjectInput> | DependencyCreateWithoutProjectInput[] | DependencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutProjectInput | DependencyCreateOrConnectWithoutProjectInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutProjectInput | DependencyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DependencyCreateManyProjectInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutProjectInput | DependencyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutProjectInput | DependencyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type UpdatePlanUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UpdatePlanCreateWithoutProjectInput, UpdatePlanUncheckedCreateWithoutProjectInput> | UpdatePlanCreateWithoutProjectInput[] | UpdatePlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutProjectInput | UpdatePlanCreateOrConnectWithoutProjectInput[]
    upsert?: UpdatePlanUpsertWithWhereUniqueWithoutProjectInput | UpdatePlanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UpdatePlanCreateManyProjectInputEnvelope
    set?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    disconnect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    delete?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    update?: UpdatePlanUpdateWithWhereUniqueWithoutProjectInput | UpdatePlanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UpdatePlanUpdateManyWithWhereWithoutProjectInput | UpdatePlanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
  }

  export type DeploymentPlanUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutProjectInput, DeploymentPlanUncheckedCreateWithoutProjectInput> | DeploymentPlanCreateWithoutProjectInput[] | DeploymentPlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutProjectInput | DeploymentPlanCreateOrConnectWithoutProjectInput[]
    upsert?: DeploymentPlanUpsertWithWhereUniqueWithoutProjectInput | DeploymentPlanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DeploymentPlanCreateManyProjectInputEnvelope
    set?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    disconnect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    delete?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    update?: DeploymentPlanUpdateWithWhereUniqueWithoutProjectInput | DeploymentPlanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DeploymentPlanUpdateManyWithWhereWithoutProjectInput | DeploymentPlanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
  }

  export type ApprovalRequestUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutProjectInput, ApprovalRequestUncheckedCreateWithoutProjectInput> | ApprovalRequestCreateWithoutProjectInput[] | ApprovalRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutProjectInput | ApprovalRequestCreateOrConnectWithoutProjectInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutProjectInput | ApprovalRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApprovalRequestCreateManyProjectInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutProjectInput | ApprovalRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutProjectInput | ApprovalRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type SyncOperationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SyncOperationCreateWithoutProjectInput, SyncOperationUncheckedCreateWithoutProjectInput> | SyncOperationCreateWithoutProjectInput[] | SyncOperationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutProjectInput | SyncOperationCreateOrConnectWithoutProjectInput[]
    upsert?: SyncOperationUpsertWithWhereUniqueWithoutProjectInput | SyncOperationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SyncOperationCreateManyProjectInputEnvelope
    set?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    disconnect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    delete?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    update?: SyncOperationUpdateWithWhereUniqueWithoutProjectInput | SyncOperationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SyncOperationUpdateManyWithWhereWithoutProjectInput | SyncOperationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
  }

  export type WebhookDeliveryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutProjectInput, WebhookDeliveryUncheckedCreateWithoutProjectInput> | WebhookDeliveryCreateWithoutProjectInput[] | WebhookDeliveryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutProjectInput | WebhookDeliveryCreateOrConnectWithoutProjectInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutProjectInput | WebhookDeliveryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WebhookDeliveryCreateManyProjectInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutProjectInput | WebhookDeliveryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutProjectInput | WebhookDeliveryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookSubscriptionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutProjectInput, WebhookSubscriptionUncheckedCreateWithoutProjectInput> | WebhookSubscriptionCreateWithoutProjectInput[] | WebhookSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutProjectInput | WebhookSubscriptionCreateOrConnectWithoutProjectInput[]
    upsert?: WebhookSubscriptionUpsertWithWhereUniqueWithoutProjectInput | WebhookSubscriptionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WebhookSubscriptionCreateManyProjectInputEnvelope
    set?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    disconnect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    delete?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    update?: WebhookSubscriptionUpdateWithWhereUniqueWithoutProjectInput | WebhookSubscriptionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WebhookSubscriptionUpdateManyWithWhereWithoutProjectInput | WebhookSubscriptionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PromptUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput> | PromptCreateWithoutProjectInput[] | PromptUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutProjectInput | PromptCreateOrConnectWithoutProjectInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutProjectInput | PromptUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PromptCreateManyProjectInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutProjectInput | PromptUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutProjectInput | PromptUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type TestRunUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TestRunCreateWithoutProjectInput, TestRunUncheckedCreateWithoutProjectInput> | TestRunCreateWithoutProjectInput[] | TestRunUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutProjectInput | TestRunCreateOrConnectWithoutProjectInput[]
    upsert?: TestRunUpsertWithWhereUniqueWithoutProjectInput | TestRunUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TestRunCreateManyProjectInputEnvelope
    set?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    disconnect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    delete?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    update?: TestRunUpdateWithWhereUniqueWithoutProjectInput | TestRunUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TestRunUpdateManyWithWhereWithoutProjectInput | TestRunUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput> | ApiKeyCreateWithoutProjectInput[] | ApiKeyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutProjectInput | ApiKeyCreateOrConnectWithoutProjectInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutProjectInput | ApiKeyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiKeyCreateManyProjectInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutProjectInput | ApiKeyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutProjectInput | ApiKeyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type EnvironmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<EnvironmentCreateWithoutProjectInput, EnvironmentUncheckedCreateWithoutProjectInput> | EnvironmentCreateWithoutProjectInput[] | EnvironmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: EnvironmentCreateOrConnectWithoutProjectInput | EnvironmentCreateOrConnectWithoutProjectInput[]
    upsert?: EnvironmentUpsertWithWhereUniqueWithoutProjectInput | EnvironmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: EnvironmentCreateManyProjectInputEnvelope
    set?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    disconnect?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    delete?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    connect?: EnvironmentWhereUniqueInput | EnvironmentWhereUniqueInput[]
    update?: EnvironmentUpdateWithWhereUniqueWithoutProjectInput | EnvironmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: EnvironmentUpdateManyWithWhereWithoutProjectInput | EnvironmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: EnvironmentScalarWhereInput | EnvironmentScalarWhereInput[]
  }

  export type CostTrackingUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CostTrackingCreateWithoutProjectInput, CostTrackingUncheckedCreateWithoutProjectInput> | CostTrackingCreateWithoutProjectInput[] | CostTrackingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CostTrackingCreateOrConnectWithoutProjectInput | CostTrackingCreateOrConnectWithoutProjectInput[]
    upsert?: CostTrackingUpsertWithWhereUniqueWithoutProjectInput | CostTrackingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CostTrackingCreateManyProjectInputEnvelope
    set?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    disconnect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    delete?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    connect?: CostTrackingWhereUniqueInput | CostTrackingWhereUniqueInput[]
    update?: CostTrackingUpdateWithWhereUniqueWithoutProjectInput | CostTrackingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CostTrackingUpdateManyWithWhereWithoutProjectInput | CostTrackingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CostTrackingScalarWhereInput | CostTrackingScalarWhereInput[]
  }

  export type AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AppIntegrationCreateWithoutProjectInput, AppIntegrationUncheckedCreateWithoutProjectInput> | AppIntegrationCreateWithoutProjectInput[] | AppIntegrationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutProjectInput | AppIntegrationCreateOrConnectWithoutProjectInput[]
    upsert?: AppIntegrationUpsertWithWhereUniqueWithoutProjectInput | AppIntegrationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AppIntegrationCreateManyProjectInputEnvelope
    set?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    disconnect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    delete?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    connect?: AppIntegrationWhereUniqueInput | AppIntegrationWhereUniqueInput[]
    update?: AppIntegrationUpdateWithWhereUniqueWithoutProjectInput | AppIntegrationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AppIntegrationUpdateManyWithWhereWithoutProjectInput | AppIntegrationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AppIntegrationScalarWhereInput | AppIntegrationScalarWhereInput[]
  }

  export type TestPipelineUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TestPipelineCreateWithoutProjectInput, TestPipelineUncheckedCreateWithoutProjectInput> | TestPipelineCreateWithoutProjectInput[] | TestPipelineUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TestPipelineCreateOrConnectWithoutProjectInput | TestPipelineCreateOrConnectWithoutProjectInput[]
    upsert?: TestPipelineUpsertWithWhereUniqueWithoutProjectInput | TestPipelineUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TestPipelineCreateManyProjectInputEnvelope
    set?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    disconnect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    delete?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    connect?: TestPipelineWhereUniqueInput | TestPipelineWhereUniqueInput[]
    update?: TestPipelineUpdateWithWhereUniqueWithoutProjectInput | TestPipelineUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TestPipelineUpdateManyWithWhereWithoutProjectInput | TestPipelineUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TestPipelineScalarWhereInput | TestPipelineScalarWhereInput[]
  }

  export type DependencyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DependencyCreateWithoutProjectInput, DependencyUncheckedCreateWithoutProjectInput> | DependencyCreateWithoutProjectInput[] | DependencyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutProjectInput | DependencyCreateOrConnectWithoutProjectInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutProjectInput | DependencyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DependencyCreateManyProjectInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutProjectInput | DependencyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutProjectInput | DependencyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UpdatePlanCreateWithoutProjectInput, UpdatePlanUncheckedCreateWithoutProjectInput> | UpdatePlanCreateWithoutProjectInput[] | UpdatePlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UpdatePlanCreateOrConnectWithoutProjectInput | UpdatePlanCreateOrConnectWithoutProjectInput[]
    upsert?: UpdatePlanUpsertWithWhereUniqueWithoutProjectInput | UpdatePlanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UpdatePlanCreateManyProjectInputEnvelope
    set?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    disconnect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    delete?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    connect?: UpdatePlanWhereUniqueInput | UpdatePlanWhereUniqueInput[]
    update?: UpdatePlanUpdateWithWhereUniqueWithoutProjectInput | UpdatePlanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UpdatePlanUpdateManyWithWhereWithoutProjectInput | UpdatePlanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
  }

  export type DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutProjectInput, DeploymentPlanUncheckedCreateWithoutProjectInput> | DeploymentPlanCreateWithoutProjectInput[] | DeploymentPlanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutProjectInput | DeploymentPlanCreateOrConnectWithoutProjectInput[]
    upsert?: DeploymentPlanUpsertWithWhereUniqueWithoutProjectInput | DeploymentPlanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DeploymentPlanCreateManyProjectInputEnvelope
    set?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    disconnect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    delete?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    update?: DeploymentPlanUpdateWithWhereUniqueWithoutProjectInput | DeploymentPlanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DeploymentPlanUpdateManyWithWhereWithoutProjectInput | DeploymentPlanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutProjectInput, ApprovalRequestUncheckedCreateWithoutProjectInput> | ApprovalRequestCreateWithoutProjectInput[] | ApprovalRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutProjectInput | ApprovalRequestCreateOrConnectWithoutProjectInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutProjectInput | ApprovalRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApprovalRequestCreateManyProjectInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutProjectInput | ApprovalRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutProjectInput | ApprovalRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type SyncOperationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SyncOperationCreateWithoutProjectInput, SyncOperationUncheckedCreateWithoutProjectInput> | SyncOperationCreateWithoutProjectInput[] | SyncOperationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutProjectInput | SyncOperationCreateOrConnectWithoutProjectInput[]
    upsert?: SyncOperationUpsertWithWhereUniqueWithoutProjectInput | SyncOperationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SyncOperationCreateManyProjectInputEnvelope
    set?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    disconnect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    delete?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    update?: SyncOperationUpdateWithWhereUniqueWithoutProjectInput | SyncOperationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SyncOperationUpdateManyWithWhereWithoutProjectInput | SyncOperationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutProjectInput, WebhookDeliveryUncheckedCreateWithoutProjectInput> | WebhookDeliveryCreateWithoutProjectInput[] | WebhookDeliveryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutProjectInput | WebhookDeliveryCreateOrConnectWithoutProjectInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutProjectInput | WebhookDeliveryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WebhookDeliveryCreateManyProjectInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutProjectInput | WebhookDeliveryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutProjectInput | WebhookDeliveryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutProjectInput, WebhookSubscriptionUncheckedCreateWithoutProjectInput> | WebhookSubscriptionCreateWithoutProjectInput[] | WebhookSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutProjectInput | WebhookSubscriptionCreateOrConnectWithoutProjectInput[]
    upsert?: WebhookSubscriptionUpsertWithWhereUniqueWithoutProjectInput | WebhookSubscriptionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WebhookSubscriptionCreateManyProjectInputEnvelope
    set?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    disconnect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    delete?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    connect?: WebhookSubscriptionWhereUniqueInput | WebhookSubscriptionWhereUniqueInput[]
    update?: WebhookSubscriptionUpdateWithWhereUniqueWithoutProjectInput | WebhookSubscriptionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WebhookSubscriptionUpdateManyWithWhereWithoutProjectInput | WebhookSubscriptionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    upsert?: UserUpsertWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembershipsInput, UserUpdateWithoutProjectMembershipsInput>, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type ProjectCreateNestedOneWithoutPromptsInput = {
    create?: XOR<ProjectCreateWithoutPromptsInput, ProjectUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPromptsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutVersionsInput = {
    create?: XOR<PromptCreateWithoutVersionsInput, PromptUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutVersionsInput
    connect?: PromptWhereUniqueInput
  }

  export type PromptCreateNestedManyWithoutParentInput = {
    create?: XOR<PromptCreateWithoutParentInput, PromptUncheckedCreateWithoutParentInput> | PromptCreateWithoutParentInput[] | PromptUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutParentInput | PromptCreateOrConnectWithoutParentInput[]
    createMany?: PromptCreateManyParentInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type TestRunCreateNestedManyWithoutPromptInput = {
    create?: XOR<TestRunCreateWithoutPromptInput, TestRunUncheckedCreateWithoutPromptInput> | TestRunCreateWithoutPromptInput[] | TestRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutPromptInput | TestRunCreateOrConnectWithoutPromptInput[]
    createMany?: TestRunCreateManyPromptInputEnvelope
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
  }

  export type DeploymentCreateNestedManyWithoutPromptInput = {
    create?: XOR<DeploymentCreateWithoutPromptInput, DeploymentUncheckedCreateWithoutPromptInput> | DeploymentCreateWithoutPromptInput[] | DeploymentUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutPromptInput | DeploymentCreateOrConnectWithoutPromptInput[]
    createMany?: DeploymentCreateManyPromptInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput = {
    create?: XOR<ImpactAnalysisCreateWithoutBaselinePromptInput, ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput> | ImpactAnalysisCreateWithoutBaselinePromptInput[] | ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput | ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput[]
    createMany?: ImpactAnalysisCreateManyBaselinePromptInputEnvelope
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
  }

  export type PipelineExecutionCreateNestedManyWithoutPromptInput = {
    create?: XOR<PipelineExecutionCreateWithoutPromptInput, PipelineExecutionUncheckedCreateWithoutPromptInput> | PipelineExecutionCreateWithoutPromptInput[] | PipelineExecutionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPromptInput | PipelineExecutionCreateOrConnectWithoutPromptInput[]
    createMany?: PipelineExecutionCreateManyPromptInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type PipelineExecutionCreateNestedManyWithoutBaselinePromptInput = {
    create?: XOR<PipelineExecutionCreateWithoutBaselinePromptInput, PipelineExecutionUncheckedCreateWithoutBaselinePromptInput> | PipelineExecutionCreateWithoutBaselinePromptInput[] | PipelineExecutionUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutBaselinePromptInput | PipelineExecutionCreateOrConnectWithoutBaselinePromptInput[]
    createMany?: PipelineExecutionCreateManyBaselinePromptInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type DeploymentPlanCreateNestedManyWithoutPromptInput = {
    create?: XOR<DeploymentPlanCreateWithoutPromptInput, DeploymentPlanUncheckedCreateWithoutPromptInput> | DeploymentPlanCreateWithoutPromptInput[] | DeploymentPlanUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutPromptInput | DeploymentPlanCreateOrConnectWithoutPromptInput[]
    createMany?: DeploymentPlanCreateManyPromptInputEnvelope
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
  }

  export type ApprovalRequestCreateNestedManyWithoutPromptInput = {
    create?: XOR<ApprovalRequestCreateWithoutPromptInput, ApprovalRequestUncheckedCreateWithoutPromptInput> | ApprovalRequestCreateWithoutPromptInput[] | ApprovalRequestUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutPromptInput | ApprovalRequestCreateOrConnectWithoutPromptInput[]
    createMany?: ApprovalRequestCreateManyPromptInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type PromptUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PromptCreateWithoutParentInput, PromptUncheckedCreateWithoutParentInput> | PromptCreateWithoutParentInput[] | PromptUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutParentInput | PromptCreateOrConnectWithoutParentInput[]
    createMany?: PromptCreateManyParentInputEnvelope
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
  }

  export type TestRunUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<TestRunCreateWithoutPromptInput, TestRunUncheckedCreateWithoutPromptInput> | TestRunCreateWithoutPromptInput[] | TestRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutPromptInput | TestRunCreateOrConnectWithoutPromptInput[]
    createMany?: TestRunCreateManyPromptInputEnvelope
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
  }

  export type DeploymentUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<DeploymentCreateWithoutPromptInput, DeploymentUncheckedCreateWithoutPromptInput> | DeploymentCreateWithoutPromptInput[] | DeploymentUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutPromptInput | DeploymentCreateOrConnectWithoutPromptInput[]
    createMany?: DeploymentCreateManyPromptInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput = {
    create?: XOR<ImpactAnalysisCreateWithoutBaselinePromptInput, ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput> | ImpactAnalysisCreateWithoutBaselinePromptInput[] | ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput | ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput[]
    createMany?: ImpactAnalysisCreateManyBaselinePromptInputEnvelope
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
  }

  export type PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<PipelineExecutionCreateWithoutPromptInput, PipelineExecutionUncheckedCreateWithoutPromptInput> | PipelineExecutionCreateWithoutPromptInput[] | PipelineExecutionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPromptInput | PipelineExecutionCreateOrConnectWithoutPromptInput[]
    createMany?: PipelineExecutionCreateManyPromptInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput = {
    create?: XOR<PipelineExecutionCreateWithoutBaselinePromptInput, PipelineExecutionUncheckedCreateWithoutBaselinePromptInput> | PipelineExecutionCreateWithoutBaselinePromptInput[] | PipelineExecutionUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutBaselinePromptInput | PipelineExecutionCreateOrConnectWithoutBaselinePromptInput[]
    createMany?: PipelineExecutionCreateManyBaselinePromptInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<DeploymentPlanCreateWithoutPromptInput, DeploymentPlanUncheckedCreateWithoutPromptInput> | DeploymentPlanCreateWithoutPromptInput[] | DeploymentPlanUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutPromptInput | DeploymentPlanCreateOrConnectWithoutPromptInput[]
    createMany?: DeploymentPlanCreateManyPromptInputEnvelope
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<ApprovalRequestCreateWithoutPromptInput, ApprovalRequestUncheckedCreateWithoutPromptInput> | ApprovalRequestCreateWithoutPromptInput[] | ApprovalRequestUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutPromptInput | ApprovalRequestCreateOrConnectWithoutPromptInput[]
    createMany?: ApprovalRequestCreateManyPromptInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProjectUpdateOneRequiredWithoutPromptsNestedInput = {
    create?: XOR<ProjectCreateWithoutPromptsInput, ProjectUncheckedCreateWithoutPromptsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPromptsInput
    upsert?: ProjectUpsertWithoutPromptsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPromptsInput, ProjectUpdateWithoutPromptsInput>, ProjectUncheckedUpdateWithoutPromptsInput>
  }

  export type PromptUpdateOneWithoutVersionsNestedInput = {
    create?: XOR<PromptCreateWithoutVersionsInput, PromptUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutVersionsInput
    upsert?: PromptUpsertWithoutVersionsInput
    disconnect?: PromptWhereInput | boolean
    delete?: PromptWhereInput | boolean
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutVersionsInput, PromptUpdateWithoutVersionsInput>, PromptUncheckedUpdateWithoutVersionsInput>
  }

  export type PromptUpdateManyWithoutParentNestedInput = {
    create?: XOR<PromptCreateWithoutParentInput, PromptUncheckedCreateWithoutParentInput> | PromptCreateWithoutParentInput[] | PromptUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutParentInput | PromptCreateOrConnectWithoutParentInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutParentInput | PromptUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PromptCreateManyParentInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutParentInput | PromptUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutParentInput | PromptUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type TestRunUpdateManyWithoutPromptNestedInput = {
    create?: XOR<TestRunCreateWithoutPromptInput, TestRunUncheckedCreateWithoutPromptInput> | TestRunCreateWithoutPromptInput[] | TestRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutPromptInput | TestRunCreateOrConnectWithoutPromptInput[]
    upsert?: TestRunUpsertWithWhereUniqueWithoutPromptInput | TestRunUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: TestRunCreateManyPromptInputEnvelope
    set?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    disconnect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    delete?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    update?: TestRunUpdateWithWhereUniqueWithoutPromptInput | TestRunUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: TestRunUpdateManyWithWhereWithoutPromptInput | TestRunUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
  }

  export type DeploymentUpdateManyWithoutPromptNestedInput = {
    create?: XOR<DeploymentCreateWithoutPromptInput, DeploymentUncheckedCreateWithoutPromptInput> | DeploymentCreateWithoutPromptInput[] | DeploymentUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutPromptInput | DeploymentCreateOrConnectWithoutPromptInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutPromptInput | DeploymentUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: DeploymentCreateManyPromptInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutPromptInput | DeploymentUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutPromptInput | DeploymentUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput = {
    create?: XOR<ImpactAnalysisCreateWithoutBaselinePromptInput, ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput> | ImpactAnalysisCreateWithoutBaselinePromptInput[] | ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput | ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput[]
    upsert?: ImpactAnalysisUpsertWithWhereUniqueWithoutBaselinePromptInput | ImpactAnalysisUpsertWithWhereUniqueWithoutBaselinePromptInput[]
    createMany?: ImpactAnalysisCreateManyBaselinePromptInputEnvelope
    set?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    disconnect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    delete?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    update?: ImpactAnalysisUpdateWithWhereUniqueWithoutBaselinePromptInput | ImpactAnalysisUpdateWithWhereUniqueWithoutBaselinePromptInput[]
    updateMany?: ImpactAnalysisUpdateManyWithWhereWithoutBaselinePromptInput | ImpactAnalysisUpdateManyWithWhereWithoutBaselinePromptInput[]
    deleteMany?: ImpactAnalysisScalarWhereInput | ImpactAnalysisScalarWhereInput[]
  }

  export type PipelineExecutionUpdateManyWithoutPromptNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutPromptInput, PipelineExecutionUncheckedCreateWithoutPromptInput> | PipelineExecutionCreateWithoutPromptInput[] | PipelineExecutionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPromptInput | PipelineExecutionCreateOrConnectWithoutPromptInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutPromptInput | PipelineExecutionUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: PipelineExecutionCreateManyPromptInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutPromptInput | PipelineExecutionUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutPromptInput | PipelineExecutionUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutBaselinePromptInput, PipelineExecutionUncheckedCreateWithoutBaselinePromptInput> | PipelineExecutionCreateWithoutBaselinePromptInput[] | PipelineExecutionUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutBaselinePromptInput | PipelineExecutionCreateOrConnectWithoutBaselinePromptInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutBaselinePromptInput | PipelineExecutionUpsertWithWhereUniqueWithoutBaselinePromptInput[]
    createMany?: PipelineExecutionCreateManyBaselinePromptInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutBaselinePromptInput | PipelineExecutionUpdateWithWhereUniqueWithoutBaselinePromptInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutBaselinePromptInput | PipelineExecutionUpdateManyWithWhereWithoutBaselinePromptInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type DeploymentPlanUpdateManyWithoutPromptNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutPromptInput, DeploymentPlanUncheckedCreateWithoutPromptInput> | DeploymentPlanCreateWithoutPromptInput[] | DeploymentPlanUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutPromptInput | DeploymentPlanCreateOrConnectWithoutPromptInput[]
    upsert?: DeploymentPlanUpsertWithWhereUniqueWithoutPromptInput | DeploymentPlanUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: DeploymentPlanCreateManyPromptInputEnvelope
    set?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    disconnect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    delete?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    update?: DeploymentPlanUpdateWithWhereUniqueWithoutPromptInput | DeploymentPlanUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: DeploymentPlanUpdateManyWithWhereWithoutPromptInput | DeploymentPlanUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
  }

  export type ApprovalRequestUpdateManyWithoutPromptNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutPromptInput, ApprovalRequestUncheckedCreateWithoutPromptInput> | ApprovalRequestCreateWithoutPromptInput[] | ApprovalRequestUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutPromptInput | ApprovalRequestCreateOrConnectWithoutPromptInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutPromptInput | ApprovalRequestUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: ApprovalRequestCreateManyPromptInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutPromptInput | ApprovalRequestUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutPromptInput | ApprovalRequestUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type PromptUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PromptCreateWithoutParentInput, PromptUncheckedCreateWithoutParentInput> | PromptCreateWithoutParentInput[] | PromptUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCreateOrConnectWithoutParentInput | PromptCreateOrConnectWithoutParentInput[]
    upsert?: PromptUpsertWithWhereUniqueWithoutParentInput | PromptUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PromptCreateManyParentInputEnvelope
    set?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    disconnect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    delete?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    connect?: PromptWhereUniqueInput | PromptWhereUniqueInput[]
    update?: PromptUpdateWithWhereUniqueWithoutParentInput | PromptUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PromptUpdateManyWithWhereWithoutParentInput | PromptUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PromptScalarWhereInput | PromptScalarWhereInput[]
  }

  export type TestRunUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<TestRunCreateWithoutPromptInput, TestRunUncheckedCreateWithoutPromptInput> | TestRunCreateWithoutPromptInput[] | TestRunUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: TestRunCreateOrConnectWithoutPromptInput | TestRunCreateOrConnectWithoutPromptInput[]
    upsert?: TestRunUpsertWithWhereUniqueWithoutPromptInput | TestRunUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: TestRunCreateManyPromptInputEnvelope
    set?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    disconnect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    delete?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    connect?: TestRunWhereUniqueInput | TestRunWhereUniqueInput[]
    update?: TestRunUpdateWithWhereUniqueWithoutPromptInput | TestRunUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: TestRunUpdateManyWithWhereWithoutPromptInput | TestRunUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
  }

  export type DeploymentUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<DeploymentCreateWithoutPromptInput, DeploymentUncheckedCreateWithoutPromptInput> | DeploymentCreateWithoutPromptInput[] | DeploymentUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutPromptInput | DeploymentCreateOrConnectWithoutPromptInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutPromptInput | DeploymentUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: DeploymentCreateManyPromptInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutPromptInput | DeploymentUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutPromptInput | DeploymentUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput = {
    create?: XOR<ImpactAnalysisCreateWithoutBaselinePromptInput, ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput> | ImpactAnalysisCreateWithoutBaselinePromptInput[] | ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput | ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput[]
    upsert?: ImpactAnalysisUpsertWithWhereUniqueWithoutBaselinePromptInput | ImpactAnalysisUpsertWithWhereUniqueWithoutBaselinePromptInput[]
    createMany?: ImpactAnalysisCreateManyBaselinePromptInputEnvelope
    set?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    disconnect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    delete?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    update?: ImpactAnalysisUpdateWithWhereUniqueWithoutBaselinePromptInput | ImpactAnalysisUpdateWithWhereUniqueWithoutBaselinePromptInput[]
    updateMany?: ImpactAnalysisUpdateManyWithWhereWithoutBaselinePromptInput | ImpactAnalysisUpdateManyWithWhereWithoutBaselinePromptInput[]
    deleteMany?: ImpactAnalysisScalarWhereInput | ImpactAnalysisScalarWhereInput[]
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutPromptInput, PipelineExecutionUncheckedCreateWithoutPromptInput> | PipelineExecutionCreateWithoutPromptInput[] | PipelineExecutionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPromptInput | PipelineExecutionCreateOrConnectWithoutPromptInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutPromptInput | PipelineExecutionUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: PipelineExecutionCreateManyPromptInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutPromptInput | PipelineExecutionUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutPromptInput | PipelineExecutionUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutBaselinePromptInput, PipelineExecutionUncheckedCreateWithoutBaselinePromptInput> | PipelineExecutionCreateWithoutBaselinePromptInput[] | PipelineExecutionUncheckedCreateWithoutBaselinePromptInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutBaselinePromptInput | PipelineExecutionCreateOrConnectWithoutBaselinePromptInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutBaselinePromptInput | PipelineExecutionUpsertWithWhereUniqueWithoutBaselinePromptInput[]
    createMany?: PipelineExecutionCreateManyBaselinePromptInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutBaselinePromptInput | PipelineExecutionUpdateWithWhereUniqueWithoutBaselinePromptInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutBaselinePromptInput | PipelineExecutionUpdateManyWithWhereWithoutBaselinePromptInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutPromptInput, DeploymentPlanUncheckedCreateWithoutPromptInput> | DeploymentPlanCreateWithoutPromptInput[] | DeploymentPlanUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutPromptInput | DeploymentPlanCreateOrConnectWithoutPromptInput[]
    upsert?: DeploymentPlanUpsertWithWhereUniqueWithoutPromptInput | DeploymentPlanUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: DeploymentPlanCreateManyPromptInputEnvelope
    set?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    disconnect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    delete?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    connect?: DeploymentPlanWhereUniqueInput | DeploymentPlanWhereUniqueInput[]
    update?: DeploymentPlanUpdateWithWhereUniqueWithoutPromptInput | DeploymentPlanUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: DeploymentPlanUpdateManyWithWhereWithoutPromptInput | DeploymentPlanUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutPromptInput, ApprovalRequestUncheckedCreateWithoutPromptInput> | ApprovalRequestCreateWithoutPromptInput[] | ApprovalRequestUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutPromptInput | ApprovalRequestCreateOrConnectWithoutPromptInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutPromptInput | ApprovalRequestUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: ApprovalRequestCreateManyPromptInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutPromptInput | ApprovalRequestUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutPromptInput | ApprovalRequestUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTestRunsInput = {
    create?: XOR<ProjectCreateWithoutTestRunsInput, ProjectUncheckedCreateWithoutTestRunsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestRunsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestRunsInput = {
    create?: XOR<UserCreateWithoutTestRunsInput, UserUncheckedCreateWithoutTestRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestRunsInput
    connect?: UserWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutTestRunsInput = {
    create?: XOR<PromptCreateWithoutTestRunsInput, PromptUncheckedCreateWithoutTestRunsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutTestRunsInput
    connect?: PromptWhereUniqueInput
  }

  export type TestResponseCreateNestedManyWithoutTestRunInput = {
    create?: XOR<TestResponseCreateWithoutTestRunInput, TestResponseUncheckedCreateWithoutTestRunInput> | TestResponseCreateWithoutTestRunInput[] | TestResponseUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestResponseCreateOrConnectWithoutTestRunInput | TestResponseCreateOrConnectWithoutTestRunInput[]
    createMany?: TestResponseCreateManyTestRunInputEnvelope
    connect?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
  }

  export type TestMetricCreateNestedManyWithoutTestRunInput = {
    create?: XOR<TestMetricCreateWithoutTestRunInput, TestMetricUncheckedCreateWithoutTestRunInput> | TestMetricCreateWithoutTestRunInput[] | TestMetricUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestMetricCreateOrConnectWithoutTestRunInput | TestMetricCreateOrConnectWithoutTestRunInput[]
    createMany?: TestMetricCreateManyTestRunInputEnvelope
    connect?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
  }

  export type TestResponseUncheckedCreateNestedManyWithoutTestRunInput = {
    create?: XOR<TestResponseCreateWithoutTestRunInput, TestResponseUncheckedCreateWithoutTestRunInput> | TestResponseCreateWithoutTestRunInput[] | TestResponseUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestResponseCreateOrConnectWithoutTestRunInput | TestResponseCreateOrConnectWithoutTestRunInput[]
    createMany?: TestResponseCreateManyTestRunInputEnvelope
    connect?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
  }

  export type TestMetricUncheckedCreateNestedManyWithoutTestRunInput = {
    create?: XOR<TestMetricCreateWithoutTestRunInput, TestMetricUncheckedCreateWithoutTestRunInput> | TestMetricCreateWithoutTestRunInput[] | TestMetricUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestMetricCreateOrConnectWithoutTestRunInput | TestMetricCreateOrConnectWithoutTestRunInput[]
    createMany?: TestMetricCreateManyTestRunInputEnvelope
    connect?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjectUpdateOneRequiredWithoutTestRunsNestedInput = {
    create?: XOR<ProjectCreateWithoutTestRunsInput, ProjectUncheckedCreateWithoutTestRunsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestRunsInput
    upsert?: ProjectUpsertWithoutTestRunsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTestRunsInput, ProjectUpdateWithoutTestRunsInput>, ProjectUncheckedUpdateWithoutTestRunsInput>
  }

  export type UserUpdateOneRequiredWithoutTestRunsNestedInput = {
    create?: XOR<UserCreateWithoutTestRunsInput, UserUncheckedCreateWithoutTestRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestRunsInput
    upsert?: UserUpsertWithoutTestRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestRunsInput, UserUpdateWithoutTestRunsInput>, UserUncheckedUpdateWithoutTestRunsInput>
  }

  export type PromptUpdateOneRequiredWithoutTestRunsNestedInput = {
    create?: XOR<PromptCreateWithoutTestRunsInput, PromptUncheckedCreateWithoutTestRunsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutTestRunsInput
    upsert?: PromptUpsertWithoutTestRunsInput
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutTestRunsInput, PromptUpdateWithoutTestRunsInput>, PromptUncheckedUpdateWithoutTestRunsInput>
  }

  export type TestResponseUpdateManyWithoutTestRunNestedInput = {
    create?: XOR<TestResponseCreateWithoutTestRunInput, TestResponseUncheckedCreateWithoutTestRunInput> | TestResponseCreateWithoutTestRunInput[] | TestResponseUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestResponseCreateOrConnectWithoutTestRunInput | TestResponseCreateOrConnectWithoutTestRunInput[]
    upsert?: TestResponseUpsertWithWhereUniqueWithoutTestRunInput | TestResponseUpsertWithWhereUniqueWithoutTestRunInput[]
    createMany?: TestResponseCreateManyTestRunInputEnvelope
    set?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    disconnect?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    delete?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    connect?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    update?: TestResponseUpdateWithWhereUniqueWithoutTestRunInput | TestResponseUpdateWithWhereUniqueWithoutTestRunInput[]
    updateMany?: TestResponseUpdateManyWithWhereWithoutTestRunInput | TestResponseUpdateManyWithWhereWithoutTestRunInput[]
    deleteMany?: TestResponseScalarWhereInput | TestResponseScalarWhereInput[]
  }

  export type TestMetricUpdateManyWithoutTestRunNestedInput = {
    create?: XOR<TestMetricCreateWithoutTestRunInput, TestMetricUncheckedCreateWithoutTestRunInput> | TestMetricCreateWithoutTestRunInput[] | TestMetricUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestMetricCreateOrConnectWithoutTestRunInput | TestMetricCreateOrConnectWithoutTestRunInput[]
    upsert?: TestMetricUpsertWithWhereUniqueWithoutTestRunInput | TestMetricUpsertWithWhereUniqueWithoutTestRunInput[]
    createMany?: TestMetricCreateManyTestRunInputEnvelope
    set?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    disconnect?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    delete?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    connect?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    update?: TestMetricUpdateWithWhereUniqueWithoutTestRunInput | TestMetricUpdateWithWhereUniqueWithoutTestRunInput[]
    updateMany?: TestMetricUpdateManyWithWhereWithoutTestRunInput | TestMetricUpdateManyWithWhereWithoutTestRunInput[]
    deleteMany?: TestMetricScalarWhereInput | TestMetricScalarWhereInput[]
  }

  export type TestResponseUncheckedUpdateManyWithoutTestRunNestedInput = {
    create?: XOR<TestResponseCreateWithoutTestRunInput, TestResponseUncheckedCreateWithoutTestRunInput> | TestResponseCreateWithoutTestRunInput[] | TestResponseUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestResponseCreateOrConnectWithoutTestRunInput | TestResponseCreateOrConnectWithoutTestRunInput[]
    upsert?: TestResponseUpsertWithWhereUniqueWithoutTestRunInput | TestResponseUpsertWithWhereUniqueWithoutTestRunInput[]
    createMany?: TestResponseCreateManyTestRunInputEnvelope
    set?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    disconnect?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    delete?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    connect?: TestResponseWhereUniqueInput | TestResponseWhereUniqueInput[]
    update?: TestResponseUpdateWithWhereUniqueWithoutTestRunInput | TestResponseUpdateWithWhereUniqueWithoutTestRunInput[]
    updateMany?: TestResponseUpdateManyWithWhereWithoutTestRunInput | TestResponseUpdateManyWithWhereWithoutTestRunInput[]
    deleteMany?: TestResponseScalarWhereInput | TestResponseScalarWhereInput[]
  }

  export type TestMetricUncheckedUpdateManyWithoutTestRunNestedInput = {
    create?: XOR<TestMetricCreateWithoutTestRunInput, TestMetricUncheckedCreateWithoutTestRunInput> | TestMetricCreateWithoutTestRunInput[] | TestMetricUncheckedCreateWithoutTestRunInput[]
    connectOrCreate?: TestMetricCreateOrConnectWithoutTestRunInput | TestMetricCreateOrConnectWithoutTestRunInput[]
    upsert?: TestMetricUpsertWithWhereUniqueWithoutTestRunInput | TestMetricUpsertWithWhereUniqueWithoutTestRunInput[]
    createMany?: TestMetricCreateManyTestRunInputEnvelope
    set?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    disconnect?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    delete?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    connect?: TestMetricWhereUniqueInput | TestMetricWhereUniqueInput[]
    update?: TestMetricUpdateWithWhereUniqueWithoutTestRunInput | TestMetricUpdateWithWhereUniqueWithoutTestRunInput[]
    updateMany?: TestMetricUpdateManyWithWhereWithoutTestRunInput | TestMetricUpdateManyWithWhereWithoutTestRunInput[]
    deleteMany?: TestMetricScalarWhereInput | TestMetricScalarWhereInput[]
  }

  export type TestRunCreateNestedOneWithoutResponsesInput = {
    create?: XOR<TestRunCreateWithoutResponsesInput, TestRunUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: TestRunCreateOrConnectWithoutResponsesInput
    connect?: TestRunWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TestRunUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<TestRunCreateWithoutResponsesInput, TestRunUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: TestRunCreateOrConnectWithoutResponsesInput
    upsert?: TestRunUpsertWithoutResponsesInput
    connect?: TestRunWhereUniqueInput
    update?: XOR<XOR<TestRunUpdateToOneWithWhereWithoutResponsesInput, TestRunUpdateWithoutResponsesInput>, TestRunUncheckedUpdateWithoutResponsesInput>
  }

  export type TestRunCreateNestedOneWithoutMetricsInput = {
    create?: XOR<TestRunCreateWithoutMetricsInput, TestRunUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: TestRunCreateOrConnectWithoutMetricsInput
    connect?: TestRunWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TestRunUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<TestRunCreateWithoutMetricsInput, TestRunUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: TestRunCreateOrConnectWithoutMetricsInput
    upsert?: TestRunUpsertWithoutMetricsInput
    connect?: TestRunWhereUniqueInput
    update?: XOR<XOR<TestRunUpdateToOneWithWhereWithoutMetricsInput, TestRunUpdateWithoutMetricsInput>, TestRunUncheckedUpdateWithoutMetricsInput>
  }

  export type ProjectCreateNestedOneWithoutSyncOperationsInput = {
    create?: XOR<ProjectCreateWithoutSyncOperationsInput, ProjectUncheckedCreateWithoutSyncOperationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSyncOperationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type AppIntegrationCreateNestedOneWithoutSyncOperationsInput = {
    create?: XOR<AppIntegrationCreateWithoutSyncOperationsInput, AppIntegrationUncheckedCreateWithoutSyncOperationsInput>
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutSyncOperationsInput
    connect?: AppIntegrationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInitiatedSyncsInput = {
    create?: XOR<UserCreateWithoutInitiatedSyncsInput, UserUncheckedCreateWithoutInitiatedSyncsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedSyncsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSyncOperationsNestedInput = {
    create?: XOR<ProjectCreateWithoutSyncOperationsInput, ProjectUncheckedCreateWithoutSyncOperationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSyncOperationsInput
    upsert?: ProjectUpsertWithoutSyncOperationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSyncOperationsInput, ProjectUpdateWithoutSyncOperationsInput>, ProjectUncheckedUpdateWithoutSyncOperationsInput>
  }

  export type AppIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInput = {
    create?: XOR<AppIntegrationCreateWithoutSyncOperationsInput, AppIntegrationUncheckedCreateWithoutSyncOperationsInput>
    connectOrCreate?: AppIntegrationCreateOrConnectWithoutSyncOperationsInput
    upsert?: AppIntegrationUpsertWithoutSyncOperationsInput
    connect?: AppIntegrationWhereUniqueInput
    update?: XOR<XOR<AppIntegrationUpdateToOneWithWhereWithoutSyncOperationsInput, AppIntegrationUpdateWithoutSyncOperationsInput>, AppIntegrationUncheckedUpdateWithoutSyncOperationsInput>
  }

  export type UserUpdateOneRequiredWithoutInitiatedSyncsNestedInput = {
    create?: XOR<UserCreateWithoutInitiatedSyncsInput, UserUncheckedCreateWithoutInitiatedSyncsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedSyncsInput
    upsert?: UserUpsertWithoutInitiatedSyncsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInitiatedSyncsInput, UserUpdateWithoutInitiatedSyncsInput>, UserUncheckedUpdateWithoutInitiatedSyncsInput>
  }

  export type ProjectCreateNestedOneWithoutWebhookSubscriptionsInput = {
    create?: XOR<ProjectCreateWithoutWebhookSubscriptionsInput, ProjectUncheckedCreateWithoutWebhookSubscriptionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebhookSubscriptionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedWebhooksInput = {
    create?: XOR<UserCreateWithoutCreatedWebhooksInput, UserUncheckedCreateWithoutCreatedWebhooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWebhooksInput
    connect?: UserWhereUniqueInput
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryCreateNestedManyWithoutFailedWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutFailedWebhookInput, WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput> | WebhookDeliveryCreateWithoutFailedWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput | WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput[]
    createMany?: WebhookDeliveryCreateManyFailedWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutFailedWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutFailedWebhookInput, WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput> | WebhookDeliveryCreateWithoutFailedWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput | WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput[]
    createMany?: WebhookDeliveryCreateManyFailedWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutWebhookSubscriptionsNestedInput = {
    create?: XOR<ProjectCreateWithoutWebhookSubscriptionsInput, ProjectUncheckedCreateWithoutWebhookSubscriptionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebhookSubscriptionsInput
    upsert?: ProjectUpsertWithoutWebhookSubscriptionsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWebhookSubscriptionsInput, ProjectUpdateWithoutWebhookSubscriptionsInput>, ProjectUncheckedUpdateWithoutWebhookSubscriptionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedWebhooksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedWebhooksInput, UserUncheckedCreateWithoutCreatedWebhooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWebhooksInput
    upsert?: UserUpsertWithoutCreatedWebhooksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedWebhooksInput, UserUpdateWithoutCreatedWebhooksInput>, UserUncheckedUpdateWithoutCreatedWebhooksInput>
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUpdateManyWithoutFailedWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutFailedWebhookInput, WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput> | WebhookDeliveryCreateWithoutFailedWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput | WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutFailedWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutFailedWebhookInput[]
    createMany?: WebhookDeliveryCreateManyFailedWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutFailedWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutFailedWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutFailedWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutFailedWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutFailedWebhookInput, WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput> | WebhookDeliveryCreateWithoutFailedWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput | WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutFailedWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutFailedWebhookInput[]
    createMany?: WebhookDeliveryCreateManyFailedWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutFailedWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutFailedWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutFailedWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutFailedWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutWebhookDeliveriesInput = {
    create?: XOR<ProjectCreateWithoutWebhookDeliveriesInput, ProjectUncheckedCreateWithoutWebhookDeliveriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebhookDeliveriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type WebhookSubscriptionCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookSubscriptionWhereUniqueInput
  }

  export type WebhookSubscriptionCreateNestedOneWithoutFailedDeliveriesInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutFailedDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutFailedDeliveriesInput>
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutFailedDeliveriesInput
    connect?: WebhookSubscriptionWhereUniqueInput
  }

  export type ProjectUpdateOneWithoutWebhookDeliveriesNestedInput = {
    create?: XOR<ProjectCreateWithoutWebhookDeliveriesInput, ProjectUncheckedCreateWithoutWebhookDeliveriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebhookDeliveriesInput
    upsert?: ProjectUpsertWithoutWebhookDeliveriesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWebhookDeliveriesInput, ProjectUpdateWithoutWebhookDeliveriesInput>, ProjectUncheckedUpdateWithoutWebhookDeliveriesInput>
  }

  export type WebhookSubscriptionUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookSubscriptionUpsertWithoutDeliveriesInput
    disconnect?: WebhookSubscriptionWhereInput | boolean
    delete?: WebhookSubscriptionWhereInput | boolean
    connect?: WebhookSubscriptionWhereUniqueInput
    update?: XOR<XOR<WebhookSubscriptionUpdateToOneWithWhereWithoutDeliveriesInput, WebhookSubscriptionUpdateWithoutDeliveriesInput>, WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookSubscriptionUpdateOneWithoutFailedDeliveriesNestedInput = {
    create?: XOR<WebhookSubscriptionCreateWithoutFailedDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutFailedDeliveriesInput>
    connectOrCreate?: WebhookSubscriptionCreateOrConnectWithoutFailedDeliveriesInput
    upsert?: WebhookSubscriptionUpsertWithoutFailedDeliveriesInput
    disconnect?: WebhookSubscriptionWhereInput | boolean
    delete?: WebhookSubscriptionWhereInput | boolean
    connect?: WebhookSubscriptionWhereUniqueInput
    update?: XOR<XOR<WebhookSubscriptionUpdateToOneWithWhereWithoutFailedDeliveriesInput, WebhookSubscriptionUpdateWithoutFailedDeliveriesInput>, WebhookSubscriptionUncheckedUpdateWithoutFailedDeliveriesInput>
  }

  export type ProjectCreateNestedOneWithoutApiKeyInput = {
    create?: XOR<ProjectCreateWithoutApiKeyInput, ProjectUncheckedCreateWithoutApiKeyInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiKeyInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutApiKeyNestedInput = {
    create?: XOR<ProjectCreateWithoutApiKeyInput, ProjectUncheckedCreateWithoutApiKeyInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiKeyInput
    upsert?: ProjectUpsertWithoutApiKeyInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiKeyInput, ProjectUpdateWithoutApiKeyInput>, ProjectUncheckedUpdateWithoutApiKeyInput>
  }

  export type ProjectCreateNestedOneWithoutEnvironmentsInput = {
    create?: XOR<ProjectCreateWithoutEnvironmentsInput, ProjectUncheckedCreateWithoutEnvironmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEnvironmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DeploymentCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput> | DeploymentCreateWithoutEnvironmentInput[] | DeploymentUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutEnvironmentInput | DeploymentCreateOrConnectWithoutEnvironmentInput[]
    createMany?: DeploymentCreateManyEnvironmentInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type DeploymentUncheckedCreateNestedManyWithoutEnvironmentInput = {
    create?: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput> | DeploymentCreateWithoutEnvironmentInput[] | DeploymentUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutEnvironmentInput | DeploymentCreateOrConnectWithoutEnvironmentInput[]
    createMany?: DeploymentCreateManyEnvironmentInputEnvelope
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutEnvironmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutEnvironmentsInput, ProjectUncheckedCreateWithoutEnvironmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutEnvironmentsInput
    upsert?: ProjectUpsertWithoutEnvironmentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutEnvironmentsInput, ProjectUpdateWithoutEnvironmentsInput>, ProjectUncheckedUpdateWithoutEnvironmentsInput>
  }

  export type DeploymentUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput> | DeploymentCreateWithoutEnvironmentInput[] | DeploymentUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutEnvironmentInput | DeploymentCreateOrConnectWithoutEnvironmentInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput | DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: DeploymentCreateManyEnvironmentInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput | DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutEnvironmentInput | DeploymentUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type DeploymentUncheckedUpdateManyWithoutEnvironmentNestedInput = {
    create?: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput> | DeploymentCreateWithoutEnvironmentInput[] | DeploymentUncheckedCreateWithoutEnvironmentInput[]
    connectOrCreate?: DeploymentCreateOrConnectWithoutEnvironmentInput | DeploymentCreateOrConnectWithoutEnvironmentInput[]
    upsert?: DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput | DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput[]
    createMany?: DeploymentCreateManyEnvironmentInputEnvelope
    set?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    disconnect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    delete?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    connect?: DeploymentWhereUniqueInput | DeploymentWhereUniqueInput[]
    update?: DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput | DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput[]
    updateMany?: DeploymentUpdateManyWithWhereWithoutEnvironmentInput | DeploymentUpdateManyWithWhereWithoutEnvironmentInput[]
    deleteMany?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
  }

  export type PromptCreateNestedOneWithoutDeploymentsInput = {
    create?: XOR<PromptCreateWithoutDeploymentsInput, PromptUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutDeploymentsInput
    connect?: PromptWhereUniqueInput
  }

  export type EnvironmentCreateNestedOneWithoutDeploymentsInput = {
    create?: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutDeploymentsInput
    connect?: EnvironmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeploymentsInput = {
    create?: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeploymentsInput
    connect?: UserWhereUniqueInput
  }

  export type DeploymentHistoryCreateNestedManyWithoutDeploymentInput = {
    create?: XOR<DeploymentHistoryCreateWithoutDeploymentInput, DeploymentHistoryUncheckedCreateWithoutDeploymentInput> | DeploymentHistoryCreateWithoutDeploymentInput[] | DeploymentHistoryUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutDeploymentInput | DeploymentHistoryCreateOrConnectWithoutDeploymentInput[]
    createMany?: DeploymentHistoryCreateManyDeploymentInputEnvelope
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
  }

  export type ImpactAnalysisCreateNestedManyWithoutDeploymentInput = {
    create?: XOR<ImpactAnalysisCreateWithoutDeploymentInput, ImpactAnalysisUncheckedCreateWithoutDeploymentInput> | ImpactAnalysisCreateWithoutDeploymentInput[] | ImpactAnalysisUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutDeploymentInput | ImpactAnalysisCreateOrConnectWithoutDeploymentInput[]
    createMany?: ImpactAnalysisCreateManyDeploymentInputEnvelope
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
  }

  export type DeploymentHistoryUncheckedCreateNestedManyWithoutDeploymentInput = {
    create?: XOR<DeploymentHistoryCreateWithoutDeploymentInput, DeploymentHistoryUncheckedCreateWithoutDeploymentInput> | DeploymentHistoryCreateWithoutDeploymentInput[] | DeploymentHistoryUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutDeploymentInput | DeploymentHistoryCreateOrConnectWithoutDeploymentInput[]
    createMany?: DeploymentHistoryCreateManyDeploymentInputEnvelope
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
  }

  export type ImpactAnalysisUncheckedCreateNestedManyWithoutDeploymentInput = {
    create?: XOR<ImpactAnalysisCreateWithoutDeploymentInput, ImpactAnalysisUncheckedCreateWithoutDeploymentInput> | ImpactAnalysisCreateWithoutDeploymentInput[] | ImpactAnalysisUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutDeploymentInput | ImpactAnalysisCreateOrConnectWithoutDeploymentInput[]
    createMany?: ImpactAnalysisCreateManyDeploymentInputEnvelope
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
  }

  export type PromptUpdateOneRequiredWithoutDeploymentsNestedInput = {
    create?: XOR<PromptCreateWithoutDeploymentsInput, PromptUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutDeploymentsInput
    upsert?: PromptUpsertWithoutDeploymentsInput
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutDeploymentsInput, PromptUpdateWithoutDeploymentsInput>, PromptUncheckedUpdateWithoutDeploymentsInput>
  }

  export type EnvironmentUpdateOneRequiredWithoutDeploymentsNestedInput = {
    create?: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: EnvironmentCreateOrConnectWithoutDeploymentsInput
    upsert?: EnvironmentUpsertWithoutDeploymentsInput
    connect?: EnvironmentWhereUniqueInput
    update?: XOR<XOR<EnvironmentUpdateToOneWithWhereWithoutDeploymentsInput, EnvironmentUpdateWithoutDeploymentsInput>, EnvironmentUncheckedUpdateWithoutDeploymentsInput>
  }

  export type UserUpdateOneRequiredWithoutDeploymentsNestedInput = {
    create?: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeploymentsInput
    upsert?: UserUpsertWithoutDeploymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeploymentsInput, UserUpdateWithoutDeploymentsInput>, UserUncheckedUpdateWithoutDeploymentsInput>
  }

  export type DeploymentHistoryUpdateManyWithoutDeploymentNestedInput = {
    create?: XOR<DeploymentHistoryCreateWithoutDeploymentInput, DeploymentHistoryUncheckedCreateWithoutDeploymentInput> | DeploymentHistoryCreateWithoutDeploymentInput[] | DeploymentHistoryUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutDeploymentInput | DeploymentHistoryCreateOrConnectWithoutDeploymentInput[]
    upsert?: DeploymentHistoryUpsertWithWhereUniqueWithoutDeploymentInput | DeploymentHistoryUpsertWithWhereUniqueWithoutDeploymentInput[]
    createMany?: DeploymentHistoryCreateManyDeploymentInputEnvelope
    set?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    disconnect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    delete?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    update?: DeploymentHistoryUpdateWithWhereUniqueWithoutDeploymentInput | DeploymentHistoryUpdateWithWhereUniqueWithoutDeploymentInput[]
    updateMany?: DeploymentHistoryUpdateManyWithWhereWithoutDeploymentInput | DeploymentHistoryUpdateManyWithWhereWithoutDeploymentInput[]
    deleteMany?: DeploymentHistoryScalarWhereInput | DeploymentHistoryScalarWhereInput[]
  }

  export type ImpactAnalysisUpdateManyWithoutDeploymentNestedInput = {
    create?: XOR<ImpactAnalysisCreateWithoutDeploymentInput, ImpactAnalysisUncheckedCreateWithoutDeploymentInput> | ImpactAnalysisCreateWithoutDeploymentInput[] | ImpactAnalysisUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutDeploymentInput | ImpactAnalysisCreateOrConnectWithoutDeploymentInput[]
    upsert?: ImpactAnalysisUpsertWithWhereUniqueWithoutDeploymentInput | ImpactAnalysisUpsertWithWhereUniqueWithoutDeploymentInput[]
    createMany?: ImpactAnalysisCreateManyDeploymentInputEnvelope
    set?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    disconnect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    delete?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    update?: ImpactAnalysisUpdateWithWhereUniqueWithoutDeploymentInput | ImpactAnalysisUpdateWithWhereUniqueWithoutDeploymentInput[]
    updateMany?: ImpactAnalysisUpdateManyWithWhereWithoutDeploymentInput | ImpactAnalysisUpdateManyWithWhereWithoutDeploymentInput[]
    deleteMany?: ImpactAnalysisScalarWhereInput | ImpactAnalysisScalarWhereInput[]
  }

  export type DeploymentHistoryUncheckedUpdateManyWithoutDeploymentNestedInput = {
    create?: XOR<DeploymentHistoryCreateWithoutDeploymentInput, DeploymentHistoryUncheckedCreateWithoutDeploymentInput> | DeploymentHistoryCreateWithoutDeploymentInput[] | DeploymentHistoryUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: DeploymentHistoryCreateOrConnectWithoutDeploymentInput | DeploymentHistoryCreateOrConnectWithoutDeploymentInput[]
    upsert?: DeploymentHistoryUpsertWithWhereUniqueWithoutDeploymentInput | DeploymentHistoryUpsertWithWhereUniqueWithoutDeploymentInput[]
    createMany?: DeploymentHistoryCreateManyDeploymentInputEnvelope
    set?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    disconnect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    delete?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    connect?: DeploymentHistoryWhereUniqueInput | DeploymentHistoryWhereUniqueInput[]
    update?: DeploymentHistoryUpdateWithWhereUniqueWithoutDeploymentInput | DeploymentHistoryUpdateWithWhereUniqueWithoutDeploymentInput[]
    updateMany?: DeploymentHistoryUpdateManyWithWhereWithoutDeploymentInput | DeploymentHistoryUpdateManyWithWhereWithoutDeploymentInput[]
    deleteMany?: DeploymentHistoryScalarWhereInput | DeploymentHistoryScalarWhereInput[]
  }

  export type ImpactAnalysisUncheckedUpdateManyWithoutDeploymentNestedInput = {
    create?: XOR<ImpactAnalysisCreateWithoutDeploymentInput, ImpactAnalysisUncheckedCreateWithoutDeploymentInput> | ImpactAnalysisCreateWithoutDeploymentInput[] | ImpactAnalysisUncheckedCreateWithoutDeploymentInput[]
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutDeploymentInput | ImpactAnalysisCreateOrConnectWithoutDeploymentInput[]
    upsert?: ImpactAnalysisUpsertWithWhereUniqueWithoutDeploymentInput | ImpactAnalysisUpsertWithWhereUniqueWithoutDeploymentInput[]
    createMany?: ImpactAnalysisCreateManyDeploymentInputEnvelope
    set?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    disconnect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    delete?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    connect?: ImpactAnalysisWhereUniqueInput | ImpactAnalysisWhereUniqueInput[]
    update?: ImpactAnalysisUpdateWithWhereUniqueWithoutDeploymentInput | ImpactAnalysisUpdateWithWhereUniqueWithoutDeploymentInput[]
    updateMany?: ImpactAnalysisUpdateManyWithWhereWithoutDeploymentInput | ImpactAnalysisUpdateManyWithWhereWithoutDeploymentInput[]
    deleteMany?: ImpactAnalysisScalarWhereInput | ImpactAnalysisScalarWhereInput[]
  }

  export type DeploymentCreateNestedOneWithoutHistoryInput = {
    create?: XOR<DeploymentCreateWithoutHistoryInput, DeploymentUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: DeploymentCreateOrConnectWithoutHistoryInput
    connect?: DeploymentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeploymentActionsInput = {
    create?: XOR<UserCreateWithoutDeploymentActionsInput, UserUncheckedCreateWithoutDeploymentActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeploymentActionsInput
    connect?: UserWhereUniqueInput
  }

  export type DeploymentUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<DeploymentCreateWithoutHistoryInput, DeploymentUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: DeploymentCreateOrConnectWithoutHistoryInput
    upsert?: DeploymentUpsertWithoutHistoryInput
    connect?: DeploymentWhereUniqueInput
    update?: XOR<XOR<DeploymentUpdateToOneWithWhereWithoutHistoryInput, DeploymentUpdateWithoutHistoryInput>, DeploymentUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutDeploymentActionsNestedInput = {
    create?: XOR<UserCreateWithoutDeploymentActionsInput, UserUncheckedCreateWithoutDeploymentActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeploymentActionsInput
    upsert?: UserUpsertWithoutDeploymentActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeploymentActionsInput, UserUpdateWithoutDeploymentActionsInput>, UserUncheckedUpdateWithoutDeploymentActionsInput>
  }

  export type DeploymentCreateNestedOneWithoutImpactAnalysisInput = {
    create?: XOR<DeploymentCreateWithoutImpactAnalysisInput, DeploymentUncheckedCreateWithoutImpactAnalysisInput>
    connectOrCreate?: DeploymentCreateOrConnectWithoutImpactAnalysisInput
    connect?: DeploymentWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutImpactAnalysisInput = {
    create?: XOR<PromptCreateWithoutImpactAnalysisInput, PromptUncheckedCreateWithoutImpactAnalysisInput>
    connectOrCreate?: PromptCreateOrConnectWithoutImpactAnalysisInput
    connect?: PromptWhereUniqueInput
  }

  export type ApprovalRequestCreateNestedManyWithoutImpactAnalysisInput = {
    create?: XOR<ApprovalRequestCreateWithoutImpactAnalysisInput, ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput> | ApprovalRequestCreateWithoutImpactAnalysisInput[] | ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput | ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput[]
    createMany?: ApprovalRequestCreateManyImpactAnalysisInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutImpactAnalysisInput = {
    create?: XOR<ApprovalRequestCreateWithoutImpactAnalysisInput, ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput> | ApprovalRequestCreateWithoutImpactAnalysisInput[] | ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput | ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput[]
    createMany?: ApprovalRequestCreateManyImpactAnalysisInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type DeploymentUpdateOneRequiredWithoutImpactAnalysisNestedInput = {
    create?: XOR<DeploymentCreateWithoutImpactAnalysisInput, DeploymentUncheckedCreateWithoutImpactAnalysisInput>
    connectOrCreate?: DeploymentCreateOrConnectWithoutImpactAnalysisInput
    upsert?: DeploymentUpsertWithoutImpactAnalysisInput
    connect?: DeploymentWhereUniqueInput
    update?: XOR<XOR<DeploymentUpdateToOneWithWhereWithoutImpactAnalysisInput, DeploymentUpdateWithoutImpactAnalysisInput>, DeploymentUncheckedUpdateWithoutImpactAnalysisInput>
  }

  export type PromptUpdateOneWithoutImpactAnalysisNestedInput = {
    create?: XOR<PromptCreateWithoutImpactAnalysisInput, PromptUncheckedCreateWithoutImpactAnalysisInput>
    connectOrCreate?: PromptCreateOrConnectWithoutImpactAnalysisInput
    upsert?: PromptUpsertWithoutImpactAnalysisInput
    disconnect?: PromptWhereInput | boolean
    delete?: PromptWhereInput | boolean
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutImpactAnalysisInput, PromptUpdateWithoutImpactAnalysisInput>, PromptUncheckedUpdateWithoutImpactAnalysisInput>
  }

  export type ApprovalRequestUpdateManyWithoutImpactAnalysisNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutImpactAnalysisInput, ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput> | ApprovalRequestCreateWithoutImpactAnalysisInput[] | ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput | ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutImpactAnalysisInput | ApprovalRequestUpsertWithWhereUniqueWithoutImpactAnalysisInput[]
    createMany?: ApprovalRequestCreateManyImpactAnalysisInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutImpactAnalysisInput | ApprovalRequestUpdateWithWhereUniqueWithoutImpactAnalysisInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutImpactAnalysisInput | ApprovalRequestUpdateManyWithWhereWithoutImpactAnalysisInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutImpactAnalysisNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutImpactAnalysisInput, ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput> | ApprovalRequestCreateWithoutImpactAnalysisInput[] | ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput | ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutImpactAnalysisInput | ApprovalRequestUpsertWithWhereUniqueWithoutImpactAnalysisInput[]
    createMany?: ApprovalRequestCreateManyImpactAnalysisInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutImpactAnalysisInput | ApprovalRequestUpdateWithWhereUniqueWithoutImpactAnalysisInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutImpactAnalysisInput | ApprovalRequestUpdateManyWithWhereWithoutImpactAnalysisInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutCostTrackingInput = {
    create?: XOR<ProjectCreateWithoutCostTrackingInput, ProjectUncheckedCreateWithoutCostTrackingInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostTrackingInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCostTrackingInput = {
    create?: XOR<UserCreateWithoutCostTrackingInput, UserUncheckedCreateWithoutCostTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutCostTrackingInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutCostTrackingNestedInput = {
    create?: XOR<ProjectCreateWithoutCostTrackingInput, ProjectUncheckedCreateWithoutCostTrackingInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCostTrackingInput
    upsert?: ProjectUpsertWithoutCostTrackingInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCostTrackingInput, ProjectUpdateWithoutCostTrackingInput>, ProjectUncheckedUpdateWithoutCostTrackingInput>
  }

  export type UserUpdateOneWithoutCostTrackingNestedInput = {
    create?: XOR<UserCreateWithoutCostTrackingInput, UserUncheckedCreateWithoutCostTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutCostTrackingInput
    upsert?: UserUpsertWithoutCostTrackingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCostTrackingInput, UserUpdateWithoutCostTrackingInput>, UserUncheckedUpdateWithoutCostTrackingInput>
  }

  export type UserCreateNestedOneWithoutBillingInput = {
    create?: XOR<UserCreateWithoutBillingInput, UserUncheckedCreateWithoutBillingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBillingNestedInput = {
    create?: XOR<UserCreateWithoutBillingInput, UserUncheckedCreateWithoutBillingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBillingInput
    upsert?: UserUpsertWithoutBillingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBillingInput, UserUpdateWithoutBillingInput>, UserUncheckedUpdateWithoutBillingInput>
  }

  export type ProjectCreateNestedOneWithoutAppIntegrationsInput = {
    create?: XOR<ProjectCreateWithoutAppIntegrationsInput, ProjectUncheckedCreateWithoutAppIntegrationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAppIntegrationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedIntegrationsInput = {
    create?: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type SyncOperationCreateNestedManyWithoutConnectionInput = {
    create?: XOR<SyncOperationCreateWithoutConnectionInput, SyncOperationUncheckedCreateWithoutConnectionInput> | SyncOperationCreateWithoutConnectionInput[] | SyncOperationUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutConnectionInput | SyncOperationCreateOrConnectWithoutConnectionInput[]
    createMany?: SyncOperationCreateManyConnectionInputEnvelope
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
  }

  export type SyncOperationUncheckedCreateNestedManyWithoutConnectionInput = {
    create?: XOR<SyncOperationCreateWithoutConnectionInput, SyncOperationUncheckedCreateWithoutConnectionInput> | SyncOperationCreateWithoutConnectionInput[] | SyncOperationUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutConnectionInput | SyncOperationCreateOrConnectWithoutConnectionInput[]
    createMany?: SyncOperationCreateManyConnectionInputEnvelope
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutAppIntegrationsNestedInput = {
    create?: XOR<ProjectCreateWithoutAppIntegrationsInput, ProjectUncheckedCreateWithoutAppIntegrationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAppIntegrationsInput
    upsert?: ProjectUpsertWithoutAppIntegrationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAppIntegrationsInput, ProjectUpdateWithoutAppIntegrationsInput>, ProjectUncheckedUpdateWithoutAppIntegrationsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIntegrationsInput
    upsert?: UserUpsertWithoutCreatedIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedIntegrationsInput, UserUpdateWithoutCreatedIntegrationsInput>, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
  }

  export type SyncOperationUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<SyncOperationCreateWithoutConnectionInput, SyncOperationUncheckedCreateWithoutConnectionInput> | SyncOperationCreateWithoutConnectionInput[] | SyncOperationUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutConnectionInput | SyncOperationCreateOrConnectWithoutConnectionInput[]
    upsert?: SyncOperationUpsertWithWhereUniqueWithoutConnectionInput | SyncOperationUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: SyncOperationCreateManyConnectionInputEnvelope
    set?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    disconnect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    delete?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    update?: SyncOperationUpdateWithWhereUniqueWithoutConnectionInput | SyncOperationUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: SyncOperationUpdateManyWithWhereWithoutConnectionInput | SyncOperationUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
  }

  export type SyncOperationUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<SyncOperationCreateWithoutConnectionInput, SyncOperationUncheckedCreateWithoutConnectionInput> | SyncOperationCreateWithoutConnectionInput[] | SyncOperationUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: SyncOperationCreateOrConnectWithoutConnectionInput | SyncOperationCreateOrConnectWithoutConnectionInput[]
    upsert?: SyncOperationUpsertWithWhereUniqueWithoutConnectionInput | SyncOperationUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: SyncOperationCreateManyConnectionInputEnvelope
    set?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    disconnect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    delete?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    connect?: SyncOperationWhereUniqueInput | SyncOperationWhereUniqueInput[]
    update?: SyncOperationUpdateWithWhereUniqueWithoutConnectionInput | SyncOperationUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: SyncOperationUpdateManyWithWhereWithoutConnectionInput | SyncOperationUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTestPipelinesInput = {
    create?: XOR<ProjectCreateWithoutTestPipelinesInput, ProjectUncheckedCreateWithoutTestPipelinesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestPipelinesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPipelinesInput = {
    create?: XOR<UserCreateWithoutCreatedPipelinesInput, UserUncheckedCreateWithoutCreatedPipelinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPipelinesInput
    connect?: UserWhereUniqueInput
  }

  export type PipelineStageCreateNestedManyWithoutPipelineInput = {
    create?: XOR<PipelineStageCreateWithoutPipelineInput, PipelineStageUncheckedCreateWithoutPipelineInput> | PipelineStageCreateWithoutPipelineInput[] | PipelineStageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineStageCreateOrConnectWithoutPipelineInput | PipelineStageCreateOrConnectWithoutPipelineInput[]
    createMany?: PipelineStageCreateManyPipelineInputEnvelope
    connect?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
  }

  export type PipelineExecutionCreateNestedManyWithoutPipelineInput = {
    create?: XOR<PipelineExecutionCreateWithoutPipelineInput, PipelineExecutionUncheckedCreateWithoutPipelineInput> | PipelineExecutionCreateWithoutPipelineInput[] | PipelineExecutionUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPipelineInput | PipelineExecutionCreateOrConnectWithoutPipelineInput[]
    createMany?: PipelineExecutionCreateManyPipelineInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type PipelineStageUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<PipelineStageCreateWithoutPipelineInput, PipelineStageUncheckedCreateWithoutPipelineInput> | PipelineStageCreateWithoutPipelineInput[] | PipelineStageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineStageCreateOrConnectWithoutPipelineInput | PipelineStageCreateOrConnectWithoutPipelineInput[]
    createMany?: PipelineStageCreateManyPipelineInputEnvelope
    connect?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
  }

  export type PipelineExecutionUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<PipelineExecutionCreateWithoutPipelineInput, PipelineExecutionUncheckedCreateWithoutPipelineInput> | PipelineExecutionCreateWithoutPipelineInput[] | PipelineExecutionUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPipelineInput | PipelineExecutionCreateOrConnectWithoutPipelineInput[]
    createMany?: PipelineExecutionCreateManyPipelineInputEnvelope
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTestPipelinesNestedInput = {
    create?: XOR<ProjectCreateWithoutTestPipelinesInput, ProjectUncheckedCreateWithoutTestPipelinesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTestPipelinesInput
    upsert?: ProjectUpsertWithoutTestPipelinesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTestPipelinesInput, ProjectUpdateWithoutTestPipelinesInput>, ProjectUncheckedUpdateWithoutTestPipelinesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedPipelinesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPipelinesInput, UserUncheckedCreateWithoutCreatedPipelinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPipelinesInput
    upsert?: UserUpsertWithoutCreatedPipelinesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPipelinesInput, UserUpdateWithoutCreatedPipelinesInput>, UserUncheckedUpdateWithoutCreatedPipelinesInput>
  }

  export type PipelineStageUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<PipelineStageCreateWithoutPipelineInput, PipelineStageUncheckedCreateWithoutPipelineInput> | PipelineStageCreateWithoutPipelineInput[] | PipelineStageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineStageCreateOrConnectWithoutPipelineInput | PipelineStageCreateOrConnectWithoutPipelineInput[]
    upsert?: PipelineStageUpsertWithWhereUniqueWithoutPipelineInput | PipelineStageUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: PipelineStageCreateManyPipelineInputEnvelope
    set?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    disconnect?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    delete?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    connect?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    update?: PipelineStageUpdateWithWhereUniqueWithoutPipelineInput | PipelineStageUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: PipelineStageUpdateManyWithWhereWithoutPipelineInput | PipelineStageUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: PipelineStageScalarWhereInput | PipelineStageScalarWhereInput[]
  }

  export type PipelineExecutionUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutPipelineInput, PipelineExecutionUncheckedCreateWithoutPipelineInput> | PipelineExecutionCreateWithoutPipelineInput[] | PipelineExecutionUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPipelineInput | PipelineExecutionCreateOrConnectWithoutPipelineInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutPipelineInput | PipelineExecutionUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: PipelineExecutionCreateManyPipelineInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutPipelineInput | PipelineExecutionUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutPipelineInput | PipelineExecutionUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type PipelineStageUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<PipelineStageCreateWithoutPipelineInput, PipelineStageUncheckedCreateWithoutPipelineInput> | PipelineStageCreateWithoutPipelineInput[] | PipelineStageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineStageCreateOrConnectWithoutPipelineInput | PipelineStageCreateOrConnectWithoutPipelineInput[]
    upsert?: PipelineStageUpsertWithWhereUniqueWithoutPipelineInput | PipelineStageUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: PipelineStageCreateManyPipelineInputEnvelope
    set?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    disconnect?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    delete?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    connect?: PipelineStageWhereUniqueInput | PipelineStageWhereUniqueInput[]
    update?: PipelineStageUpdateWithWhereUniqueWithoutPipelineInput | PipelineStageUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: PipelineStageUpdateManyWithWhereWithoutPipelineInput | PipelineStageUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: PipelineStageScalarWhereInput | PipelineStageScalarWhereInput[]
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<PipelineExecutionCreateWithoutPipelineInput, PipelineExecutionUncheckedCreateWithoutPipelineInput> | PipelineExecutionCreateWithoutPipelineInput[] | PipelineExecutionUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: PipelineExecutionCreateOrConnectWithoutPipelineInput | PipelineExecutionCreateOrConnectWithoutPipelineInput[]
    upsert?: PipelineExecutionUpsertWithWhereUniqueWithoutPipelineInput | PipelineExecutionUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: PipelineExecutionCreateManyPipelineInputEnvelope
    set?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    disconnect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    delete?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    connect?: PipelineExecutionWhereUniqueInput | PipelineExecutionWhereUniqueInput[]
    update?: PipelineExecutionUpdateWithWhereUniqueWithoutPipelineInput | PipelineExecutionUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: PipelineExecutionUpdateManyWithWhereWithoutPipelineInput | PipelineExecutionUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
  }

  export type TestPipelineCreateNestedOneWithoutStagesInput = {
    create?: XOR<TestPipelineCreateWithoutStagesInput, TestPipelineUncheckedCreateWithoutStagesInput>
    connectOrCreate?: TestPipelineCreateOrConnectWithoutStagesInput
    connect?: TestPipelineWhereUniqueInput
  }

  export type TestPipelineUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<TestPipelineCreateWithoutStagesInput, TestPipelineUncheckedCreateWithoutStagesInput>
    connectOrCreate?: TestPipelineCreateOrConnectWithoutStagesInput
    upsert?: TestPipelineUpsertWithoutStagesInput
    connect?: TestPipelineWhereUniqueInput
    update?: XOR<XOR<TestPipelineUpdateToOneWithWhereWithoutStagesInput, TestPipelineUpdateWithoutStagesInput>, TestPipelineUncheckedUpdateWithoutStagesInput>
  }

  export type TestPipelineCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<TestPipelineCreateWithoutExecutionsInput, TestPipelineUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TestPipelineCreateOrConnectWithoutExecutionsInput
    connect?: TestPipelineWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutPipelineExecutionsInput = {
    create?: XOR<PromptCreateWithoutPipelineExecutionsInput, PromptUncheckedCreateWithoutPipelineExecutionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutPipelineExecutionsInput
    connect?: PromptWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutBaselinePipelineExecutionsInput = {
    create?: XOR<PromptCreateWithoutBaselinePipelineExecutionsInput, PromptUncheckedCreateWithoutBaselinePipelineExecutionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutBaselinePipelineExecutionsInput
    connect?: PromptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExecutedPipelinesInput = {
    create?: XOR<UserCreateWithoutExecutedPipelinesInput, UserUncheckedCreateWithoutExecutedPipelinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutedPipelinesInput
    connect?: UserWhereUniqueInput
  }

  export type TestPipelineUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<TestPipelineCreateWithoutExecutionsInput, TestPipelineUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: TestPipelineCreateOrConnectWithoutExecutionsInput
    upsert?: TestPipelineUpsertWithoutExecutionsInput
    connect?: TestPipelineWhereUniqueInput
    update?: XOR<XOR<TestPipelineUpdateToOneWithWhereWithoutExecutionsInput, TestPipelineUpdateWithoutExecutionsInput>, TestPipelineUncheckedUpdateWithoutExecutionsInput>
  }

  export type PromptUpdateOneRequiredWithoutPipelineExecutionsNestedInput = {
    create?: XOR<PromptCreateWithoutPipelineExecutionsInput, PromptUncheckedCreateWithoutPipelineExecutionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutPipelineExecutionsInput
    upsert?: PromptUpsertWithoutPipelineExecutionsInput
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutPipelineExecutionsInput, PromptUpdateWithoutPipelineExecutionsInput>, PromptUncheckedUpdateWithoutPipelineExecutionsInput>
  }

  export type PromptUpdateOneWithoutBaselinePipelineExecutionsNestedInput = {
    create?: XOR<PromptCreateWithoutBaselinePipelineExecutionsInput, PromptUncheckedCreateWithoutBaselinePipelineExecutionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutBaselinePipelineExecutionsInput
    upsert?: PromptUpsertWithoutBaselinePipelineExecutionsInput
    disconnect?: PromptWhereInput | boolean
    delete?: PromptWhereInput | boolean
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutBaselinePipelineExecutionsInput, PromptUpdateWithoutBaselinePipelineExecutionsInput>, PromptUncheckedUpdateWithoutBaselinePipelineExecutionsInput>
  }

  export type UserUpdateOneRequiredWithoutExecutedPipelinesNestedInput = {
    create?: XOR<UserCreateWithoutExecutedPipelinesInput, UserUncheckedCreateWithoutExecutedPipelinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutedPipelinesInput
    upsert?: UserUpsertWithoutExecutedPipelinesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExecutedPipelinesInput, UserUpdateWithoutExecutedPipelinesInput>, UserUncheckedUpdateWithoutExecutedPipelinesInput>
  }

  export type ProjectCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<ProjectCreateWithoutDependenciesInput, ProjectUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDependenciesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedDependenciesInput = {
    create?: XOR<UserCreateWithoutCreatedDependenciesInput, UserUncheckedCreateWithoutCreatedDependenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDependenciesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<ProjectCreateWithoutDependenciesInput, ProjectUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDependenciesInput
    upsert?: ProjectUpsertWithoutDependenciesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDependenciesInput, ProjectUpdateWithoutDependenciesInput>, ProjectUncheckedUpdateWithoutDependenciesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedDependenciesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedDependenciesInput, UserUncheckedCreateWithoutCreatedDependenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDependenciesInput
    upsert?: UserUpsertWithoutCreatedDependenciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedDependenciesInput, UserUpdateWithoutCreatedDependenciesInput>, UserUncheckedUpdateWithoutCreatedDependenciesInput>
  }

  export type ProjectCreateNestedOneWithoutUpdatePlansInput = {
    create?: XOR<ProjectCreateWithoutUpdatePlansInput, ProjectUncheckedCreateWithoutUpdatePlansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatePlansInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedUpdatePlansInput = {
    create?: XOR<UserCreateWithoutCreatedUpdatePlansInput, UserUncheckedCreateWithoutCreatedUpdatePlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUpdatePlansInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExecutedUpdatePlansInput = {
    create?: XOR<UserCreateWithoutExecutedUpdatePlansInput, UserUncheckedCreateWithoutExecutedUpdatePlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutedUpdatePlansInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutUpdatePlansNestedInput = {
    create?: XOR<ProjectCreateWithoutUpdatePlansInput, ProjectUncheckedCreateWithoutUpdatePlansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatePlansInput
    upsert?: ProjectUpsertWithoutUpdatePlansInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUpdatePlansInput, ProjectUpdateWithoutUpdatePlansInput>, ProjectUncheckedUpdateWithoutUpdatePlansInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedUpdatePlansNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUpdatePlansInput, UserUncheckedCreateWithoutCreatedUpdatePlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUpdatePlansInput
    upsert?: UserUpsertWithoutCreatedUpdatePlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUpdatePlansInput, UserUpdateWithoutCreatedUpdatePlansInput>, UserUncheckedUpdateWithoutCreatedUpdatePlansInput>
  }

  export type UserUpdateOneWithoutExecutedUpdatePlansNestedInput = {
    create?: XOR<UserCreateWithoutExecutedUpdatePlansInput, UserUncheckedCreateWithoutExecutedUpdatePlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutedUpdatePlansInput
    upsert?: UserUpsertWithoutExecutedUpdatePlansInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExecutedUpdatePlansInput, UserUpdateWithoutExecutedUpdatePlansInput>, UserUncheckedUpdateWithoutExecutedUpdatePlansInput>
  }

  export type ProjectCreateNestedOneWithoutDeploymentPlansInput = {
    create?: XOR<ProjectCreateWithoutDeploymentPlansInput, ProjectUncheckedCreateWithoutDeploymentPlansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDeploymentPlansInput
    connect?: ProjectWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutDeploymentPlansInput = {
    create?: XOR<PromptCreateWithoutDeploymentPlansInput, PromptUncheckedCreateWithoutDeploymentPlansInput>
    connectOrCreate?: PromptCreateOrConnectWithoutDeploymentPlansInput
    connect?: PromptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedDeploymentPlansInput = {
    create?: XOR<UserCreateWithoutCreatedDeploymentPlansInput, UserUncheckedCreateWithoutCreatedDeploymentPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDeploymentPlansInput
    connect?: UserWhereUniqueInput
  }

  export type DeploymentExecutionCreateNestedManyWithoutPlanInput = {
    create?: XOR<DeploymentExecutionCreateWithoutPlanInput, DeploymentExecutionUncheckedCreateWithoutPlanInput> | DeploymentExecutionCreateWithoutPlanInput[] | DeploymentExecutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutPlanInput | DeploymentExecutionCreateOrConnectWithoutPlanInput[]
    createMany?: DeploymentExecutionCreateManyPlanInputEnvelope
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
  }

  export type DeploymentApprovalCreateNestedManyWithoutPlanInput = {
    create?: XOR<DeploymentApprovalCreateWithoutPlanInput, DeploymentApprovalUncheckedCreateWithoutPlanInput> | DeploymentApprovalCreateWithoutPlanInput[] | DeploymentApprovalUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutPlanInput | DeploymentApprovalCreateOrConnectWithoutPlanInput[]
    createMany?: DeploymentApprovalCreateManyPlanInputEnvelope
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
  }

  export type DeploymentExecutionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<DeploymentExecutionCreateWithoutPlanInput, DeploymentExecutionUncheckedCreateWithoutPlanInput> | DeploymentExecutionCreateWithoutPlanInput[] | DeploymentExecutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutPlanInput | DeploymentExecutionCreateOrConnectWithoutPlanInput[]
    createMany?: DeploymentExecutionCreateManyPlanInputEnvelope
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
  }

  export type DeploymentApprovalUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<DeploymentApprovalCreateWithoutPlanInput, DeploymentApprovalUncheckedCreateWithoutPlanInput> | DeploymentApprovalCreateWithoutPlanInput[] | DeploymentApprovalUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutPlanInput | DeploymentApprovalCreateOrConnectWithoutPlanInput[]
    createMany?: DeploymentApprovalCreateManyPlanInputEnvelope
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutDeploymentPlansNestedInput = {
    create?: XOR<ProjectCreateWithoutDeploymentPlansInput, ProjectUncheckedCreateWithoutDeploymentPlansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDeploymentPlansInput
    upsert?: ProjectUpsertWithoutDeploymentPlansInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDeploymentPlansInput, ProjectUpdateWithoutDeploymentPlansInput>, ProjectUncheckedUpdateWithoutDeploymentPlansInput>
  }

  export type PromptUpdateOneRequiredWithoutDeploymentPlansNestedInput = {
    create?: XOR<PromptCreateWithoutDeploymentPlansInput, PromptUncheckedCreateWithoutDeploymentPlansInput>
    connectOrCreate?: PromptCreateOrConnectWithoutDeploymentPlansInput
    upsert?: PromptUpsertWithoutDeploymentPlansInput
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutDeploymentPlansInput, PromptUpdateWithoutDeploymentPlansInput>, PromptUncheckedUpdateWithoutDeploymentPlansInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedDeploymentPlansNestedInput = {
    create?: XOR<UserCreateWithoutCreatedDeploymentPlansInput, UserUncheckedCreateWithoutCreatedDeploymentPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDeploymentPlansInput
    upsert?: UserUpsertWithoutCreatedDeploymentPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedDeploymentPlansInput, UserUpdateWithoutCreatedDeploymentPlansInput>, UserUncheckedUpdateWithoutCreatedDeploymentPlansInput>
  }

  export type DeploymentExecutionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<DeploymentExecutionCreateWithoutPlanInput, DeploymentExecutionUncheckedCreateWithoutPlanInput> | DeploymentExecutionCreateWithoutPlanInput[] | DeploymentExecutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutPlanInput | DeploymentExecutionCreateOrConnectWithoutPlanInput[]
    upsert?: DeploymentExecutionUpsertWithWhereUniqueWithoutPlanInput | DeploymentExecutionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: DeploymentExecutionCreateManyPlanInputEnvelope
    set?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    disconnect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    delete?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    update?: DeploymentExecutionUpdateWithWhereUniqueWithoutPlanInput | DeploymentExecutionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: DeploymentExecutionUpdateManyWithWhereWithoutPlanInput | DeploymentExecutionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: DeploymentExecutionScalarWhereInput | DeploymentExecutionScalarWhereInput[]
  }

  export type DeploymentApprovalUpdateManyWithoutPlanNestedInput = {
    create?: XOR<DeploymentApprovalCreateWithoutPlanInput, DeploymentApprovalUncheckedCreateWithoutPlanInput> | DeploymentApprovalCreateWithoutPlanInput[] | DeploymentApprovalUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutPlanInput | DeploymentApprovalCreateOrConnectWithoutPlanInput[]
    upsert?: DeploymentApprovalUpsertWithWhereUniqueWithoutPlanInput | DeploymentApprovalUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: DeploymentApprovalCreateManyPlanInputEnvelope
    set?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    disconnect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    delete?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    update?: DeploymentApprovalUpdateWithWhereUniqueWithoutPlanInput | DeploymentApprovalUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: DeploymentApprovalUpdateManyWithWhereWithoutPlanInput | DeploymentApprovalUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: DeploymentApprovalScalarWhereInput | DeploymentApprovalScalarWhereInput[]
  }

  export type DeploymentExecutionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<DeploymentExecutionCreateWithoutPlanInput, DeploymentExecutionUncheckedCreateWithoutPlanInput> | DeploymentExecutionCreateWithoutPlanInput[] | DeploymentExecutionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentExecutionCreateOrConnectWithoutPlanInput | DeploymentExecutionCreateOrConnectWithoutPlanInput[]
    upsert?: DeploymentExecutionUpsertWithWhereUniqueWithoutPlanInput | DeploymentExecutionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: DeploymentExecutionCreateManyPlanInputEnvelope
    set?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    disconnect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    delete?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    connect?: DeploymentExecutionWhereUniqueInput | DeploymentExecutionWhereUniqueInput[]
    update?: DeploymentExecutionUpdateWithWhereUniqueWithoutPlanInput | DeploymentExecutionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: DeploymentExecutionUpdateManyWithWhereWithoutPlanInput | DeploymentExecutionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: DeploymentExecutionScalarWhereInput | DeploymentExecutionScalarWhereInput[]
  }

  export type DeploymentApprovalUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<DeploymentApprovalCreateWithoutPlanInput, DeploymentApprovalUncheckedCreateWithoutPlanInput> | DeploymentApprovalCreateWithoutPlanInput[] | DeploymentApprovalUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: DeploymentApprovalCreateOrConnectWithoutPlanInput | DeploymentApprovalCreateOrConnectWithoutPlanInput[]
    upsert?: DeploymentApprovalUpsertWithWhereUniqueWithoutPlanInput | DeploymentApprovalUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: DeploymentApprovalCreateManyPlanInputEnvelope
    set?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    disconnect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    delete?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    connect?: DeploymentApprovalWhereUniqueInput | DeploymentApprovalWhereUniqueInput[]
    update?: DeploymentApprovalUpdateWithWhereUniqueWithoutPlanInput | DeploymentApprovalUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: DeploymentApprovalUpdateManyWithWhereWithoutPlanInput | DeploymentApprovalUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: DeploymentApprovalScalarWhereInput | DeploymentApprovalScalarWhereInput[]
  }

  export type DeploymentPlanCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<DeploymentPlanCreateWithoutExecutionsInput, DeploymentPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutExecutionsInput
    connect?: DeploymentPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExecutedDeploymentsInput = {
    create?: XOR<UserCreateWithoutExecutedDeploymentsInput, UserUncheckedCreateWithoutExecutedDeploymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutedDeploymentsInput
    connect?: UserWhereUniqueInput
  }

  export type DeploymentPlanUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutExecutionsInput, DeploymentPlanUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutExecutionsInput
    upsert?: DeploymentPlanUpsertWithoutExecutionsInput
    connect?: DeploymentPlanWhereUniqueInput
    update?: XOR<XOR<DeploymentPlanUpdateToOneWithWhereWithoutExecutionsInput, DeploymentPlanUpdateWithoutExecutionsInput>, DeploymentPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserUpdateOneRequiredWithoutExecutedDeploymentsNestedInput = {
    create?: XOR<UserCreateWithoutExecutedDeploymentsInput, UserUncheckedCreateWithoutExecutedDeploymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExecutedDeploymentsInput
    upsert?: UserUpsertWithoutExecutedDeploymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExecutedDeploymentsInput, UserUpdateWithoutExecutedDeploymentsInput>, UserUncheckedUpdateWithoutExecutedDeploymentsInput>
  }

  export type DeploymentPlanCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<DeploymentPlanCreateWithoutApprovalsInput, DeploymentPlanUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutApprovalsInput
    connect?: DeploymentPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeploymentApprovalsInput = {
    create?: XOR<UserCreateWithoutDeploymentApprovalsInput, UserUncheckedCreateWithoutDeploymentApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeploymentApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type DeploymentPlanUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<DeploymentPlanCreateWithoutApprovalsInput, DeploymentPlanUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: DeploymentPlanCreateOrConnectWithoutApprovalsInput
    upsert?: DeploymentPlanUpsertWithoutApprovalsInput
    connect?: DeploymentPlanWhereUniqueInput
    update?: XOR<XOR<DeploymentPlanUpdateToOneWithWhereWithoutApprovalsInput, DeploymentPlanUpdateWithoutApprovalsInput>, DeploymentPlanUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutDeploymentApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutDeploymentApprovalsInput, UserUncheckedCreateWithoutDeploymentApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeploymentApprovalsInput
    upsert?: UserUpsertWithoutDeploymentApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeploymentApprovalsInput, UserUpdateWithoutDeploymentApprovalsInput>, UserUncheckedUpdateWithoutDeploymentApprovalsInput>
  }

  export type ProjectCreateNestedOneWithoutApprovalRequestsInput = {
    create?: XOR<ProjectCreateWithoutApprovalRequestsInput, ProjectUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApprovalRequestsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutApprovalRequestsInput = {
    create?: XOR<PromptCreateWithoutApprovalRequestsInput, PromptUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutApprovalRequestsInput
    connect?: PromptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestedApprovalsInput = {
    create?: XOR<UserCreateWithoutRequestedApprovalsInput, UserUncheckedCreateWithoutRequestedApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type ImpactAnalysisCreateNestedOneWithoutApprovalRequestsInput = {
    create?: XOR<ImpactAnalysisCreateWithoutApprovalRequestsInput, ImpactAnalysisUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutApprovalRequestsInput
    connect?: ImpactAnalysisWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutApprovalRequestsNestedInput = {
    create?: XOR<ProjectCreateWithoutApprovalRequestsInput, ProjectUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApprovalRequestsInput
    upsert?: ProjectUpsertWithoutApprovalRequestsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApprovalRequestsInput, ProjectUpdateWithoutApprovalRequestsInput>, ProjectUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type PromptUpdateOneRequiredWithoutApprovalRequestsNestedInput = {
    create?: XOR<PromptCreateWithoutApprovalRequestsInput, PromptUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutApprovalRequestsInput
    upsert?: PromptUpsertWithoutApprovalRequestsInput
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutApprovalRequestsInput, PromptUpdateWithoutApprovalRequestsInput>, PromptUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutRequestedApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutRequestedApprovalsInput, UserUncheckedCreateWithoutRequestedApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestedApprovalsInput
    upsert?: UserUpsertWithoutRequestedApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequestedApprovalsInput, UserUpdateWithoutRequestedApprovalsInput>, UserUncheckedUpdateWithoutRequestedApprovalsInput>
  }

  export type ImpactAnalysisUpdateOneWithoutApprovalRequestsNestedInput = {
    create?: XOR<ImpactAnalysisCreateWithoutApprovalRequestsInput, ImpactAnalysisUncheckedCreateWithoutApprovalRequestsInput>
    connectOrCreate?: ImpactAnalysisCreateOrConnectWithoutApprovalRequestsInput
    upsert?: ImpactAnalysisUpsertWithoutApprovalRequestsInput
    disconnect?: ImpactAnalysisWhereInput | boolean
    delete?: ImpactAnalysisWhereInput | boolean
    connect?: ImpactAnalysisWhereUniqueInput
    update?: XOR<XOR<ImpactAnalysisUpdateToOneWithWhereWithoutApprovalRequestsInput, ImpactAnalysisUpdateWithoutApprovalRequestsInput>, ImpactAnalysisUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
  }

  export type ProjectCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectCreateManyOwnerInputEnvelope = {
    data: ProjectCreateManyOwnerInput | ProjectCreateManyOwnerInput[]
  }

  export type TestRunCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestRunsInput
    prompt: PromptCreateNestedOneWithoutTestRunsInput
    responses?: TestResponseCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    responses?: TestResponseUncheckedCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricUncheckedCreateNestedManyWithoutTestRunInput
  }

  export type TestRunCreateOrConnectWithoutUserInput = {
    where: TestRunWhereUniqueInput
    create: XOR<TestRunCreateWithoutUserInput, TestRunUncheckedCreateWithoutUserInput>
  }

  export type TestRunCreateManyUserInputEnvelope = {
    data: TestRunCreateManyUserInput | TestRunCreateManyUserInput[]
  }

  export type DeploymentCreateWithoutDeployedByUserInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutDeploymentsInput
    environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
    history?: DeploymentHistoryCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateWithoutDeployedByUserInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    environmentId: string
    history?: DeploymentHistoryUncheckedCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentCreateOrConnectWithoutDeployedByUserInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutDeployedByUserInput, DeploymentUncheckedCreateWithoutDeployedByUserInput>
  }

  export type DeploymentCreateManyDeployedByUserInputEnvelope = {
    data: DeploymentCreateManyDeployedByUserInput | DeploymentCreateManyDeployedByUserInput[]
  }

  export type DeploymentHistoryCreateWithoutUserInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    deployment: DeploymentCreateNestedOneWithoutHistoryInput
  }

  export type DeploymentHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    deploymentId: string
  }

  export type DeploymentHistoryCreateOrConnectWithoutUserInput = {
    where: DeploymentHistoryWhereUniqueInput
    create: XOR<DeploymentHistoryCreateWithoutUserInput, DeploymentHistoryUncheckedCreateWithoutUserInput>
  }

  export type DeploymentHistoryCreateManyUserInputEnvelope = {
    data: DeploymentHistoryCreateManyUserInput | DeploymentHistoryCreateManyUserInput[]
  }

  export type CostTrackingCreateWithoutUserInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutCostTrackingInput
  }

  export type CostTrackingUncheckedCreateWithoutUserInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type CostTrackingCreateOrConnectWithoutUserInput = {
    where: CostTrackingWhereUniqueInput
    create: XOR<CostTrackingCreateWithoutUserInput, CostTrackingUncheckedCreateWithoutUserInput>
  }

  export type CostTrackingCreateManyUserInputEnvelope = {
    data: CostTrackingCreateManyUserInput | CostTrackingCreateManyUserInput[]
  }

  export type UserBillingCreateWithoutUserInput = {
    id?: string
    billingEmail?: string | null
    plan?: string
    monthlyLimit?: number
    currentUsage?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBillingUncheckedCreateWithoutUserInput = {
    id?: string
    billingEmail?: string | null
    plan?: string
    monthlyLimit?: number
    currentUsage?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBillingCreateOrConnectWithoutUserInput = {
    where: UserBillingWhereUniqueInput
    create: XOR<UserBillingCreateWithoutUserInput, UserBillingUncheckedCreateWithoutUserInput>
  }

  export type AppIntegrationCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAppIntegrationsInput
    syncOperations?: SyncOperationCreateNestedManyWithoutConnectionInput
  }

  export type AppIntegrationUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type AppIntegrationCreateOrConnectWithoutCreatorInput = {
    where: AppIntegrationWhereUniqueInput
    create: XOR<AppIntegrationCreateWithoutCreatorInput, AppIntegrationUncheckedCreateWithoutCreatorInput>
  }

  export type AppIntegrationCreateManyCreatorInputEnvelope = {
    data: AppIntegrationCreateManyCreatorInput | AppIntegrationCreateManyCreatorInput[]
  }

  export type TestPipelineCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestPipelinesInput
    stages?: PipelineStageCreateNestedManyWithoutPipelineInput
    executions?: PipelineExecutionCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    stages?: PipelineStageUncheckedCreateNestedManyWithoutPipelineInput
    executions?: PipelineExecutionUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineCreateOrConnectWithoutCreatorInput = {
    where: TestPipelineWhereUniqueInput
    create: XOR<TestPipelineCreateWithoutCreatorInput, TestPipelineUncheckedCreateWithoutCreatorInput>
  }

  export type TestPipelineCreateManyCreatorInputEnvelope = {
    data: TestPipelineCreateManyCreatorInput | TestPipelineCreateManyCreatorInput[]
  }

  export type PipelineExecutionCreateWithoutExecutorInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: TestPipelineCreateNestedOneWithoutExecutionsInput
    prompt: PromptCreateNestedOneWithoutPipelineExecutionsInput
    baselinePrompt?: PromptCreateNestedOneWithoutBaselinePipelineExecutionsInput
  }

  export type PipelineExecutionUncheckedCreateWithoutExecutorInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    promptId: string
    baselinePromptId?: string | null
  }

  export type PipelineExecutionCreateOrConnectWithoutExecutorInput = {
    where: PipelineExecutionWhereUniqueInput
    create: XOR<PipelineExecutionCreateWithoutExecutorInput, PipelineExecutionUncheckedCreateWithoutExecutorInput>
  }

  export type PipelineExecutionCreateManyExecutorInputEnvelope = {
    data: PipelineExecutionCreateManyExecutorInput | PipelineExecutionCreateManyExecutorInput[]
  }

  export type DependencyCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDependenciesInput
  }

  export type DependencyUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type DependencyCreateOrConnectWithoutCreatorInput = {
    where: DependencyWhereUniqueInput
    create: XOR<DependencyCreateWithoutCreatorInput, DependencyUncheckedCreateWithoutCreatorInput>
  }

  export type DependencyCreateManyCreatorInputEnvelope = {
    data: DependencyCreateManyCreatorInput | DependencyCreateManyCreatorInput[]
  }

  export type UpdatePlanCreateWithoutCreatorInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatePlansInput
    executor?: UserCreateNestedOneWithoutExecutedUpdatePlansInput
  }

  export type UpdatePlanUncheckedCreateWithoutCreatorInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    executedBy?: string | null
  }

  export type UpdatePlanCreateOrConnectWithoutCreatorInput = {
    where: UpdatePlanWhereUniqueInput
    create: XOR<UpdatePlanCreateWithoutCreatorInput, UpdatePlanUncheckedCreateWithoutCreatorInput>
  }

  export type UpdatePlanCreateManyCreatorInputEnvelope = {
    data: UpdatePlanCreateManyCreatorInput | UpdatePlanCreateManyCreatorInput[]
  }

  export type UpdatePlanCreateWithoutExecutorInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatePlansInput
    creator: UserCreateNestedOneWithoutCreatedUpdatePlansInput
  }

  export type UpdatePlanUncheckedCreateWithoutExecutorInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type UpdatePlanCreateOrConnectWithoutExecutorInput = {
    where: UpdatePlanWhereUniqueInput
    create: XOR<UpdatePlanCreateWithoutExecutorInput, UpdatePlanUncheckedCreateWithoutExecutorInput>
  }

  export type UpdatePlanCreateManyExecutorInputEnvelope = {
    data: UpdatePlanCreateManyExecutorInput | UpdatePlanCreateManyExecutorInput[]
  }

  export type DeploymentPlanCreateWithoutCreatorInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeploymentPlansInput
    prompt: PromptCreateNestedOneWithoutDeploymentPlansInput
    executions?: DeploymentExecutionCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUncheckedCreateWithoutCreatorInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    executions?: DeploymentExecutionUncheckedCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalUncheckedCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanCreateOrConnectWithoutCreatorInput = {
    where: DeploymentPlanWhereUniqueInput
    create: XOR<DeploymentPlanCreateWithoutCreatorInput, DeploymentPlanUncheckedCreateWithoutCreatorInput>
  }

  export type DeploymentPlanCreateManyCreatorInputEnvelope = {
    data: DeploymentPlanCreateManyCreatorInput | DeploymentPlanCreateManyCreatorInput[]
  }

  export type DeploymentExecutionCreateWithoutExecutorInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: DeploymentPlanCreateNestedOneWithoutExecutionsInput
  }

  export type DeploymentExecutionUncheckedCreateWithoutExecutorInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
  }

  export type DeploymentExecutionCreateOrConnectWithoutExecutorInput = {
    where: DeploymentExecutionWhereUniqueInput
    create: XOR<DeploymentExecutionCreateWithoutExecutorInput, DeploymentExecutionUncheckedCreateWithoutExecutorInput>
  }

  export type DeploymentExecutionCreateManyExecutorInputEnvelope = {
    data: DeploymentExecutionCreateManyExecutorInput | DeploymentExecutionCreateManyExecutorInput[]
  }

  export type DeploymentApprovalCreateWithoutApproverInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: DeploymentPlanCreateNestedOneWithoutApprovalsInput
  }

  export type DeploymentApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
  }

  export type DeploymentApprovalCreateOrConnectWithoutApproverInput = {
    where: DeploymentApprovalWhereUniqueInput
    create: XOR<DeploymentApprovalCreateWithoutApproverInput, DeploymentApprovalUncheckedCreateWithoutApproverInput>
  }

  export type DeploymentApprovalCreateManyApproverInputEnvelope = {
    data: DeploymentApprovalCreateManyApproverInput | DeploymentApprovalCreateManyApproverInput[]
  }

  export type ApprovalRequestCreateWithoutRequesterInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appId: string
    project: ProjectCreateNestedOneWithoutApprovalRequestsInput
    prompt: PromptCreateNestedOneWithoutApprovalRequestsInput
    impactAnalysis?: ImpactAnalysisCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    appId: string
    impactAnalysisId?: string | null
  }

  export type ApprovalRequestCreateOrConnectWithoutRequesterInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput>
  }

  export type ApprovalRequestCreateManyRequesterInputEnvelope = {
    data: ApprovalRequestCreateManyRequesterInput | ApprovalRequestCreateManyRequesterInput[]
  }

  export type SyncOperationCreateWithoutInitiatorInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSyncOperationsInput
    connection: AppIntegrationCreateNestedOneWithoutSyncOperationsInput
  }

  export type SyncOperationUncheckedCreateWithoutInitiatorInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    connectionId: string
  }

  export type SyncOperationCreateOrConnectWithoutInitiatorInput = {
    where: SyncOperationWhereUniqueInput
    create: XOR<SyncOperationCreateWithoutInitiatorInput, SyncOperationUncheckedCreateWithoutInitiatorInput>
  }

  export type SyncOperationCreateManyInitiatorInputEnvelope = {
    data: SyncOperationCreateManyInitiatorInput | SyncOperationCreateManyInitiatorInput[]
  }

  export type WebhookSubscriptionCreateWithoutCreatorInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWebhookSubscriptionsInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
    failedDeliveries?: WebhookDeliveryCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionUncheckedCreateWithoutCreatorInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
    failedDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionCreateOrConnectWithoutCreatorInput = {
    where: WebhookSubscriptionWhereUniqueInput
    create: XOR<WebhookSubscriptionCreateWithoutCreatorInput, WebhookSubscriptionUncheckedCreateWithoutCreatorInput>
  }

  export type WebhookSubscriptionCreateManyCreatorInputEnvelope = {
    data: WebhookSubscriptionCreateManyCreatorInput | WebhookSubscriptionCreateManyCreatorInput[]
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    createdAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    settings?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
  }

  export type TestRunUpsertWithWhereUniqueWithoutUserInput = {
    where: TestRunWhereUniqueInput
    update: XOR<TestRunUpdateWithoutUserInput, TestRunUncheckedUpdateWithoutUserInput>
    create: XOR<TestRunCreateWithoutUserInput, TestRunUncheckedCreateWithoutUserInput>
  }

  export type TestRunUpdateWithWhereUniqueWithoutUserInput = {
    where: TestRunWhereUniqueInput
    data: XOR<TestRunUpdateWithoutUserInput, TestRunUncheckedUpdateWithoutUserInput>
  }

  export type TestRunUpdateManyWithWhereWithoutUserInput = {
    where: TestRunScalarWhereInput
    data: XOR<TestRunUpdateManyMutationInput, TestRunUncheckedUpdateManyWithoutUserInput>
  }

  export type TestRunScalarWhereInput = {
    AND?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
    OR?: TestRunScalarWhereInput[]
    NOT?: TestRunScalarWhereInput | TestRunScalarWhereInput[]
    id?: StringFilter<"TestRun"> | string
    name?: StringFilter<"TestRun"> | string
    description?: StringNullableFilter<"TestRun"> | string | null
    status?: StringFilter<"TestRun"> | string
    config?: StringFilter<"TestRun"> | string
    metadata?: StringNullableFilter<"TestRun"> | string | null
    startedAt?: DateTimeNullableFilter<"TestRun"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TestRun"> | Date | string | null
    createdAt?: DateTimeFilter<"TestRun"> | Date | string
    updatedAt?: DateTimeFilter<"TestRun"> | Date | string
    projectId?: StringFilter<"TestRun"> | string
    userId?: StringFilter<"TestRun"> | string
    promptId?: StringFilter<"TestRun"> | string
  }

  export type DeploymentUpsertWithWhereUniqueWithoutDeployedByUserInput = {
    where: DeploymentWhereUniqueInput
    update: XOR<DeploymentUpdateWithoutDeployedByUserInput, DeploymentUncheckedUpdateWithoutDeployedByUserInput>
    create: XOR<DeploymentCreateWithoutDeployedByUserInput, DeploymentUncheckedCreateWithoutDeployedByUserInput>
  }

  export type DeploymentUpdateWithWhereUniqueWithoutDeployedByUserInput = {
    where: DeploymentWhereUniqueInput
    data: XOR<DeploymentUpdateWithoutDeployedByUserInput, DeploymentUncheckedUpdateWithoutDeployedByUserInput>
  }

  export type DeploymentUpdateManyWithWhereWithoutDeployedByUserInput = {
    where: DeploymentScalarWhereInput
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutDeployedByUserInput>
  }

  export type DeploymentScalarWhereInput = {
    AND?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
    OR?: DeploymentScalarWhereInput[]
    NOT?: DeploymentScalarWhereInput | DeploymentScalarWhereInput[]
    id?: StringFilter<"Deployment"> | string
    version?: StringFilter<"Deployment"> | string
    status?: StringFilter<"Deployment"> | string
    deployedUrl?: StringNullableFilter<"Deployment"> | string | null
    config?: StringNullableFilter<"Deployment"> | string | null
    metadata?: StringNullableFilter<"Deployment"> | string | null
    deployedAt?: DateTimeNullableFilter<"Deployment"> | Date | string | null
    rollbackAt?: DateTimeNullableFilter<"Deployment"> | Date | string | null
    createdAt?: DateTimeFilter<"Deployment"> | Date | string
    updatedAt?: DateTimeFilter<"Deployment"> | Date | string
    promptId?: StringFilter<"Deployment"> | string
    environmentId?: StringFilter<"Deployment"> | string
    deployedBy?: StringFilter<"Deployment"> | string
  }

  export type DeploymentHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: DeploymentHistoryWhereUniqueInput
    update: XOR<DeploymentHistoryUpdateWithoutUserInput, DeploymentHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<DeploymentHistoryCreateWithoutUserInput, DeploymentHistoryUncheckedCreateWithoutUserInput>
  }

  export type DeploymentHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: DeploymentHistoryWhereUniqueInput
    data: XOR<DeploymentHistoryUpdateWithoutUserInput, DeploymentHistoryUncheckedUpdateWithoutUserInput>
  }

  export type DeploymentHistoryUpdateManyWithWhereWithoutUserInput = {
    where: DeploymentHistoryScalarWhereInput
    data: XOR<DeploymentHistoryUpdateManyMutationInput, DeploymentHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type DeploymentHistoryScalarWhereInput = {
    AND?: DeploymentHistoryScalarWhereInput | DeploymentHistoryScalarWhereInput[]
    OR?: DeploymentHistoryScalarWhereInput[]
    NOT?: DeploymentHistoryScalarWhereInput | DeploymentHistoryScalarWhereInput[]
    id?: StringFilter<"DeploymentHistory"> | string
    action?: StringFilter<"DeploymentHistory"> | string
    status?: StringFilter<"DeploymentHistory"> | string
    metadata?: StringNullableFilter<"DeploymentHistory"> | string | null
    timestamp?: DateTimeFilter<"DeploymentHistory"> | Date | string
    deploymentId?: StringFilter<"DeploymentHistory"> | string
    performedBy?: StringFilter<"DeploymentHistory"> | string
  }

  export type CostTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: CostTrackingWhereUniqueInput
    update: XOR<CostTrackingUpdateWithoutUserInput, CostTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<CostTrackingCreateWithoutUserInput, CostTrackingUncheckedCreateWithoutUserInput>
  }

  export type CostTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: CostTrackingWhereUniqueInput
    data: XOR<CostTrackingUpdateWithoutUserInput, CostTrackingUncheckedUpdateWithoutUserInput>
  }

  export type CostTrackingUpdateManyWithWhereWithoutUserInput = {
    where: CostTrackingScalarWhereInput
    data: XOR<CostTrackingUpdateManyMutationInput, CostTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type CostTrackingScalarWhereInput = {
    AND?: CostTrackingScalarWhereInput | CostTrackingScalarWhereInput[]
    OR?: CostTrackingScalarWhereInput[]
    NOT?: CostTrackingScalarWhereInput | CostTrackingScalarWhereInput[]
    id?: StringFilter<"CostTracking"> | string
    period?: StringFilter<"CostTracking"> | string
    totalCost?: FloatFilter<"CostTracking"> | number
    tokenUsage?: IntFilter<"CostTracking"> | number
    requestCount?: IntFilter<"CostTracking"> | number
    breakdown?: StringFilter<"CostTracking"> | string
    createdAt?: DateTimeFilter<"CostTracking"> | Date | string
    updatedAt?: DateTimeFilter<"CostTracking"> | Date | string
    projectId?: StringFilter<"CostTracking"> | string
    userId?: StringNullableFilter<"CostTracking"> | string | null
  }

  export type UserBillingUpsertWithoutUserInput = {
    update: XOR<UserBillingUpdateWithoutUserInput, UserBillingUncheckedUpdateWithoutUserInput>
    create: XOR<UserBillingCreateWithoutUserInput, UserBillingUncheckedCreateWithoutUserInput>
    where?: UserBillingWhereInput
  }

  export type UserBillingUpdateToOneWithWhereWithoutUserInput = {
    where?: UserBillingWhereInput
    data: XOR<UserBillingUpdateWithoutUserInput, UserBillingUncheckedUpdateWithoutUserInput>
  }

  export type UserBillingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    monthlyLimit?: FloatFieldUpdateOperationsInput | number
    currentUsage?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBillingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    billingEmail?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: StringFieldUpdateOperationsInput | string
    monthlyLimit?: FloatFieldUpdateOperationsInput | number
    currentUsage?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIntegrationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AppIntegrationWhereUniqueInput
    update: XOR<AppIntegrationUpdateWithoutCreatorInput, AppIntegrationUncheckedUpdateWithoutCreatorInput>
    create: XOR<AppIntegrationCreateWithoutCreatorInput, AppIntegrationUncheckedCreateWithoutCreatorInput>
  }

  export type AppIntegrationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AppIntegrationWhereUniqueInput
    data: XOR<AppIntegrationUpdateWithoutCreatorInput, AppIntegrationUncheckedUpdateWithoutCreatorInput>
  }

  export type AppIntegrationUpdateManyWithWhereWithoutCreatorInput = {
    where: AppIntegrationScalarWhereInput
    data: XOR<AppIntegrationUpdateManyMutationInput, AppIntegrationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AppIntegrationScalarWhereInput = {
    AND?: AppIntegrationScalarWhereInput | AppIntegrationScalarWhereInput[]
    OR?: AppIntegrationScalarWhereInput[]
    NOT?: AppIntegrationScalarWhereInput | AppIntegrationScalarWhereInput[]
    id?: StringFilter<"AppIntegration"> | string
    name?: StringFilter<"AppIntegration"> | string
    type?: StringFilter<"AppIntegration"> | string
    baseUrl?: StringFilter<"AppIntegration"> | string
    apiKeyHash?: StringFilter<"AppIntegration"> | string
    syncConfig?: StringFilter<"AppIntegration"> | string
    isActive?: BoolFilter<"AppIntegration"> | boolean
    lastSync?: DateTimeNullableFilter<"AppIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"AppIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"AppIntegration"> | Date | string
    projectId?: StringFilter<"AppIntegration"> | string
    createdBy?: StringFilter<"AppIntegration"> | string
  }

  export type TestPipelineUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TestPipelineWhereUniqueInput
    update: XOR<TestPipelineUpdateWithoutCreatorInput, TestPipelineUncheckedUpdateWithoutCreatorInput>
    create: XOR<TestPipelineCreateWithoutCreatorInput, TestPipelineUncheckedCreateWithoutCreatorInput>
  }

  export type TestPipelineUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TestPipelineWhereUniqueInput
    data: XOR<TestPipelineUpdateWithoutCreatorInput, TestPipelineUncheckedUpdateWithoutCreatorInput>
  }

  export type TestPipelineUpdateManyWithWhereWithoutCreatorInput = {
    where: TestPipelineScalarWhereInput
    data: XOR<TestPipelineUpdateManyMutationInput, TestPipelineUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TestPipelineScalarWhereInput = {
    AND?: TestPipelineScalarWhereInput | TestPipelineScalarWhereInput[]
    OR?: TestPipelineScalarWhereInput[]
    NOT?: TestPipelineScalarWhereInput | TestPipelineScalarWhereInput[]
    id?: StringFilter<"TestPipeline"> | string
    name?: StringFilter<"TestPipeline"> | string
    description?: StringNullableFilter<"TestPipeline"> | string | null
    config?: StringFilter<"TestPipeline"> | string
    status?: StringFilter<"TestPipeline"> | string
    createdAt?: DateTimeFilter<"TestPipeline"> | Date | string
    updatedAt?: DateTimeFilter<"TestPipeline"> | Date | string
    projectId?: StringFilter<"TestPipeline"> | string
    createdBy?: StringFilter<"TestPipeline"> | string
  }

  export type PipelineExecutionUpsertWithWhereUniqueWithoutExecutorInput = {
    where: PipelineExecutionWhereUniqueInput
    update: XOR<PipelineExecutionUpdateWithoutExecutorInput, PipelineExecutionUncheckedUpdateWithoutExecutorInput>
    create: XOR<PipelineExecutionCreateWithoutExecutorInput, PipelineExecutionUncheckedCreateWithoutExecutorInput>
  }

  export type PipelineExecutionUpdateWithWhereUniqueWithoutExecutorInput = {
    where: PipelineExecutionWhereUniqueInput
    data: XOR<PipelineExecutionUpdateWithoutExecutorInput, PipelineExecutionUncheckedUpdateWithoutExecutorInput>
  }

  export type PipelineExecutionUpdateManyWithWhereWithoutExecutorInput = {
    where: PipelineExecutionScalarWhereInput
    data: XOR<PipelineExecutionUpdateManyMutationInput, PipelineExecutionUncheckedUpdateManyWithoutExecutorInput>
  }

  export type PipelineExecutionScalarWhereInput = {
    AND?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
    OR?: PipelineExecutionScalarWhereInput[]
    NOT?: PipelineExecutionScalarWhereInput | PipelineExecutionScalarWhereInput[]
    id?: StringFilter<"PipelineExecution"> | string
    status?: StringFilter<"PipelineExecution"> | string
    startedAt?: DateTimeNullableFilter<"PipelineExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PipelineExecution"> | Date | string | null
    result?: StringNullableFilter<"PipelineExecution"> | string | null
    error?: StringNullableFilter<"PipelineExecution"> | string | null
    metadata?: StringNullableFilter<"PipelineExecution"> | string | null
    createdAt?: DateTimeFilter<"PipelineExecution"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineExecution"> | Date | string
    pipelineId?: StringFilter<"PipelineExecution"> | string
    promptId?: StringFilter<"PipelineExecution"> | string
    baselinePromptId?: StringNullableFilter<"PipelineExecution"> | string | null
    executedBy?: StringFilter<"PipelineExecution"> | string
  }

  export type DependencyUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DependencyWhereUniqueInput
    update: XOR<DependencyUpdateWithoutCreatorInput, DependencyUncheckedUpdateWithoutCreatorInput>
    create: XOR<DependencyCreateWithoutCreatorInput, DependencyUncheckedCreateWithoutCreatorInput>
  }

  export type DependencyUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DependencyWhereUniqueInput
    data: XOR<DependencyUpdateWithoutCreatorInput, DependencyUncheckedUpdateWithoutCreatorInput>
  }

  export type DependencyUpdateManyWithWhereWithoutCreatorInput = {
    where: DependencyScalarWhereInput
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DependencyScalarWhereInput = {
    AND?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
    OR?: DependencyScalarWhereInput[]
    NOT?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
    id?: StringFilter<"Dependency"> | string
    name?: StringFilter<"Dependency"> | string
    type?: StringFilter<"Dependency"> | string
    provider?: StringFilter<"Dependency"> | string
    config?: StringFilter<"Dependency"> | string
    status?: StringFilter<"Dependency"> | string
    version?: StringNullableFilter<"Dependency"> | string | null
    healthScore?: IntFilter<"Dependency"> | number
    lastCheck?: DateTimeFilter<"Dependency"> | Date | string
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    updatedAt?: DateTimeFilter<"Dependency"> | Date | string
    projectId?: StringFilter<"Dependency"> | string
    createdBy?: StringFilter<"Dependency"> | string
  }

  export type UpdatePlanUpsertWithWhereUniqueWithoutCreatorInput = {
    where: UpdatePlanWhereUniqueInput
    update: XOR<UpdatePlanUpdateWithoutCreatorInput, UpdatePlanUncheckedUpdateWithoutCreatorInput>
    create: XOR<UpdatePlanCreateWithoutCreatorInput, UpdatePlanUncheckedCreateWithoutCreatorInput>
  }

  export type UpdatePlanUpdateWithWhereUniqueWithoutCreatorInput = {
    where: UpdatePlanWhereUniqueInput
    data: XOR<UpdatePlanUpdateWithoutCreatorInput, UpdatePlanUncheckedUpdateWithoutCreatorInput>
  }

  export type UpdatePlanUpdateManyWithWhereWithoutCreatorInput = {
    where: UpdatePlanScalarWhereInput
    data: XOR<UpdatePlanUpdateManyMutationInput, UpdatePlanUncheckedUpdateManyWithoutCreatorInput>
  }

  export type UpdatePlanScalarWhereInput = {
    AND?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
    OR?: UpdatePlanScalarWhereInput[]
    NOT?: UpdatePlanScalarWhereInput | UpdatePlanScalarWhereInput[]
    id?: StringFilter<"UpdatePlan"> | string
    planData?: StringFilter<"UpdatePlan"> | string
    status?: StringFilter<"UpdatePlan"> | string
    executionResult?: StringNullableFilter<"UpdatePlan"> | string | null
    executedAt?: DateTimeNullableFilter<"UpdatePlan"> | Date | string | null
    createdAt?: DateTimeFilter<"UpdatePlan"> | Date | string
    updatedAt?: DateTimeFilter<"UpdatePlan"> | Date | string
    projectId?: StringFilter<"UpdatePlan"> | string
    createdBy?: StringFilter<"UpdatePlan"> | string
    executedBy?: StringNullableFilter<"UpdatePlan"> | string | null
  }

  export type UpdatePlanUpsertWithWhereUniqueWithoutExecutorInput = {
    where: UpdatePlanWhereUniqueInput
    update: XOR<UpdatePlanUpdateWithoutExecutorInput, UpdatePlanUncheckedUpdateWithoutExecutorInput>
    create: XOR<UpdatePlanCreateWithoutExecutorInput, UpdatePlanUncheckedCreateWithoutExecutorInput>
  }

  export type UpdatePlanUpdateWithWhereUniqueWithoutExecutorInput = {
    where: UpdatePlanWhereUniqueInput
    data: XOR<UpdatePlanUpdateWithoutExecutorInput, UpdatePlanUncheckedUpdateWithoutExecutorInput>
  }

  export type UpdatePlanUpdateManyWithWhereWithoutExecutorInput = {
    where: UpdatePlanScalarWhereInput
    data: XOR<UpdatePlanUpdateManyMutationInput, UpdatePlanUncheckedUpdateManyWithoutExecutorInput>
  }

  export type DeploymentPlanUpsertWithWhereUniqueWithoutCreatorInput = {
    where: DeploymentPlanWhereUniqueInput
    update: XOR<DeploymentPlanUpdateWithoutCreatorInput, DeploymentPlanUncheckedUpdateWithoutCreatorInput>
    create: XOR<DeploymentPlanCreateWithoutCreatorInput, DeploymentPlanUncheckedCreateWithoutCreatorInput>
  }

  export type DeploymentPlanUpdateWithWhereUniqueWithoutCreatorInput = {
    where: DeploymentPlanWhereUniqueInput
    data: XOR<DeploymentPlanUpdateWithoutCreatorInput, DeploymentPlanUncheckedUpdateWithoutCreatorInput>
  }

  export type DeploymentPlanUpdateManyWithWhereWithoutCreatorInput = {
    where: DeploymentPlanScalarWhereInput
    data: XOR<DeploymentPlanUpdateManyMutationInput, DeploymentPlanUncheckedUpdateManyWithoutCreatorInput>
  }

  export type DeploymentPlanScalarWhereInput = {
    AND?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
    OR?: DeploymentPlanScalarWhereInput[]
    NOT?: DeploymentPlanScalarWhereInput | DeploymentPlanScalarWhereInput[]
    id?: StringFilter<"DeploymentPlan"> | string
    planData?: StringFilter<"DeploymentPlan"> | string
    status?: StringFilter<"DeploymentPlan"> | string
    createdAt?: DateTimeFilter<"DeploymentPlan"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentPlan"> | Date | string
    projectId?: StringFilter<"DeploymentPlan"> | string
    promptId?: StringFilter<"DeploymentPlan"> | string
    createdBy?: StringFilter<"DeploymentPlan"> | string
  }

  export type DeploymentExecutionUpsertWithWhereUniqueWithoutExecutorInput = {
    where: DeploymentExecutionWhereUniqueInput
    update: XOR<DeploymentExecutionUpdateWithoutExecutorInput, DeploymentExecutionUncheckedUpdateWithoutExecutorInput>
    create: XOR<DeploymentExecutionCreateWithoutExecutorInput, DeploymentExecutionUncheckedCreateWithoutExecutorInput>
  }

  export type DeploymentExecutionUpdateWithWhereUniqueWithoutExecutorInput = {
    where: DeploymentExecutionWhereUniqueInput
    data: XOR<DeploymentExecutionUpdateWithoutExecutorInput, DeploymentExecutionUncheckedUpdateWithoutExecutorInput>
  }

  export type DeploymentExecutionUpdateManyWithWhereWithoutExecutorInput = {
    where: DeploymentExecutionScalarWhereInput
    data: XOR<DeploymentExecutionUpdateManyMutationInput, DeploymentExecutionUncheckedUpdateManyWithoutExecutorInput>
  }

  export type DeploymentExecutionScalarWhereInput = {
    AND?: DeploymentExecutionScalarWhereInput | DeploymentExecutionScalarWhereInput[]
    OR?: DeploymentExecutionScalarWhereInput[]
    NOT?: DeploymentExecutionScalarWhereInput | DeploymentExecutionScalarWhereInput[]
    id?: StringFilter<"DeploymentExecution"> | string
    status?: StringFilter<"DeploymentExecution"> | string
    currentStage?: IntFilter<"DeploymentExecution"> | number
    startedAt?: DateTimeNullableFilter<"DeploymentExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"DeploymentExecution"> | Date | string | null
    metrics?: StringNullableFilter<"DeploymentExecution"> | string | null
    error?: StringNullableFilter<"DeploymentExecution"> | string | null
    metadata?: StringNullableFilter<"DeploymentExecution"> | string | null
    createdAt?: DateTimeFilter<"DeploymentExecution"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentExecution"> | Date | string
    planId?: StringFilter<"DeploymentExecution"> | string
    executedBy?: StringFilter<"DeploymentExecution"> | string
  }

  export type DeploymentApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: DeploymentApprovalWhereUniqueInput
    update: XOR<DeploymentApprovalUpdateWithoutApproverInput, DeploymentApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<DeploymentApprovalCreateWithoutApproverInput, DeploymentApprovalUncheckedCreateWithoutApproverInput>
  }

  export type DeploymentApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: DeploymentApprovalWhereUniqueInput
    data: XOR<DeploymentApprovalUpdateWithoutApproverInput, DeploymentApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type DeploymentApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: DeploymentApprovalScalarWhereInput
    data: XOR<DeploymentApprovalUpdateManyMutationInput, DeploymentApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type DeploymentApprovalScalarWhereInput = {
    AND?: DeploymentApprovalScalarWhereInput | DeploymentApprovalScalarWhereInput[]
    OR?: DeploymentApprovalScalarWhereInput[]
    NOT?: DeploymentApprovalScalarWhereInput | DeploymentApprovalScalarWhereInput[]
    id?: StringFilter<"DeploymentApproval"> | string
    status?: StringFilter<"DeploymentApproval"> | string
    comments?: StringNullableFilter<"DeploymentApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"DeploymentApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"DeploymentApproval"> | Date | string
    updatedAt?: DateTimeFilter<"DeploymentApproval"> | Date | string
    planId?: StringFilter<"DeploymentApproval"> | string
    approvedBy?: StringFilter<"DeploymentApproval"> | string
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutRequesterInput, ApprovalRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<ApprovalRequestCreateWithoutRequesterInput, ApprovalRequestUncheckedCreateWithoutRequesterInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutRequesterInput, ApprovalRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type ApprovalRequestScalarWhereInput = {
    AND?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
    OR?: ApprovalRequestScalarWhereInput[]
    NOT?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
    id?: StringFilter<"ApprovalRequest"> | string
    status?: StringFilter<"ApprovalRequest"> | string
    metadata?: StringNullableFilter<"ApprovalRequest"> | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    projectId?: StringFilter<"ApprovalRequest"> | string
    promptId?: StringFilter<"ApprovalRequest"> | string
    appId?: StringFilter<"ApprovalRequest"> | string
    requestedBy?: StringFilter<"ApprovalRequest"> | string
    impactAnalysisId?: StringNullableFilter<"ApprovalRequest"> | string | null
  }

  export type SyncOperationUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: SyncOperationWhereUniqueInput
    update: XOR<SyncOperationUpdateWithoutInitiatorInput, SyncOperationUncheckedUpdateWithoutInitiatorInput>
    create: XOR<SyncOperationCreateWithoutInitiatorInput, SyncOperationUncheckedCreateWithoutInitiatorInput>
  }

  export type SyncOperationUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: SyncOperationWhereUniqueInput
    data: XOR<SyncOperationUpdateWithoutInitiatorInput, SyncOperationUncheckedUpdateWithoutInitiatorInput>
  }

  export type SyncOperationUpdateManyWithWhereWithoutInitiatorInput = {
    where: SyncOperationScalarWhereInput
    data: XOR<SyncOperationUpdateManyMutationInput, SyncOperationUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type SyncOperationScalarWhereInput = {
    AND?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
    OR?: SyncOperationScalarWhereInput[]
    NOT?: SyncOperationScalarWhereInput | SyncOperationScalarWhereInput[]
    id?: StringFilter<"SyncOperation"> | string
    direction?: StringFilter<"SyncOperation"> | string
    strategy?: StringFilter<"SyncOperation"> | string
    status?: StringFilter<"SyncOperation"> | string
    progress?: StringFilter<"SyncOperation"> | string
    result?: StringNullableFilter<"SyncOperation"> | string | null
    error?: StringNullableFilter<"SyncOperation"> | string | null
    config?: StringFilter<"SyncOperation"> | string
    startedAt?: DateTimeNullableFilter<"SyncOperation"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SyncOperation"> | Date | string | null
    createdAt?: DateTimeFilter<"SyncOperation"> | Date | string
    updatedAt?: DateTimeFilter<"SyncOperation"> | Date | string
    projectId?: StringFilter<"SyncOperation"> | string
    connectionId?: StringFilter<"SyncOperation"> | string
    initiatedBy?: StringFilter<"SyncOperation"> | string
  }

  export type WebhookSubscriptionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WebhookSubscriptionWhereUniqueInput
    update: XOR<WebhookSubscriptionUpdateWithoutCreatorInput, WebhookSubscriptionUncheckedUpdateWithoutCreatorInput>
    create: XOR<WebhookSubscriptionCreateWithoutCreatorInput, WebhookSubscriptionUncheckedCreateWithoutCreatorInput>
  }

  export type WebhookSubscriptionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WebhookSubscriptionWhereUniqueInput
    data: XOR<WebhookSubscriptionUpdateWithoutCreatorInput, WebhookSubscriptionUncheckedUpdateWithoutCreatorInput>
  }

  export type WebhookSubscriptionUpdateManyWithWhereWithoutCreatorInput = {
    where: WebhookSubscriptionScalarWhereInput
    data: XOR<WebhookSubscriptionUpdateManyMutationInput, WebhookSubscriptionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type WebhookSubscriptionScalarWhereInput = {
    AND?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
    OR?: WebhookSubscriptionScalarWhereInput[]
    NOT?: WebhookSubscriptionScalarWhereInput | WebhookSubscriptionScalarWhereInput[]
    id?: StringFilter<"WebhookSubscription"> | string
    url?: StringFilter<"WebhookSubscription"> | string
    events?: StringFilter<"WebhookSubscription"> | string
    headers?: StringFilter<"WebhookSubscription"> | string
    secret?: StringNullableFilter<"WebhookSubscription"> | string | null
    enabled?: BoolFilter<"WebhookSubscription"> | boolean
    retryAttempts?: IntFilter<"WebhookSubscription"> | number
    lastDelivery?: DateTimeNullableFilter<"WebhookSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookSubscription"> | Date | string
    projectId?: StringNullableFilter<"WebhookSubscription"> | string | null
    createdBy?: StringFilter<"WebhookSubscription"> | string
  }

  export type UserCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOwnedProjectsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOwnedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
  }

  export type PromptCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutProjectInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput>
  }

  export type PromptCreateManyProjectInputEnvelope = {
    data: PromptCreateManyProjectInput | PromptCreateManyProjectInput[]
  }

  export type TestRunCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTestRunsInput
    prompt: PromptCreateNestedOneWithoutTestRunsInput
    responses?: TestResponseCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    promptId: string
    responses?: TestResponseUncheckedCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricUncheckedCreateNestedManyWithoutTestRunInput
  }

  export type TestRunCreateOrConnectWithoutProjectInput = {
    where: TestRunWhereUniqueInput
    create: XOR<TestRunCreateWithoutProjectInput, TestRunUncheckedCreateWithoutProjectInput>
  }

  export type TestRunCreateManyProjectInputEnvelope = {
    data: TestRunCreateManyProjectInput | TestRunCreateManyProjectInput[]
  }

  export type ApiKeyCreateWithoutProjectInput = {
    id?: string
    name: string
    provider: string
    keyHash: string
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    provider: string
    keyHash: string
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput>
  }

  export type ApiKeyCreateManyProjectInputEnvelope = {
    data: ApiKeyCreateManyProjectInput | ApiKeyCreateManyProjectInput[]
  }

  export type EnvironmentCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deployments?: DeploymentCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deployments?: DeploymentUncheckedCreateNestedManyWithoutEnvironmentInput
  }

  export type EnvironmentCreateOrConnectWithoutProjectInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutProjectInput, EnvironmentUncheckedCreateWithoutProjectInput>
  }

  export type EnvironmentCreateManyProjectInputEnvelope = {
    data: EnvironmentCreateManyProjectInput | EnvironmentCreateManyProjectInput[]
  }

  export type CostTrackingCreateWithoutProjectInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCostTrackingInput
  }

  export type CostTrackingUncheckedCreateWithoutProjectInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type CostTrackingCreateOrConnectWithoutProjectInput = {
    where: CostTrackingWhereUniqueInput
    create: XOR<CostTrackingCreateWithoutProjectInput, CostTrackingUncheckedCreateWithoutProjectInput>
  }

  export type CostTrackingCreateManyProjectInputEnvelope = {
    data: CostTrackingCreateManyProjectInput | CostTrackingCreateManyProjectInput[]
  }

  export type AppIntegrationCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
    syncOperations?: SyncOperationCreateNestedManyWithoutConnectionInput
  }

  export type AppIntegrationUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type AppIntegrationCreateOrConnectWithoutProjectInput = {
    where: AppIntegrationWhereUniqueInput
    create: XOR<AppIntegrationCreateWithoutProjectInput, AppIntegrationUncheckedCreateWithoutProjectInput>
  }

  export type AppIntegrationCreateManyProjectInputEnvelope = {
    data: AppIntegrationCreateManyProjectInput | AppIntegrationCreateManyProjectInput[]
  }

  export type TestPipelineCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedPipelinesInput
    stages?: PipelineStageCreateNestedManyWithoutPipelineInput
    executions?: PipelineExecutionCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    stages?: PipelineStageUncheckedCreateNestedManyWithoutPipelineInput
    executions?: PipelineExecutionUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineCreateOrConnectWithoutProjectInput = {
    where: TestPipelineWhereUniqueInput
    create: XOR<TestPipelineCreateWithoutProjectInput, TestPipelineUncheckedCreateWithoutProjectInput>
  }

  export type TestPipelineCreateManyProjectInputEnvelope = {
    data: TestPipelineCreateManyProjectInput | TestPipelineCreateManyProjectInput[]
  }

  export type DependencyCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedDependenciesInput
  }

  export type DependencyUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type DependencyCreateOrConnectWithoutProjectInput = {
    where: DependencyWhereUniqueInput
    create: XOR<DependencyCreateWithoutProjectInput, DependencyUncheckedCreateWithoutProjectInput>
  }

  export type DependencyCreateManyProjectInputEnvelope = {
    data: DependencyCreateManyProjectInput | DependencyCreateManyProjectInput[]
  }

  export type UpdatePlanCreateWithoutProjectInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedUpdatePlansInput
    executor?: UserCreateNestedOneWithoutExecutedUpdatePlansInput
  }

  export type UpdatePlanUncheckedCreateWithoutProjectInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    executedBy?: string | null
  }

  export type UpdatePlanCreateOrConnectWithoutProjectInput = {
    where: UpdatePlanWhereUniqueInput
    create: XOR<UpdatePlanCreateWithoutProjectInput, UpdatePlanUncheckedCreateWithoutProjectInput>
  }

  export type UpdatePlanCreateManyProjectInputEnvelope = {
    data: UpdatePlanCreateManyProjectInput | UpdatePlanCreateManyProjectInput[]
  }

  export type DeploymentPlanCreateWithoutProjectInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutDeploymentPlansInput
    creator: UserCreateNestedOneWithoutCreatedDeploymentPlansInput
    executions?: DeploymentExecutionCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUncheckedCreateWithoutProjectInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    createdBy: string
    executions?: DeploymentExecutionUncheckedCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalUncheckedCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanCreateOrConnectWithoutProjectInput = {
    where: DeploymentPlanWhereUniqueInput
    create: XOR<DeploymentPlanCreateWithoutProjectInput, DeploymentPlanUncheckedCreateWithoutProjectInput>
  }

  export type DeploymentPlanCreateManyProjectInputEnvelope = {
    data: DeploymentPlanCreateManyProjectInput | DeploymentPlanCreateManyProjectInput[]
  }

  export type ApprovalRequestCreateWithoutProjectInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appId: string
    prompt: PromptCreateNestedOneWithoutApprovalRequestsInput
    requester: UserCreateNestedOneWithoutRequestedApprovalsInput
    impactAnalysis?: ImpactAnalysisCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalRequestUncheckedCreateWithoutProjectInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    appId: string
    requestedBy: string
    impactAnalysisId?: string | null
  }

  export type ApprovalRequestCreateOrConnectWithoutProjectInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutProjectInput, ApprovalRequestUncheckedCreateWithoutProjectInput>
  }

  export type ApprovalRequestCreateManyProjectInputEnvelope = {
    data: ApprovalRequestCreateManyProjectInput | ApprovalRequestCreateManyProjectInput[]
  }

  export type SyncOperationCreateWithoutProjectInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    connection: AppIntegrationCreateNestedOneWithoutSyncOperationsInput
    initiator: UserCreateNestedOneWithoutInitiatedSyncsInput
  }

  export type SyncOperationUncheckedCreateWithoutProjectInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    connectionId: string
    initiatedBy: string
  }

  export type SyncOperationCreateOrConnectWithoutProjectInput = {
    where: SyncOperationWhereUniqueInput
    create: XOR<SyncOperationCreateWithoutProjectInput, SyncOperationUncheckedCreateWithoutProjectInput>
  }

  export type SyncOperationCreateManyProjectInputEnvelope = {
    data: SyncOperationCreateManyProjectInput | SyncOperationCreateManyProjectInput[]
  }

  export type WebhookDeliveryCreateWithoutProjectInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    webhook?: WebhookSubscriptionCreateNestedOneWithoutDeliveriesInput
    failedWebhook?: WebhookSubscriptionCreateNestedOneWithoutFailedDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateWithoutProjectInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    webhookId?: string | null
    failedWebhookId?: string | null
  }

  export type WebhookDeliveryCreateOrConnectWithoutProjectInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutProjectInput, WebhookDeliveryUncheckedCreateWithoutProjectInput>
  }

  export type WebhookDeliveryCreateManyProjectInputEnvelope = {
    data: WebhookDeliveryCreateManyProjectInput | WebhookDeliveryCreateManyProjectInput[]
  }

  export type WebhookSubscriptionCreateWithoutProjectInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
    failedDeliveries?: WebhookDeliveryCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionUncheckedCreateWithoutProjectInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
    failedDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionCreateOrConnectWithoutProjectInput = {
    where: WebhookSubscriptionWhereUniqueInput
    create: XOR<WebhookSubscriptionCreateWithoutProjectInput, WebhookSubscriptionUncheckedCreateWithoutProjectInput>
  }

  export type WebhookSubscriptionCreateManyProjectInputEnvelope = {
    data: WebhookSubscriptionCreateManyProjectInput | WebhookSubscriptionCreateManyProjectInput[]
  }

  export type UserUpsertWithoutOwnedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type UserUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type PromptUpsertWithWhereUniqueWithoutProjectInput = {
    where: PromptWhereUniqueInput
    update: XOR<PromptUpdateWithoutProjectInput, PromptUncheckedUpdateWithoutProjectInput>
    create: XOR<PromptCreateWithoutProjectInput, PromptUncheckedCreateWithoutProjectInput>
  }

  export type PromptUpdateWithWhereUniqueWithoutProjectInput = {
    where: PromptWhereUniqueInput
    data: XOR<PromptUpdateWithoutProjectInput, PromptUncheckedUpdateWithoutProjectInput>
  }

  export type PromptUpdateManyWithWhereWithoutProjectInput = {
    where: PromptScalarWhereInput
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyWithoutProjectInput>
  }

  export type PromptScalarWhereInput = {
    AND?: PromptScalarWhereInput | PromptScalarWhereInput[]
    OR?: PromptScalarWhereInput[]
    NOT?: PromptScalarWhereInput | PromptScalarWhereInput[]
    id?: StringFilter<"Prompt"> | string
    name?: StringFilter<"Prompt"> | string
    description?: StringNullableFilter<"Prompt"> | string | null
    content?: StringFilter<"Prompt"> | string
    version?: IntFilter<"Prompt"> | number
    isArchived?: BoolFilter<"Prompt"> | boolean
    tags?: StringFilter<"Prompt"> | string
    metadata?: StringNullableFilter<"Prompt"> | string | null
    outputSchema?: StringNullableFilter<"Prompt"> | string | null
    outputFormat?: StringNullableFilter<"Prompt"> | string | null
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    projectId?: StringFilter<"Prompt"> | string
    parentId?: StringNullableFilter<"Prompt"> | string | null
  }

  export type TestRunUpsertWithWhereUniqueWithoutProjectInput = {
    where: TestRunWhereUniqueInput
    update: XOR<TestRunUpdateWithoutProjectInput, TestRunUncheckedUpdateWithoutProjectInput>
    create: XOR<TestRunCreateWithoutProjectInput, TestRunUncheckedCreateWithoutProjectInput>
  }

  export type TestRunUpdateWithWhereUniqueWithoutProjectInput = {
    where: TestRunWhereUniqueInput
    data: XOR<TestRunUpdateWithoutProjectInput, TestRunUncheckedUpdateWithoutProjectInput>
  }

  export type TestRunUpdateManyWithWhereWithoutProjectInput = {
    where: TestRunScalarWhereInput
    data: XOR<TestRunUpdateManyMutationInput, TestRunUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutProjectInput, ApiKeyUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiKeyCreateWithoutProjectInput, ApiKeyUncheckedCreateWithoutProjectInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutProjectInput, ApiKeyUncheckedUpdateWithoutProjectInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutProjectInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    provider?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    isActive?: BoolFilter<"ApiKey"> | boolean
    lastUsed?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    projectId?: StringFilter<"ApiKey"> | string
  }

  export type EnvironmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: EnvironmentWhereUniqueInput
    update: XOR<EnvironmentUpdateWithoutProjectInput, EnvironmentUncheckedUpdateWithoutProjectInput>
    create: XOR<EnvironmentCreateWithoutProjectInput, EnvironmentUncheckedCreateWithoutProjectInput>
  }

  export type EnvironmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: EnvironmentWhereUniqueInput
    data: XOR<EnvironmentUpdateWithoutProjectInput, EnvironmentUncheckedUpdateWithoutProjectInput>
  }

  export type EnvironmentUpdateManyWithWhereWithoutProjectInput = {
    where: EnvironmentScalarWhereInput
    data: XOR<EnvironmentUpdateManyMutationInput, EnvironmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type EnvironmentScalarWhereInput = {
    AND?: EnvironmentScalarWhereInput | EnvironmentScalarWhereInput[]
    OR?: EnvironmentScalarWhereInput[]
    NOT?: EnvironmentScalarWhereInput | EnvironmentScalarWhereInput[]
    id?: StringFilter<"Environment"> | string
    name?: StringFilter<"Environment"> | string
    type?: StringFilter<"Environment"> | string
    description?: StringNullableFilter<"Environment"> | string | null
    config?: StringNullableFilter<"Environment"> | string | null
    isActive?: BoolFilter<"Environment"> | boolean
    createdAt?: DateTimeFilter<"Environment"> | Date | string
    updatedAt?: DateTimeFilter<"Environment"> | Date | string
    projectId?: StringFilter<"Environment"> | string
  }

  export type CostTrackingUpsertWithWhereUniqueWithoutProjectInput = {
    where: CostTrackingWhereUniqueInput
    update: XOR<CostTrackingUpdateWithoutProjectInput, CostTrackingUncheckedUpdateWithoutProjectInput>
    create: XOR<CostTrackingCreateWithoutProjectInput, CostTrackingUncheckedCreateWithoutProjectInput>
  }

  export type CostTrackingUpdateWithWhereUniqueWithoutProjectInput = {
    where: CostTrackingWhereUniqueInput
    data: XOR<CostTrackingUpdateWithoutProjectInput, CostTrackingUncheckedUpdateWithoutProjectInput>
  }

  export type CostTrackingUpdateManyWithWhereWithoutProjectInput = {
    where: CostTrackingScalarWhereInput
    data: XOR<CostTrackingUpdateManyMutationInput, CostTrackingUncheckedUpdateManyWithoutProjectInput>
  }

  export type AppIntegrationUpsertWithWhereUniqueWithoutProjectInput = {
    where: AppIntegrationWhereUniqueInput
    update: XOR<AppIntegrationUpdateWithoutProjectInput, AppIntegrationUncheckedUpdateWithoutProjectInput>
    create: XOR<AppIntegrationCreateWithoutProjectInput, AppIntegrationUncheckedCreateWithoutProjectInput>
  }

  export type AppIntegrationUpdateWithWhereUniqueWithoutProjectInput = {
    where: AppIntegrationWhereUniqueInput
    data: XOR<AppIntegrationUpdateWithoutProjectInput, AppIntegrationUncheckedUpdateWithoutProjectInput>
  }

  export type AppIntegrationUpdateManyWithWhereWithoutProjectInput = {
    where: AppIntegrationScalarWhereInput
    data: XOR<AppIntegrationUpdateManyMutationInput, AppIntegrationUncheckedUpdateManyWithoutProjectInput>
  }

  export type TestPipelineUpsertWithWhereUniqueWithoutProjectInput = {
    where: TestPipelineWhereUniqueInput
    update: XOR<TestPipelineUpdateWithoutProjectInput, TestPipelineUncheckedUpdateWithoutProjectInput>
    create: XOR<TestPipelineCreateWithoutProjectInput, TestPipelineUncheckedCreateWithoutProjectInput>
  }

  export type TestPipelineUpdateWithWhereUniqueWithoutProjectInput = {
    where: TestPipelineWhereUniqueInput
    data: XOR<TestPipelineUpdateWithoutProjectInput, TestPipelineUncheckedUpdateWithoutProjectInput>
  }

  export type TestPipelineUpdateManyWithWhereWithoutProjectInput = {
    where: TestPipelineScalarWhereInput
    data: XOR<TestPipelineUpdateManyMutationInput, TestPipelineUncheckedUpdateManyWithoutProjectInput>
  }

  export type DependencyUpsertWithWhereUniqueWithoutProjectInput = {
    where: DependencyWhereUniqueInput
    update: XOR<DependencyUpdateWithoutProjectInput, DependencyUncheckedUpdateWithoutProjectInput>
    create: XOR<DependencyCreateWithoutProjectInput, DependencyUncheckedCreateWithoutProjectInput>
  }

  export type DependencyUpdateWithWhereUniqueWithoutProjectInput = {
    where: DependencyWhereUniqueInput
    data: XOR<DependencyUpdateWithoutProjectInput, DependencyUncheckedUpdateWithoutProjectInput>
  }

  export type DependencyUpdateManyWithWhereWithoutProjectInput = {
    where: DependencyScalarWhereInput
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyWithoutProjectInput>
  }

  export type UpdatePlanUpsertWithWhereUniqueWithoutProjectInput = {
    where: UpdatePlanWhereUniqueInput
    update: XOR<UpdatePlanUpdateWithoutProjectInput, UpdatePlanUncheckedUpdateWithoutProjectInput>
    create: XOR<UpdatePlanCreateWithoutProjectInput, UpdatePlanUncheckedCreateWithoutProjectInput>
  }

  export type UpdatePlanUpdateWithWhereUniqueWithoutProjectInput = {
    where: UpdatePlanWhereUniqueInput
    data: XOR<UpdatePlanUpdateWithoutProjectInput, UpdatePlanUncheckedUpdateWithoutProjectInput>
  }

  export type UpdatePlanUpdateManyWithWhereWithoutProjectInput = {
    where: UpdatePlanScalarWhereInput
    data: XOR<UpdatePlanUpdateManyMutationInput, UpdatePlanUncheckedUpdateManyWithoutProjectInput>
  }

  export type DeploymentPlanUpsertWithWhereUniqueWithoutProjectInput = {
    where: DeploymentPlanWhereUniqueInput
    update: XOR<DeploymentPlanUpdateWithoutProjectInput, DeploymentPlanUncheckedUpdateWithoutProjectInput>
    create: XOR<DeploymentPlanCreateWithoutProjectInput, DeploymentPlanUncheckedCreateWithoutProjectInput>
  }

  export type DeploymentPlanUpdateWithWhereUniqueWithoutProjectInput = {
    where: DeploymentPlanWhereUniqueInput
    data: XOR<DeploymentPlanUpdateWithoutProjectInput, DeploymentPlanUncheckedUpdateWithoutProjectInput>
  }

  export type DeploymentPlanUpdateManyWithWhereWithoutProjectInput = {
    where: DeploymentPlanScalarWhereInput
    data: XOR<DeploymentPlanUpdateManyMutationInput, DeploymentPlanUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutProjectInput, ApprovalRequestUncheckedUpdateWithoutProjectInput>
    create: XOR<ApprovalRequestCreateWithoutProjectInput, ApprovalRequestUncheckedCreateWithoutProjectInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutProjectInput, ApprovalRequestUncheckedUpdateWithoutProjectInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutProjectInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutProjectInput>
  }

  export type SyncOperationUpsertWithWhereUniqueWithoutProjectInput = {
    where: SyncOperationWhereUniqueInput
    update: XOR<SyncOperationUpdateWithoutProjectInput, SyncOperationUncheckedUpdateWithoutProjectInput>
    create: XOR<SyncOperationCreateWithoutProjectInput, SyncOperationUncheckedCreateWithoutProjectInput>
  }

  export type SyncOperationUpdateWithWhereUniqueWithoutProjectInput = {
    where: SyncOperationWhereUniqueInput
    data: XOR<SyncOperationUpdateWithoutProjectInput, SyncOperationUncheckedUpdateWithoutProjectInput>
  }

  export type SyncOperationUpdateManyWithWhereWithoutProjectInput = {
    where: SyncOperationScalarWhereInput
    data: XOR<SyncOperationUpdateManyMutationInput, SyncOperationUncheckedUpdateManyWithoutProjectInput>
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutProjectInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutProjectInput, WebhookDeliveryUncheckedUpdateWithoutProjectInput>
    create: XOR<WebhookDeliveryCreateWithoutProjectInput, WebhookDeliveryUncheckedCreateWithoutProjectInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutProjectInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutProjectInput, WebhookDeliveryUncheckedUpdateWithoutProjectInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutProjectInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutProjectInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    url?: StringFilter<"WebhookDelivery"> | string
    payload?: StringFilter<"WebhookDelivery"> | string
    headers?: StringNullableFilter<"WebhookDelivery"> | string | null
    status?: StringFilter<"WebhookDelivery"> | string
    attempts?: IntFilter<"WebhookDelivery"> | number
    maxAttempts?: IntFilter<"WebhookDelivery"> | number
    response?: StringNullableFilter<"WebhookDelivery"> | string | null
    error?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    createdAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    eventType?: StringFilter<"WebhookDelivery"> | string
    projectId?: StringNullableFilter<"WebhookDelivery"> | string | null
    webhookId?: StringNullableFilter<"WebhookDelivery"> | string | null
    failedWebhookId?: StringNullableFilter<"WebhookDelivery"> | string | null
  }

  export type WebhookSubscriptionUpsertWithWhereUniqueWithoutProjectInput = {
    where: WebhookSubscriptionWhereUniqueInput
    update: XOR<WebhookSubscriptionUpdateWithoutProjectInput, WebhookSubscriptionUncheckedUpdateWithoutProjectInput>
    create: XOR<WebhookSubscriptionCreateWithoutProjectInput, WebhookSubscriptionUncheckedCreateWithoutProjectInput>
  }

  export type WebhookSubscriptionUpdateWithWhereUniqueWithoutProjectInput = {
    where: WebhookSubscriptionWhereUniqueInput
    data: XOR<WebhookSubscriptionUpdateWithoutProjectInput, WebhookSubscriptionUncheckedUpdateWithoutProjectInput>
  }

  export type WebhookSubscriptionUpdateManyWithWhereWithoutProjectInput = {
    where: WebhookSubscriptionScalarWhereInput
    data: XOR<WebhookSubscriptionUpdateManyMutationInput, WebhookSubscriptionUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProjectMembershipsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProjectMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembershipsInput = {
    update: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type UserUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutPromptsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPromptsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPromptsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPromptsInput, ProjectUncheckedCreateWithoutPromptsInput>
  }

  export type PromptCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutVersionsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutVersionsInput, PromptUncheckedCreateWithoutVersionsInput>
  }

  export type PromptCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutParentInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutParentInput, PromptUncheckedCreateWithoutParentInput>
  }

  export type PromptCreateManyParentInputEnvelope = {
    data: PromptCreateManyParentInput | PromptCreateManyParentInput[]
  }

  export type TestRunCreateWithoutPromptInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestRunsInput
    user: UserCreateNestedOneWithoutTestRunsInput
    responses?: TestResponseCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUncheckedCreateWithoutPromptInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    responses?: TestResponseUncheckedCreateNestedManyWithoutTestRunInput
    metrics?: TestMetricUncheckedCreateNestedManyWithoutTestRunInput
  }

  export type TestRunCreateOrConnectWithoutPromptInput = {
    where: TestRunWhereUniqueInput
    create: XOR<TestRunCreateWithoutPromptInput, TestRunUncheckedCreateWithoutPromptInput>
  }

  export type TestRunCreateManyPromptInputEnvelope = {
    data: TestRunCreateManyPromptInput | TestRunCreateManyPromptInput[]
  }

  export type DeploymentCreateWithoutPromptInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
    deployedByUser: UserCreateNestedOneWithoutDeploymentsInput
    history?: DeploymentHistoryCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateWithoutPromptInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    environmentId: string
    deployedBy: string
    history?: DeploymentHistoryUncheckedCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentCreateOrConnectWithoutPromptInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutPromptInput, DeploymentUncheckedCreateWithoutPromptInput>
  }

  export type DeploymentCreateManyPromptInputEnvelope = {
    data: DeploymentCreateManyPromptInput | DeploymentCreateManyPromptInput[]
  }

  export type ImpactAnalysisCreateWithoutBaselinePromptInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deployment: DeploymentCreateNestedOneWithoutImpactAnalysisInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deploymentId: string
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisCreateOrConnectWithoutBaselinePromptInput = {
    where: ImpactAnalysisWhereUniqueInput
    create: XOR<ImpactAnalysisCreateWithoutBaselinePromptInput, ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput>
  }

  export type ImpactAnalysisCreateManyBaselinePromptInputEnvelope = {
    data: ImpactAnalysisCreateManyBaselinePromptInput | ImpactAnalysisCreateManyBaselinePromptInput[]
  }

  export type PipelineExecutionCreateWithoutPromptInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: TestPipelineCreateNestedOneWithoutExecutionsInput
    baselinePrompt?: PromptCreateNestedOneWithoutBaselinePipelineExecutionsInput
    executor: UserCreateNestedOneWithoutExecutedPipelinesInput
  }

  export type PipelineExecutionUncheckedCreateWithoutPromptInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    baselinePromptId?: string | null
    executedBy: string
  }

  export type PipelineExecutionCreateOrConnectWithoutPromptInput = {
    where: PipelineExecutionWhereUniqueInput
    create: XOR<PipelineExecutionCreateWithoutPromptInput, PipelineExecutionUncheckedCreateWithoutPromptInput>
  }

  export type PipelineExecutionCreateManyPromptInputEnvelope = {
    data: PipelineExecutionCreateManyPromptInput | PipelineExecutionCreateManyPromptInput[]
  }

  export type PipelineExecutionCreateWithoutBaselinePromptInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: TestPipelineCreateNestedOneWithoutExecutionsInput
    prompt: PromptCreateNestedOneWithoutPipelineExecutionsInput
    executor: UserCreateNestedOneWithoutExecutedPipelinesInput
  }

  export type PipelineExecutionUncheckedCreateWithoutBaselinePromptInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    promptId: string
    executedBy: string
  }

  export type PipelineExecutionCreateOrConnectWithoutBaselinePromptInput = {
    where: PipelineExecutionWhereUniqueInput
    create: XOR<PipelineExecutionCreateWithoutBaselinePromptInput, PipelineExecutionUncheckedCreateWithoutBaselinePromptInput>
  }

  export type PipelineExecutionCreateManyBaselinePromptInputEnvelope = {
    data: PipelineExecutionCreateManyBaselinePromptInput | PipelineExecutionCreateManyBaselinePromptInput[]
  }

  export type DeploymentPlanCreateWithoutPromptInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeploymentPlansInput
    creator: UserCreateNestedOneWithoutCreatedDeploymentPlansInput
    executions?: DeploymentExecutionCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUncheckedCreateWithoutPromptInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    executions?: DeploymentExecutionUncheckedCreateNestedManyWithoutPlanInput
    approvals?: DeploymentApprovalUncheckedCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanCreateOrConnectWithoutPromptInput = {
    where: DeploymentPlanWhereUniqueInput
    create: XOR<DeploymentPlanCreateWithoutPromptInput, DeploymentPlanUncheckedCreateWithoutPromptInput>
  }

  export type DeploymentPlanCreateManyPromptInputEnvelope = {
    data: DeploymentPlanCreateManyPromptInput | DeploymentPlanCreateManyPromptInput[]
  }

  export type ApprovalRequestCreateWithoutPromptInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appId: string
    project: ProjectCreateNestedOneWithoutApprovalRequestsInput
    requester: UserCreateNestedOneWithoutRequestedApprovalsInput
    impactAnalysis?: ImpactAnalysisCreateNestedOneWithoutApprovalRequestsInput
  }

  export type ApprovalRequestUncheckedCreateWithoutPromptInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    appId: string
    requestedBy: string
    impactAnalysisId?: string | null
  }

  export type ApprovalRequestCreateOrConnectWithoutPromptInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutPromptInput, ApprovalRequestUncheckedCreateWithoutPromptInput>
  }

  export type ApprovalRequestCreateManyPromptInputEnvelope = {
    data: ApprovalRequestCreateManyPromptInput | ApprovalRequestCreateManyPromptInput[]
  }

  export type ProjectUpsertWithoutPromptsInput = {
    update: XOR<ProjectUpdateWithoutPromptsInput, ProjectUncheckedUpdateWithoutPromptsInput>
    create: XOR<ProjectCreateWithoutPromptsInput, ProjectUncheckedCreateWithoutPromptsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPromptsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPromptsInput, ProjectUncheckedUpdateWithoutPromptsInput>
  }

  export type ProjectUpdateWithoutPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPromptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PromptUpsertWithoutVersionsInput = {
    update: XOR<PromptUpdateWithoutVersionsInput, PromptUncheckedUpdateWithoutVersionsInput>
    create: XOR<PromptCreateWithoutVersionsInput, PromptUncheckedCreateWithoutVersionsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutVersionsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutVersionsInput, PromptUncheckedUpdateWithoutVersionsInput>
  }

  export type PromptUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUpsertWithWhereUniqueWithoutParentInput = {
    where: PromptWhereUniqueInput
    update: XOR<PromptUpdateWithoutParentInput, PromptUncheckedUpdateWithoutParentInput>
    create: XOR<PromptCreateWithoutParentInput, PromptUncheckedCreateWithoutParentInput>
  }

  export type PromptUpdateWithWhereUniqueWithoutParentInput = {
    where: PromptWhereUniqueInput
    data: XOR<PromptUpdateWithoutParentInput, PromptUncheckedUpdateWithoutParentInput>
  }

  export type PromptUpdateManyWithWhereWithoutParentInput = {
    where: PromptScalarWhereInput
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyWithoutParentInput>
  }

  export type TestRunUpsertWithWhereUniqueWithoutPromptInput = {
    where: TestRunWhereUniqueInput
    update: XOR<TestRunUpdateWithoutPromptInput, TestRunUncheckedUpdateWithoutPromptInput>
    create: XOR<TestRunCreateWithoutPromptInput, TestRunUncheckedCreateWithoutPromptInput>
  }

  export type TestRunUpdateWithWhereUniqueWithoutPromptInput = {
    where: TestRunWhereUniqueInput
    data: XOR<TestRunUpdateWithoutPromptInput, TestRunUncheckedUpdateWithoutPromptInput>
  }

  export type TestRunUpdateManyWithWhereWithoutPromptInput = {
    where: TestRunScalarWhereInput
    data: XOR<TestRunUpdateManyMutationInput, TestRunUncheckedUpdateManyWithoutPromptInput>
  }

  export type DeploymentUpsertWithWhereUniqueWithoutPromptInput = {
    where: DeploymentWhereUniqueInput
    update: XOR<DeploymentUpdateWithoutPromptInput, DeploymentUncheckedUpdateWithoutPromptInput>
    create: XOR<DeploymentCreateWithoutPromptInput, DeploymentUncheckedCreateWithoutPromptInput>
  }

  export type DeploymentUpdateWithWhereUniqueWithoutPromptInput = {
    where: DeploymentWhereUniqueInput
    data: XOR<DeploymentUpdateWithoutPromptInput, DeploymentUncheckedUpdateWithoutPromptInput>
  }

  export type DeploymentUpdateManyWithWhereWithoutPromptInput = {
    where: DeploymentScalarWhereInput
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutPromptInput>
  }

  export type ImpactAnalysisUpsertWithWhereUniqueWithoutBaselinePromptInput = {
    where: ImpactAnalysisWhereUniqueInput
    update: XOR<ImpactAnalysisUpdateWithoutBaselinePromptInput, ImpactAnalysisUncheckedUpdateWithoutBaselinePromptInput>
    create: XOR<ImpactAnalysisCreateWithoutBaselinePromptInput, ImpactAnalysisUncheckedCreateWithoutBaselinePromptInput>
  }

  export type ImpactAnalysisUpdateWithWhereUniqueWithoutBaselinePromptInput = {
    where: ImpactAnalysisWhereUniqueInput
    data: XOR<ImpactAnalysisUpdateWithoutBaselinePromptInput, ImpactAnalysisUncheckedUpdateWithoutBaselinePromptInput>
  }

  export type ImpactAnalysisUpdateManyWithWhereWithoutBaselinePromptInput = {
    where: ImpactAnalysisScalarWhereInput
    data: XOR<ImpactAnalysisUpdateManyMutationInput, ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptInput>
  }

  export type ImpactAnalysisScalarWhereInput = {
    AND?: ImpactAnalysisScalarWhereInput | ImpactAnalysisScalarWhereInput[]
    OR?: ImpactAnalysisScalarWhereInput[]
    NOT?: ImpactAnalysisScalarWhereInput | ImpactAnalysisScalarWhereInput[]
    id?: StringFilter<"ImpactAnalysis"> | string
    impactPercentage?: FloatFilter<"ImpactAnalysis"> | number
    diffAnalysis?: StringFilter<"ImpactAnalysis"> | string
    sampleComparisons?: StringFilter<"ImpactAnalysis"> | string
    createdAt?: DateTimeFilter<"ImpactAnalysis"> | Date | string
    deploymentId?: StringFilter<"ImpactAnalysis"> | string
    baselinePromptId?: StringNullableFilter<"ImpactAnalysis"> | string | null
  }

  export type PipelineExecutionUpsertWithWhereUniqueWithoutPromptInput = {
    where: PipelineExecutionWhereUniqueInput
    update: XOR<PipelineExecutionUpdateWithoutPromptInput, PipelineExecutionUncheckedUpdateWithoutPromptInput>
    create: XOR<PipelineExecutionCreateWithoutPromptInput, PipelineExecutionUncheckedCreateWithoutPromptInput>
  }

  export type PipelineExecutionUpdateWithWhereUniqueWithoutPromptInput = {
    where: PipelineExecutionWhereUniqueInput
    data: XOR<PipelineExecutionUpdateWithoutPromptInput, PipelineExecutionUncheckedUpdateWithoutPromptInput>
  }

  export type PipelineExecutionUpdateManyWithWhereWithoutPromptInput = {
    where: PipelineExecutionScalarWhereInput
    data: XOR<PipelineExecutionUpdateManyMutationInput, PipelineExecutionUncheckedUpdateManyWithoutPromptInput>
  }

  export type PipelineExecutionUpsertWithWhereUniqueWithoutBaselinePromptInput = {
    where: PipelineExecutionWhereUniqueInput
    update: XOR<PipelineExecutionUpdateWithoutBaselinePromptInput, PipelineExecutionUncheckedUpdateWithoutBaselinePromptInput>
    create: XOR<PipelineExecutionCreateWithoutBaselinePromptInput, PipelineExecutionUncheckedCreateWithoutBaselinePromptInput>
  }

  export type PipelineExecutionUpdateWithWhereUniqueWithoutBaselinePromptInput = {
    where: PipelineExecutionWhereUniqueInput
    data: XOR<PipelineExecutionUpdateWithoutBaselinePromptInput, PipelineExecutionUncheckedUpdateWithoutBaselinePromptInput>
  }

  export type PipelineExecutionUpdateManyWithWhereWithoutBaselinePromptInput = {
    where: PipelineExecutionScalarWhereInput
    data: XOR<PipelineExecutionUpdateManyMutationInput, PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptInput>
  }

  export type DeploymentPlanUpsertWithWhereUniqueWithoutPromptInput = {
    where: DeploymentPlanWhereUniqueInput
    update: XOR<DeploymentPlanUpdateWithoutPromptInput, DeploymentPlanUncheckedUpdateWithoutPromptInput>
    create: XOR<DeploymentPlanCreateWithoutPromptInput, DeploymentPlanUncheckedCreateWithoutPromptInput>
  }

  export type DeploymentPlanUpdateWithWhereUniqueWithoutPromptInput = {
    where: DeploymentPlanWhereUniqueInput
    data: XOR<DeploymentPlanUpdateWithoutPromptInput, DeploymentPlanUncheckedUpdateWithoutPromptInput>
  }

  export type DeploymentPlanUpdateManyWithWhereWithoutPromptInput = {
    where: DeploymentPlanScalarWhereInput
    data: XOR<DeploymentPlanUpdateManyMutationInput, DeploymentPlanUncheckedUpdateManyWithoutPromptInput>
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutPromptInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutPromptInput, ApprovalRequestUncheckedUpdateWithoutPromptInput>
    create: XOR<ApprovalRequestCreateWithoutPromptInput, ApprovalRequestUncheckedCreateWithoutPromptInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutPromptInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutPromptInput, ApprovalRequestUncheckedUpdateWithoutPromptInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutPromptInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutPromptInput>
  }

  export type ProjectCreateWithoutTestRunsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTestRunsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTestRunsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTestRunsInput, ProjectUncheckedCreateWithoutTestRunsInput>
  }

  export type UserCreateWithoutTestRunsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTestRunsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTestRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestRunsInput, UserUncheckedCreateWithoutTestRunsInput>
  }

  export type PromptCreateWithoutTestRunsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutTestRunsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutTestRunsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutTestRunsInput, PromptUncheckedCreateWithoutTestRunsInput>
  }

  export type TestResponseCreateWithoutTestRunInput = {
    id?: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput?: string | null
    outputStructure?: string | null
    tokenUsage?: string | null
    latencyMs?: number | null
    cost?: number | null
    error?: string | null
    rawResponse?: string | null
    evaluationData?: string | null
    createdAt?: Date | string
  }

  export type TestResponseUncheckedCreateWithoutTestRunInput = {
    id?: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput?: string | null
    outputStructure?: string | null
    tokenUsage?: string | null
    latencyMs?: number | null
    cost?: number | null
    error?: string | null
    rawResponse?: string | null
    evaluationData?: string | null
    createdAt?: Date | string
  }

  export type TestResponseCreateOrConnectWithoutTestRunInput = {
    where: TestResponseWhereUniqueInput
    create: XOR<TestResponseCreateWithoutTestRunInput, TestResponseUncheckedCreateWithoutTestRunInput>
  }

  export type TestResponseCreateManyTestRunInputEnvelope = {
    data: TestResponseCreateManyTestRunInput | TestResponseCreateManyTestRunInput[]
  }

  export type TestMetricCreateWithoutTestRunInput = {
    id?: string
    name: string
    value: number
    unit?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type TestMetricUncheckedCreateWithoutTestRunInput = {
    id?: string
    name: string
    value: number
    unit?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type TestMetricCreateOrConnectWithoutTestRunInput = {
    where: TestMetricWhereUniqueInput
    create: XOR<TestMetricCreateWithoutTestRunInput, TestMetricUncheckedCreateWithoutTestRunInput>
  }

  export type TestMetricCreateManyTestRunInputEnvelope = {
    data: TestMetricCreateManyTestRunInput | TestMetricCreateManyTestRunInput[]
  }

  export type ProjectUpsertWithoutTestRunsInput = {
    update: XOR<ProjectUpdateWithoutTestRunsInput, ProjectUncheckedUpdateWithoutTestRunsInput>
    create: XOR<ProjectCreateWithoutTestRunsInput, ProjectUncheckedCreateWithoutTestRunsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTestRunsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTestRunsInput, ProjectUncheckedUpdateWithoutTestRunsInput>
  }

  export type ProjectUpdateWithoutTestRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTestRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutTestRunsInput = {
    update: XOR<UserUpdateWithoutTestRunsInput, UserUncheckedUpdateWithoutTestRunsInput>
    create: XOR<UserCreateWithoutTestRunsInput, UserUncheckedCreateWithoutTestRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestRunsInput, UserUncheckedUpdateWithoutTestRunsInput>
  }

  export type UserUpdateWithoutTestRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTestRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PromptUpsertWithoutTestRunsInput = {
    update: XOR<PromptUpdateWithoutTestRunsInput, PromptUncheckedUpdateWithoutTestRunsInput>
    create: XOR<PromptCreateWithoutTestRunsInput, PromptUncheckedCreateWithoutTestRunsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutTestRunsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutTestRunsInput, PromptUncheckedUpdateWithoutTestRunsInput>
  }

  export type PromptUpdateWithoutTestRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutTestRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type TestResponseUpsertWithWhereUniqueWithoutTestRunInput = {
    where: TestResponseWhereUniqueInput
    update: XOR<TestResponseUpdateWithoutTestRunInput, TestResponseUncheckedUpdateWithoutTestRunInput>
    create: XOR<TestResponseCreateWithoutTestRunInput, TestResponseUncheckedCreateWithoutTestRunInput>
  }

  export type TestResponseUpdateWithWhereUniqueWithoutTestRunInput = {
    where: TestResponseWhereUniqueInput
    data: XOR<TestResponseUpdateWithoutTestRunInput, TestResponseUncheckedUpdateWithoutTestRunInput>
  }

  export type TestResponseUpdateManyWithWhereWithoutTestRunInput = {
    where: TestResponseScalarWhereInput
    data: XOR<TestResponseUpdateManyMutationInput, TestResponseUncheckedUpdateManyWithoutTestRunInput>
  }

  export type TestResponseScalarWhereInput = {
    AND?: TestResponseScalarWhereInput | TestResponseScalarWhereInput[]
    OR?: TestResponseScalarWhereInput[]
    NOT?: TestResponseScalarWhereInput | TestResponseScalarWhereInput[]
    id?: StringFilter<"TestResponse"> | string
    modelProvider?: StringFilter<"TestResponse"> | string
    modelName?: StringFilter<"TestResponse"> | string
    input?: StringFilter<"TestResponse"> | string
    output?: StringFilter<"TestResponse"> | string
    parsedOutput?: StringNullableFilter<"TestResponse"> | string | null
    outputStructure?: StringNullableFilter<"TestResponse"> | string | null
    tokenUsage?: StringNullableFilter<"TestResponse"> | string | null
    latencyMs?: IntNullableFilter<"TestResponse"> | number | null
    cost?: FloatNullableFilter<"TestResponse"> | number | null
    error?: StringNullableFilter<"TestResponse"> | string | null
    rawResponse?: StringNullableFilter<"TestResponse"> | string | null
    evaluationData?: StringNullableFilter<"TestResponse"> | string | null
    createdAt?: DateTimeFilter<"TestResponse"> | Date | string
    testRunId?: StringFilter<"TestResponse"> | string
  }

  export type TestMetricUpsertWithWhereUniqueWithoutTestRunInput = {
    where: TestMetricWhereUniqueInput
    update: XOR<TestMetricUpdateWithoutTestRunInput, TestMetricUncheckedUpdateWithoutTestRunInput>
    create: XOR<TestMetricCreateWithoutTestRunInput, TestMetricUncheckedCreateWithoutTestRunInput>
  }

  export type TestMetricUpdateWithWhereUniqueWithoutTestRunInput = {
    where: TestMetricWhereUniqueInput
    data: XOR<TestMetricUpdateWithoutTestRunInput, TestMetricUncheckedUpdateWithoutTestRunInput>
  }

  export type TestMetricUpdateManyWithWhereWithoutTestRunInput = {
    where: TestMetricScalarWhereInput
    data: XOR<TestMetricUpdateManyMutationInput, TestMetricUncheckedUpdateManyWithoutTestRunInput>
  }

  export type TestMetricScalarWhereInput = {
    AND?: TestMetricScalarWhereInput | TestMetricScalarWhereInput[]
    OR?: TestMetricScalarWhereInput[]
    NOT?: TestMetricScalarWhereInput | TestMetricScalarWhereInput[]
    id?: StringFilter<"TestMetric"> | string
    name?: StringFilter<"TestMetric"> | string
    value?: FloatFilter<"TestMetric"> | number
    unit?: StringNullableFilter<"TestMetric"> | string | null
    metadata?: StringNullableFilter<"TestMetric"> | string | null
    createdAt?: DateTimeFilter<"TestMetric"> | Date | string
    testRunId?: StringFilter<"TestMetric"> | string
  }

  export type TestRunCreateWithoutResponsesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestRunsInput
    user: UserCreateNestedOneWithoutTestRunsInput
    prompt: PromptCreateNestedOneWithoutTestRunsInput
    metrics?: TestMetricCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUncheckedCreateWithoutResponsesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    promptId: string
    metrics?: TestMetricUncheckedCreateNestedManyWithoutTestRunInput
  }

  export type TestRunCreateOrConnectWithoutResponsesInput = {
    where: TestRunWhereUniqueInput
    create: XOR<TestRunCreateWithoutResponsesInput, TestRunUncheckedCreateWithoutResponsesInput>
  }

  export type TestRunUpsertWithoutResponsesInput = {
    update: XOR<TestRunUpdateWithoutResponsesInput, TestRunUncheckedUpdateWithoutResponsesInput>
    create: XOR<TestRunCreateWithoutResponsesInput, TestRunUncheckedCreateWithoutResponsesInput>
    where?: TestRunWhereInput
  }

  export type TestRunUpdateToOneWithWhereWithoutResponsesInput = {
    where?: TestRunWhereInput
    data: XOR<TestRunUpdateWithoutResponsesInput, TestRunUncheckedUpdateWithoutResponsesInput>
  }

  export type TestRunUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestRunsNestedInput
    user?: UserUpdateOneRequiredWithoutTestRunsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutTestRunsNestedInput
    metrics?: TestMetricUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    metrics?: TestMetricUncheckedUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestRunsInput
    user: UserCreateNestedOneWithoutTestRunsInput
    prompt: PromptCreateNestedOneWithoutTestRunsInput
    responses?: TestResponseCreateNestedManyWithoutTestRunInput
  }

  export type TestRunUncheckedCreateWithoutMetricsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
    promptId: string
    responses?: TestResponseUncheckedCreateNestedManyWithoutTestRunInput
  }

  export type TestRunCreateOrConnectWithoutMetricsInput = {
    where: TestRunWhereUniqueInput
    create: XOR<TestRunCreateWithoutMetricsInput, TestRunUncheckedCreateWithoutMetricsInput>
  }

  export type TestRunUpsertWithoutMetricsInput = {
    update: XOR<TestRunUpdateWithoutMetricsInput, TestRunUncheckedUpdateWithoutMetricsInput>
    create: XOR<TestRunCreateWithoutMetricsInput, TestRunUncheckedCreateWithoutMetricsInput>
    where?: TestRunWhereInput
  }

  export type TestRunUpdateToOneWithWhereWithoutMetricsInput = {
    where?: TestRunWhereInput
    data: XOR<TestRunUpdateWithoutMetricsInput, TestRunUncheckedUpdateWithoutMetricsInput>
  }

  export type TestRunUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestRunsNestedInput
    user?: UserUpdateOneRequiredWithoutTestRunsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutTestRunsNestedInput
    responses?: TestResponseUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    responses?: TestResponseUncheckedUpdateManyWithoutTestRunNestedInput
  }

  export type ProjectCreateWithoutSyncOperationsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSyncOperationsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSyncOperationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSyncOperationsInput, ProjectUncheckedCreateWithoutSyncOperationsInput>
  }

  export type AppIntegrationCreateWithoutSyncOperationsInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAppIntegrationsInput
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
  }

  export type AppIntegrationUncheckedCreateWithoutSyncOperationsInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type AppIntegrationCreateOrConnectWithoutSyncOperationsInput = {
    where: AppIntegrationWhereUniqueInput
    create: XOR<AppIntegrationCreateWithoutSyncOperationsInput, AppIntegrationUncheckedCreateWithoutSyncOperationsInput>
  }

  export type UserCreateWithoutInitiatedSyncsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutInitiatedSyncsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutInitiatedSyncsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInitiatedSyncsInput, UserUncheckedCreateWithoutInitiatedSyncsInput>
  }

  export type ProjectUpsertWithoutSyncOperationsInput = {
    update: XOR<ProjectUpdateWithoutSyncOperationsInput, ProjectUncheckedUpdateWithoutSyncOperationsInput>
    create: XOR<ProjectCreateWithoutSyncOperationsInput, ProjectUncheckedCreateWithoutSyncOperationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSyncOperationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSyncOperationsInput, ProjectUncheckedUpdateWithoutSyncOperationsInput>
  }

  export type ProjectUpdateWithoutSyncOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSyncOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AppIntegrationUpsertWithoutSyncOperationsInput = {
    update: XOR<AppIntegrationUpdateWithoutSyncOperationsInput, AppIntegrationUncheckedUpdateWithoutSyncOperationsInput>
    create: XOR<AppIntegrationCreateWithoutSyncOperationsInput, AppIntegrationUncheckedCreateWithoutSyncOperationsInput>
    where?: AppIntegrationWhereInput
  }

  export type AppIntegrationUpdateToOneWithWhereWithoutSyncOperationsInput = {
    where?: AppIntegrationWhereInput
    data: XOR<AppIntegrationUpdateWithoutSyncOperationsInput, AppIntegrationUncheckedUpdateWithoutSyncOperationsInput>
  }

  export type AppIntegrationUpdateWithoutSyncOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAppIntegrationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
  }

  export type AppIntegrationUncheckedUpdateWithoutSyncOperationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutInitiatedSyncsInput = {
    update: XOR<UserUpdateWithoutInitiatedSyncsInput, UserUncheckedUpdateWithoutInitiatedSyncsInput>
    create: XOR<UserCreateWithoutInitiatedSyncsInput, UserUncheckedCreateWithoutInitiatedSyncsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInitiatedSyncsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInitiatedSyncsInput, UserUncheckedUpdateWithoutInitiatedSyncsInput>
  }

  export type UserUpdateWithoutInitiatedSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutInitiatedSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutWebhookSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWebhookSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWebhookSubscriptionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWebhookSubscriptionsInput, ProjectUncheckedCreateWithoutWebhookSubscriptionsInput>
  }

  export type UserCreateWithoutCreatedWebhooksInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutCreatedWebhooksInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutCreatedWebhooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedWebhooksInput, UserUncheckedCreateWithoutCreatedWebhooksInput>
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    project?: ProjectCreateNestedOneWithoutWebhookDeliveriesInput
    failedWebhook?: WebhookSubscriptionCreateNestedOneWithoutFailedDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    projectId?: string | null
    failedWebhookId?: string | null
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
  }

  export type WebhookDeliveryCreateWithoutFailedWebhookInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    project?: ProjectCreateNestedOneWithoutWebhookDeliveriesInput
    webhook?: WebhookSubscriptionCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    projectId?: string | null
    webhookId?: string | null
  }

  export type WebhookDeliveryCreateOrConnectWithoutFailedWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutFailedWebhookInput, WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput>
  }

  export type WebhookDeliveryCreateManyFailedWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyFailedWebhookInput | WebhookDeliveryCreateManyFailedWebhookInput[]
  }

  export type ProjectUpsertWithoutWebhookSubscriptionsInput = {
    update: XOR<ProjectUpdateWithoutWebhookSubscriptionsInput, ProjectUncheckedUpdateWithoutWebhookSubscriptionsInput>
    create: XOR<ProjectCreateWithoutWebhookSubscriptionsInput, ProjectUncheckedCreateWithoutWebhookSubscriptionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWebhookSubscriptionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWebhookSubscriptionsInput, ProjectUncheckedUpdateWithoutWebhookSubscriptionsInput>
  }

  export type ProjectUpdateWithoutWebhookSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWebhookSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedWebhooksInput = {
    update: XOR<UserUpdateWithoutCreatedWebhooksInput, UserUncheckedUpdateWithoutCreatedWebhooksInput>
    create: XOR<UserCreateWithoutCreatedWebhooksInput, UserUncheckedCreateWithoutCreatedWebhooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedWebhooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedWebhooksInput, UserUncheckedUpdateWithoutCreatedWebhooksInput>
  }

  export type UserUpdateWithoutCreatedWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutFailedWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutFailedWebhookInput, WebhookDeliveryUncheckedUpdateWithoutFailedWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutFailedWebhookInput, WebhookDeliveryUncheckedCreateWithoutFailedWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutFailedWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutFailedWebhookInput, WebhookDeliveryUncheckedUpdateWithoutFailedWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutFailedWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookInput>
  }

  export type ProjectCreateWithoutWebhookDeliveriesInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWebhookDeliveriesInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWebhookDeliveriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWebhookDeliveriesInput, ProjectUncheckedCreateWithoutWebhookDeliveriesInput>
  }

  export type WebhookSubscriptionCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWebhookSubscriptionsInput
    creator: UserCreateNestedOneWithoutCreatedWebhooksInput
    failedDeliveries?: WebhookDeliveryCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    createdBy: string
    failedDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutFailedWebhookInput
  }

  export type WebhookSubscriptionCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookSubscriptionWhereUniqueInput
    create: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookSubscriptionCreateWithoutFailedDeliveriesInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutWebhookSubscriptionsInput
    creator: UserCreateNestedOneWithoutCreatedWebhooksInput
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookSubscriptionUncheckedCreateWithoutFailedDeliveriesInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
    createdBy: string
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookSubscriptionCreateOrConnectWithoutFailedDeliveriesInput = {
    where: WebhookSubscriptionWhereUniqueInput
    create: XOR<WebhookSubscriptionCreateWithoutFailedDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutFailedDeliveriesInput>
  }

  export type ProjectUpsertWithoutWebhookDeliveriesInput = {
    update: XOR<ProjectUpdateWithoutWebhookDeliveriesInput, ProjectUncheckedUpdateWithoutWebhookDeliveriesInput>
    create: XOR<ProjectCreateWithoutWebhookDeliveriesInput, ProjectUncheckedCreateWithoutWebhookDeliveriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWebhookDeliveriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWebhookDeliveriesInput, ProjectUncheckedUpdateWithoutWebhookDeliveriesInput>
  }

  export type ProjectUpdateWithoutWebhookDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWebhookDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type WebhookSubscriptionUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookSubscriptionUpdateWithoutDeliveriesInput, WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookSubscriptionCreateWithoutDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookSubscriptionWhereInput
  }

  export type WebhookSubscriptionUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookSubscriptionWhereInput
    data: XOR<WebhookSubscriptionUpdateWithoutDeliveriesInput, WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookSubscriptionUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWebhookSubscriptionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWebhooksNestedInput
    failedDeliveries?: WebhookDeliveryUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    failedDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUpsertWithoutFailedDeliveriesInput = {
    update: XOR<WebhookSubscriptionUpdateWithoutFailedDeliveriesInput, WebhookSubscriptionUncheckedUpdateWithoutFailedDeliveriesInput>
    create: XOR<WebhookSubscriptionCreateWithoutFailedDeliveriesInput, WebhookSubscriptionUncheckedCreateWithoutFailedDeliveriesInput>
    where?: WebhookSubscriptionWhereInput
  }

  export type WebhookSubscriptionUpdateToOneWithWhereWithoutFailedDeliveriesInput = {
    where?: WebhookSubscriptionWhereInput
    data: XOR<WebhookSubscriptionUpdateWithoutFailedDeliveriesInput, WebhookSubscriptionUncheckedUpdateWithoutFailedDeliveriesInput>
  }

  export type WebhookSubscriptionUpdateWithoutFailedDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWebhookSubscriptionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateWithoutFailedDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type ProjectCreateWithoutApiKeyInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiKeyInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiKeyInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiKeyInput, ProjectUncheckedCreateWithoutApiKeyInput>
  }

  export type ProjectUpsertWithoutApiKeyInput = {
    update: XOR<ProjectUpdateWithoutApiKeyInput, ProjectUncheckedUpdateWithoutApiKeyInput>
    create: XOR<ProjectCreateWithoutApiKeyInput, ProjectUncheckedCreateWithoutApiKeyInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiKeyInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiKeyInput, ProjectUncheckedUpdateWithoutApiKeyInput>
  }

  export type ProjectUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutEnvironmentsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutEnvironmentsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutEnvironmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutEnvironmentsInput, ProjectUncheckedCreateWithoutEnvironmentsInput>
  }

  export type DeploymentCreateWithoutEnvironmentInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutDeploymentsInput
    deployedByUser: UserCreateNestedOneWithoutDeploymentsInput
    history?: DeploymentHistoryCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateWithoutEnvironmentInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    deployedBy: string
    history?: DeploymentHistoryUncheckedCreateNestedManyWithoutDeploymentInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentCreateOrConnectWithoutEnvironmentInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput>
  }

  export type DeploymentCreateManyEnvironmentInputEnvelope = {
    data: DeploymentCreateManyEnvironmentInput | DeploymentCreateManyEnvironmentInput[]
  }

  export type ProjectUpsertWithoutEnvironmentsInput = {
    update: XOR<ProjectUpdateWithoutEnvironmentsInput, ProjectUncheckedUpdateWithoutEnvironmentsInput>
    create: XOR<ProjectCreateWithoutEnvironmentsInput, ProjectUncheckedCreateWithoutEnvironmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutEnvironmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutEnvironmentsInput, ProjectUncheckedUpdateWithoutEnvironmentsInput>
  }

  export type ProjectUpdateWithoutEnvironmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutEnvironmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DeploymentUpsertWithWhereUniqueWithoutEnvironmentInput = {
    where: DeploymentWhereUniqueInput
    update: XOR<DeploymentUpdateWithoutEnvironmentInput, DeploymentUncheckedUpdateWithoutEnvironmentInput>
    create: XOR<DeploymentCreateWithoutEnvironmentInput, DeploymentUncheckedCreateWithoutEnvironmentInput>
  }

  export type DeploymentUpdateWithWhereUniqueWithoutEnvironmentInput = {
    where: DeploymentWhereUniqueInput
    data: XOR<DeploymentUpdateWithoutEnvironmentInput, DeploymentUncheckedUpdateWithoutEnvironmentInput>
  }

  export type DeploymentUpdateManyWithWhereWithoutEnvironmentInput = {
    where: DeploymentScalarWhereInput
    data: XOR<DeploymentUpdateManyMutationInput, DeploymentUncheckedUpdateManyWithoutEnvironmentInput>
  }

  export type PromptCreateWithoutDeploymentsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutDeploymentsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutDeploymentsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutDeploymentsInput, PromptUncheckedCreateWithoutDeploymentsInput>
  }

  export type EnvironmentCreateWithoutDeploymentsInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutEnvironmentsInput
  }

  export type EnvironmentUncheckedCreateWithoutDeploymentsInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type EnvironmentCreateOrConnectWithoutDeploymentsInput = {
    where: EnvironmentWhereUniqueInput
    create: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
  }

  export type UserCreateWithoutDeploymentsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDeploymentsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDeploymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
  }

  export type DeploymentHistoryCreateWithoutDeploymentInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutDeploymentActionsInput
  }

  export type DeploymentHistoryUncheckedCreateWithoutDeploymentInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    performedBy: string
  }

  export type DeploymentHistoryCreateOrConnectWithoutDeploymentInput = {
    where: DeploymentHistoryWhereUniqueInput
    create: XOR<DeploymentHistoryCreateWithoutDeploymentInput, DeploymentHistoryUncheckedCreateWithoutDeploymentInput>
  }

  export type DeploymentHistoryCreateManyDeploymentInputEnvelope = {
    data: DeploymentHistoryCreateManyDeploymentInput | DeploymentHistoryCreateManyDeploymentInput[]
  }

  export type ImpactAnalysisCreateWithoutDeploymentInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    baselinePrompt?: PromptCreateNestedOneWithoutImpactAnalysisInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisUncheckedCreateWithoutDeploymentInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    baselinePromptId?: string | null
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisCreateOrConnectWithoutDeploymentInput = {
    where: ImpactAnalysisWhereUniqueInput
    create: XOR<ImpactAnalysisCreateWithoutDeploymentInput, ImpactAnalysisUncheckedCreateWithoutDeploymentInput>
  }

  export type ImpactAnalysisCreateManyDeploymentInputEnvelope = {
    data: ImpactAnalysisCreateManyDeploymentInput | ImpactAnalysisCreateManyDeploymentInput[]
  }

  export type PromptUpsertWithoutDeploymentsInput = {
    update: XOR<PromptUpdateWithoutDeploymentsInput, PromptUncheckedUpdateWithoutDeploymentsInput>
    create: XOR<PromptCreateWithoutDeploymentsInput, PromptUncheckedCreateWithoutDeploymentsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutDeploymentsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutDeploymentsInput, PromptUncheckedUpdateWithoutDeploymentsInput>
  }

  export type PromptUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type EnvironmentUpsertWithoutDeploymentsInput = {
    update: XOR<EnvironmentUpdateWithoutDeploymentsInput, EnvironmentUncheckedUpdateWithoutDeploymentsInput>
    create: XOR<EnvironmentCreateWithoutDeploymentsInput, EnvironmentUncheckedCreateWithoutDeploymentsInput>
    where?: EnvironmentWhereInput
  }

  export type EnvironmentUpdateToOneWithWhereWithoutDeploymentsInput = {
    where?: EnvironmentWhereInput
    data: XOR<EnvironmentUpdateWithoutDeploymentsInput, EnvironmentUncheckedUpdateWithoutDeploymentsInput>
  }

  export type EnvironmentUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutEnvironmentsNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutDeploymentsInput = {
    update: XOR<UserUpdateWithoutDeploymentsInput, UserUncheckedUpdateWithoutDeploymentsInput>
    create: XOR<UserCreateWithoutDeploymentsInput, UserUncheckedCreateWithoutDeploymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeploymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeploymentsInput, UserUncheckedUpdateWithoutDeploymentsInput>
  }

  export type UserUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DeploymentHistoryUpsertWithWhereUniqueWithoutDeploymentInput = {
    where: DeploymentHistoryWhereUniqueInput
    update: XOR<DeploymentHistoryUpdateWithoutDeploymentInput, DeploymentHistoryUncheckedUpdateWithoutDeploymentInput>
    create: XOR<DeploymentHistoryCreateWithoutDeploymentInput, DeploymentHistoryUncheckedCreateWithoutDeploymentInput>
  }

  export type DeploymentHistoryUpdateWithWhereUniqueWithoutDeploymentInput = {
    where: DeploymentHistoryWhereUniqueInput
    data: XOR<DeploymentHistoryUpdateWithoutDeploymentInput, DeploymentHistoryUncheckedUpdateWithoutDeploymentInput>
  }

  export type DeploymentHistoryUpdateManyWithWhereWithoutDeploymentInput = {
    where: DeploymentHistoryScalarWhereInput
    data: XOR<DeploymentHistoryUpdateManyMutationInput, DeploymentHistoryUncheckedUpdateManyWithoutDeploymentInput>
  }

  export type ImpactAnalysisUpsertWithWhereUniqueWithoutDeploymentInput = {
    where: ImpactAnalysisWhereUniqueInput
    update: XOR<ImpactAnalysisUpdateWithoutDeploymentInput, ImpactAnalysisUncheckedUpdateWithoutDeploymentInput>
    create: XOR<ImpactAnalysisCreateWithoutDeploymentInput, ImpactAnalysisUncheckedCreateWithoutDeploymentInput>
  }

  export type ImpactAnalysisUpdateWithWhereUniqueWithoutDeploymentInput = {
    where: ImpactAnalysisWhereUniqueInput
    data: XOR<ImpactAnalysisUpdateWithoutDeploymentInput, ImpactAnalysisUncheckedUpdateWithoutDeploymentInput>
  }

  export type ImpactAnalysisUpdateManyWithWhereWithoutDeploymentInput = {
    where: ImpactAnalysisScalarWhereInput
    data: XOR<ImpactAnalysisUpdateManyMutationInput, ImpactAnalysisUncheckedUpdateManyWithoutDeploymentInput>
  }

  export type DeploymentCreateWithoutHistoryInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutDeploymentsInput
    environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
    deployedByUser: UserCreateNestedOneWithoutDeploymentsInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateWithoutHistoryInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    environmentId: string
    deployedBy: string
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentCreateOrConnectWithoutHistoryInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutHistoryInput, DeploymentUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutDeploymentActionsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDeploymentActionsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDeploymentActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeploymentActionsInput, UserUncheckedCreateWithoutDeploymentActionsInput>
  }

  export type DeploymentUpsertWithoutHistoryInput = {
    update: XOR<DeploymentUpdateWithoutHistoryInput, DeploymentUncheckedUpdateWithoutHistoryInput>
    create: XOR<DeploymentCreateWithoutHistoryInput, DeploymentUncheckedCreateWithoutHistoryInput>
    where?: DeploymentWhereInput
  }

  export type DeploymentUpdateToOneWithWhereWithoutHistoryInput = {
    where?: DeploymentWhereInput
    data: XOR<DeploymentUpdateWithoutHistoryInput, DeploymentUncheckedUpdateWithoutHistoryInput>
  }

  export type DeploymentUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutDeploymentsNestedInput
    environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsNestedInput
    deployedByUser?: UserUpdateOneRequiredWithoutDeploymentsNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type UserUpsertWithoutDeploymentActionsInput = {
    update: XOR<UserUpdateWithoutDeploymentActionsInput, UserUncheckedUpdateWithoutDeploymentActionsInput>
    create: XOR<UserCreateWithoutDeploymentActionsInput, UserUncheckedCreateWithoutDeploymentActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeploymentActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeploymentActionsInput, UserUncheckedUpdateWithoutDeploymentActionsInput>
  }

  export type UserUpdateWithoutDeploymentActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDeploymentActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DeploymentCreateWithoutImpactAnalysisInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutDeploymentsInput
    environment: EnvironmentCreateNestedOneWithoutDeploymentsInput
    deployedByUser: UserCreateNestedOneWithoutDeploymentsInput
    history?: DeploymentHistoryCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentUncheckedCreateWithoutImpactAnalysisInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    environmentId: string
    deployedBy: string
    history?: DeploymentHistoryUncheckedCreateNestedManyWithoutDeploymentInput
  }

  export type DeploymentCreateOrConnectWithoutImpactAnalysisInput = {
    where: DeploymentWhereUniqueInput
    create: XOR<DeploymentCreateWithoutImpactAnalysisInput, DeploymentUncheckedCreateWithoutImpactAnalysisInput>
  }

  export type PromptCreateWithoutImpactAnalysisInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutImpactAnalysisInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutImpactAnalysisInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutImpactAnalysisInput, PromptUncheckedCreateWithoutImpactAnalysisInput>
  }

  export type ApprovalRequestCreateWithoutImpactAnalysisInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appId: string
    project: ProjectCreateNestedOneWithoutApprovalRequestsInput
    prompt: PromptCreateNestedOneWithoutApprovalRequestsInput
    requester: UserCreateNestedOneWithoutRequestedApprovalsInput
  }

  export type ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    appId: string
    requestedBy: string
  }

  export type ApprovalRequestCreateOrConnectWithoutImpactAnalysisInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutImpactAnalysisInput, ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput>
  }

  export type ApprovalRequestCreateManyImpactAnalysisInputEnvelope = {
    data: ApprovalRequestCreateManyImpactAnalysisInput | ApprovalRequestCreateManyImpactAnalysisInput[]
  }

  export type DeploymentUpsertWithoutImpactAnalysisInput = {
    update: XOR<DeploymentUpdateWithoutImpactAnalysisInput, DeploymentUncheckedUpdateWithoutImpactAnalysisInput>
    create: XOR<DeploymentCreateWithoutImpactAnalysisInput, DeploymentUncheckedCreateWithoutImpactAnalysisInput>
    where?: DeploymentWhereInput
  }

  export type DeploymentUpdateToOneWithWhereWithoutImpactAnalysisInput = {
    where?: DeploymentWhereInput
    data: XOR<DeploymentUpdateWithoutImpactAnalysisInput, DeploymentUncheckedUpdateWithoutImpactAnalysisInput>
  }

  export type DeploymentUpdateWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutDeploymentsNestedInput
    environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsNestedInput
    deployedByUser?: UserUpdateOneRequiredWithoutDeploymentsNestedInput
    history?: DeploymentHistoryUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
    history?: DeploymentHistoryUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type PromptUpsertWithoutImpactAnalysisInput = {
    update: XOR<PromptUpdateWithoutImpactAnalysisInput, PromptUncheckedUpdateWithoutImpactAnalysisInput>
    create: XOR<PromptCreateWithoutImpactAnalysisInput, PromptUncheckedCreateWithoutImpactAnalysisInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutImpactAnalysisInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutImpactAnalysisInput, PromptUncheckedUpdateWithoutImpactAnalysisInput>
  }

  export type PromptUpdateWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutImpactAnalysisInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutImpactAnalysisInput, ApprovalRequestUncheckedUpdateWithoutImpactAnalysisInput>
    create: XOR<ApprovalRequestCreateWithoutImpactAnalysisInput, ApprovalRequestUncheckedCreateWithoutImpactAnalysisInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutImpactAnalysisInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutImpactAnalysisInput, ApprovalRequestUncheckedUpdateWithoutImpactAnalysisInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutImpactAnalysisInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutImpactAnalysisInput>
  }

  export type ProjectCreateWithoutCostTrackingInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCostTrackingInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCostTrackingInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCostTrackingInput, ProjectUncheckedCreateWithoutCostTrackingInput>
  }

  export type UserCreateWithoutCostTrackingInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCostTrackingInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCostTrackingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCostTrackingInput, UserUncheckedCreateWithoutCostTrackingInput>
  }

  export type ProjectUpsertWithoutCostTrackingInput = {
    update: XOR<ProjectUpdateWithoutCostTrackingInput, ProjectUncheckedUpdateWithoutCostTrackingInput>
    create: XOR<ProjectCreateWithoutCostTrackingInput, ProjectUncheckedCreateWithoutCostTrackingInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCostTrackingInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCostTrackingInput, ProjectUncheckedUpdateWithoutCostTrackingInput>
  }

  export type ProjectUpdateWithoutCostTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCostTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCostTrackingInput = {
    update: XOR<UserUpdateWithoutCostTrackingInput, UserUncheckedUpdateWithoutCostTrackingInput>
    create: XOR<UserCreateWithoutCostTrackingInput, UserUncheckedCreateWithoutCostTrackingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCostTrackingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCostTrackingInput, UserUncheckedUpdateWithoutCostTrackingInput>
  }

  export type UserUpdateWithoutCostTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCostTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutBillingInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutBillingInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutBillingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBillingInput, UserUncheckedCreateWithoutBillingInput>
  }

  export type UserUpsertWithoutBillingInput = {
    update: XOR<UserUpdateWithoutBillingInput, UserUncheckedUpdateWithoutBillingInput>
    create: XOR<UserCreateWithoutBillingInput, UserUncheckedCreateWithoutBillingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBillingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBillingInput, UserUncheckedUpdateWithoutBillingInput>
  }

  export type UserUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutBillingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutAppIntegrationsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAppIntegrationsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAppIntegrationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAppIntegrationsInput, ProjectUncheckedCreateWithoutAppIntegrationsInput>
  }

  export type UserCreateWithoutCreatedIntegrationsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedIntegrationsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
  }

  export type SyncOperationCreateWithoutConnectionInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSyncOperationsInput
    initiator: UserCreateNestedOneWithoutInitiatedSyncsInput
  }

  export type SyncOperationUncheckedCreateWithoutConnectionInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    initiatedBy: string
  }

  export type SyncOperationCreateOrConnectWithoutConnectionInput = {
    where: SyncOperationWhereUniqueInput
    create: XOR<SyncOperationCreateWithoutConnectionInput, SyncOperationUncheckedCreateWithoutConnectionInput>
  }

  export type SyncOperationCreateManyConnectionInputEnvelope = {
    data: SyncOperationCreateManyConnectionInput | SyncOperationCreateManyConnectionInput[]
  }

  export type ProjectUpsertWithoutAppIntegrationsInput = {
    update: XOR<ProjectUpdateWithoutAppIntegrationsInput, ProjectUncheckedUpdateWithoutAppIntegrationsInput>
    create: XOR<ProjectCreateWithoutAppIntegrationsInput, ProjectUncheckedCreateWithoutAppIntegrationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAppIntegrationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAppIntegrationsInput, ProjectUncheckedUpdateWithoutAppIntegrationsInput>
  }

  export type ProjectUpdateWithoutAppIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAppIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedIntegrationsInput = {
    update: XOR<UserUpdateWithoutCreatedIntegrationsInput, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
    create: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedIntegrationsInput, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
  }

  export type UserUpdateWithoutCreatedIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SyncOperationUpsertWithWhereUniqueWithoutConnectionInput = {
    where: SyncOperationWhereUniqueInput
    update: XOR<SyncOperationUpdateWithoutConnectionInput, SyncOperationUncheckedUpdateWithoutConnectionInput>
    create: XOR<SyncOperationCreateWithoutConnectionInput, SyncOperationUncheckedCreateWithoutConnectionInput>
  }

  export type SyncOperationUpdateWithWhereUniqueWithoutConnectionInput = {
    where: SyncOperationWhereUniqueInput
    data: XOR<SyncOperationUpdateWithoutConnectionInput, SyncOperationUncheckedUpdateWithoutConnectionInput>
  }

  export type SyncOperationUpdateManyWithWhereWithoutConnectionInput = {
    where: SyncOperationScalarWhereInput
    data: XOR<SyncOperationUpdateManyMutationInput, SyncOperationUncheckedUpdateManyWithoutConnectionInput>
  }

  export type ProjectCreateWithoutTestPipelinesInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTestPipelinesInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTestPipelinesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTestPipelinesInput, ProjectUncheckedCreateWithoutTestPipelinesInput>
  }

  export type UserCreateWithoutCreatedPipelinesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedPipelinesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedPipelinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPipelinesInput, UserUncheckedCreateWithoutCreatedPipelinesInput>
  }

  export type PipelineStageCreateWithoutPipelineInput = {
    id?: string
    name: string
    type: string
    config: string
    order: number
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineStageUncheckedCreateWithoutPipelineInput = {
    id?: string
    name: string
    type: string
    config: string
    order: number
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineStageCreateOrConnectWithoutPipelineInput = {
    where: PipelineStageWhereUniqueInput
    create: XOR<PipelineStageCreateWithoutPipelineInput, PipelineStageUncheckedCreateWithoutPipelineInput>
  }

  export type PipelineStageCreateManyPipelineInputEnvelope = {
    data: PipelineStageCreateManyPipelineInput | PipelineStageCreateManyPipelineInput[]
  }

  export type PipelineExecutionCreateWithoutPipelineInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt: PromptCreateNestedOneWithoutPipelineExecutionsInput
    baselinePrompt?: PromptCreateNestedOneWithoutBaselinePipelineExecutionsInput
    executor: UserCreateNestedOneWithoutExecutedPipelinesInput
  }

  export type PipelineExecutionUncheckedCreateWithoutPipelineInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    baselinePromptId?: string | null
    executedBy: string
  }

  export type PipelineExecutionCreateOrConnectWithoutPipelineInput = {
    where: PipelineExecutionWhereUniqueInput
    create: XOR<PipelineExecutionCreateWithoutPipelineInput, PipelineExecutionUncheckedCreateWithoutPipelineInput>
  }

  export type PipelineExecutionCreateManyPipelineInputEnvelope = {
    data: PipelineExecutionCreateManyPipelineInput | PipelineExecutionCreateManyPipelineInput[]
  }

  export type ProjectUpsertWithoutTestPipelinesInput = {
    update: XOR<ProjectUpdateWithoutTestPipelinesInput, ProjectUncheckedUpdateWithoutTestPipelinesInput>
    create: XOR<ProjectCreateWithoutTestPipelinesInput, ProjectUncheckedCreateWithoutTestPipelinesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTestPipelinesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTestPipelinesInput, ProjectUncheckedUpdateWithoutTestPipelinesInput>
  }

  export type ProjectUpdateWithoutTestPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTestPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedPipelinesInput = {
    update: XOR<UserUpdateWithoutCreatedPipelinesInput, UserUncheckedUpdateWithoutCreatedPipelinesInput>
    create: XOR<UserCreateWithoutCreatedPipelinesInput, UserUncheckedCreateWithoutCreatedPipelinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPipelinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPipelinesInput, UserUncheckedUpdateWithoutCreatedPipelinesInput>
  }

  export type UserUpdateWithoutCreatedPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PipelineStageUpsertWithWhereUniqueWithoutPipelineInput = {
    where: PipelineStageWhereUniqueInput
    update: XOR<PipelineStageUpdateWithoutPipelineInput, PipelineStageUncheckedUpdateWithoutPipelineInput>
    create: XOR<PipelineStageCreateWithoutPipelineInput, PipelineStageUncheckedCreateWithoutPipelineInput>
  }

  export type PipelineStageUpdateWithWhereUniqueWithoutPipelineInput = {
    where: PipelineStageWhereUniqueInput
    data: XOR<PipelineStageUpdateWithoutPipelineInput, PipelineStageUncheckedUpdateWithoutPipelineInput>
  }

  export type PipelineStageUpdateManyWithWhereWithoutPipelineInput = {
    where: PipelineStageScalarWhereInput
    data: XOR<PipelineStageUpdateManyMutationInput, PipelineStageUncheckedUpdateManyWithoutPipelineInput>
  }

  export type PipelineStageScalarWhereInput = {
    AND?: PipelineStageScalarWhereInput | PipelineStageScalarWhereInput[]
    OR?: PipelineStageScalarWhereInput[]
    NOT?: PipelineStageScalarWhereInput | PipelineStageScalarWhereInput[]
    id?: StringFilter<"PipelineStage"> | string
    name?: StringFilter<"PipelineStage"> | string
    type?: StringFilter<"PipelineStage"> | string
    config?: StringFilter<"PipelineStage"> | string
    order?: IntFilter<"PipelineStage"> | number
    status?: StringFilter<"PipelineStage"> | string
    result?: StringNullableFilter<"PipelineStage"> | string | null
    createdAt?: DateTimeFilter<"PipelineStage"> | Date | string
    updatedAt?: DateTimeFilter<"PipelineStage"> | Date | string
    pipelineId?: StringFilter<"PipelineStage"> | string
  }

  export type PipelineExecutionUpsertWithWhereUniqueWithoutPipelineInput = {
    where: PipelineExecutionWhereUniqueInput
    update: XOR<PipelineExecutionUpdateWithoutPipelineInput, PipelineExecutionUncheckedUpdateWithoutPipelineInput>
    create: XOR<PipelineExecutionCreateWithoutPipelineInput, PipelineExecutionUncheckedCreateWithoutPipelineInput>
  }

  export type PipelineExecutionUpdateWithWhereUniqueWithoutPipelineInput = {
    where: PipelineExecutionWhereUniqueInput
    data: XOR<PipelineExecutionUpdateWithoutPipelineInput, PipelineExecutionUncheckedUpdateWithoutPipelineInput>
  }

  export type PipelineExecutionUpdateManyWithWhereWithoutPipelineInput = {
    where: PipelineExecutionScalarWhereInput
    data: XOR<PipelineExecutionUpdateManyMutationInput, PipelineExecutionUncheckedUpdateManyWithoutPipelineInput>
  }

  export type TestPipelineCreateWithoutStagesInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestPipelinesInput
    creator: UserCreateNestedOneWithoutCreatedPipelinesInput
    executions?: PipelineExecutionCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineUncheckedCreateWithoutStagesInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    executions?: PipelineExecutionUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineCreateOrConnectWithoutStagesInput = {
    where: TestPipelineWhereUniqueInput
    create: XOR<TestPipelineCreateWithoutStagesInput, TestPipelineUncheckedCreateWithoutStagesInput>
  }

  export type TestPipelineUpsertWithoutStagesInput = {
    update: XOR<TestPipelineUpdateWithoutStagesInput, TestPipelineUncheckedUpdateWithoutStagesInput>
    create: XOR<TestPipelineCreateWithoutStagesInput, TestPipelineUncheckedCreateWithoutStagesInput>
    where?: TestPipelineWhereInput
  }

  export type TestPipelineUpdateToOneWithWhereWithoutStagesInput = {
    where?: TestPipelineWhereInput
    data: XOR<TestPipelineUpdateWithoutStagesInput, TestPipelineUncheckedUpdateWithoutStagesInput>
  }

  export type TestPipelineUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestPipelinesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPipelinesNestedInput
    executions?: PipelineExecutionUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executions?: PipelineExecutionUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTestPipelinesInput
    creator: UserCreateNestedOneWithoutCreatedPipelinesInput
    stages?: PipelineStageCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
    stages?: PipelineStageUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type TestPipelineCreateOrConnectWithoutExecutionsInput = {
    where: TestPipelineWhereUniqueInput
    create: XOR<TestPipelineCreateWithoutExecutionsInput, TestPipelineUncheckedCreateWithoutExecutionsInput>
  }

  export type PromptCreateWithoutPipelineExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutPipelineExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutPipelineExecutionsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutPipelineExecutionsInput, PromptUncheckedCreateWithoutPipelineExecutionsInput>
  }

  export type PromptCreateWithoutBaselinePipelineExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutBaselinePipelineExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutBaselinePipelineExecutionsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutBaselinePipelineExecutionsInput, PromptUncheckedCreateWithoutBaselinePipelineExecutionsInput>
  }

  export type UserCreateWithoutExecutedPipelinesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutExecutedPipelinesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutExecutedPipelinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExecutedPipelinesInput, UserUncheckedCreateWithoutExecutedPipelinesInput>
  }

  export type TestPipelineUpsertWithoutExecutionsInput = {
    update: XOR<TestPipelineUpdateWithoutExecutionsInput, TestPipelineUncheckedUpdateWithoutExecutionsInput>
    create: XOR<TestPipelineCreateWithoutExecutionsInput, TestPipelineUncheckedCreateWithoutExecutionsInput>
    where?: TestPipelineWhereInput
  }

  export type TestPipelineUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: TestPipelineWhereInput
    data: XOR<TestPipelineUpdateWithoutExecutionsInput, TestPipelineUncheckedUpdateWithoutExecutionsInput>
  }

  export type TestPipelineUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestPipelinesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPipelinesNestedInput
    stages?: PipelineStageUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    stages?: PipelineStageUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PromptUpsertWithoutPipelineExecutionsInput = {
    update: XOR<PromptUpdateWithoutPipelineExecutionsInput, PromptUncheckedUpdateWithoutPipelineExecutionsInput>
    create: XOR<PromptCreateWithoutPipelineExecutionsInput, PromptUncheckedCreateWithoutPipelineExecutionsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutPipelineExecutionsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutPipelineExecutionsInput, PromptUncheckedUpdateWithoutPipelineExecutionsInput>
  }

  export type PromptUpdateWithoutPipelineExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutPipelineExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUpsertWithoutBaselinePipelineExecutionsInput = {
    update: XOR<PromptUpdateWithoutBaselinePipelineExecutionsInput, PromptUncheckedUpdateWithoutBaselinePipelineExecutionsInput>
    create: XOR<PromptCreateWithoutBaselinePipelineExecutionsInput, PromptUncheckedCreateWithoutBaselinePipelineExecutionsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutBaselinePipelineExecutionsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutBaselinePipelineExecutionsInput, PromptUncheckedUpdateWithoutBaselinePipelineExecutionsInput>
  }

  export type PromptUpdateWithoutBaselinePipelineExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutBaselinePipelineExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type UserUpsertWithoutExecutedPipelinesInput = {
    update: XOR<UserUpdateWithoutExecutedPipelinesInput, UserUncheckedUpdateWithoutExecutedPipelinesInput>
    create: XOR<UserCreateWithoutExecutedPipelinesInput, UserUncheckedCreateWithoutExecutedPipelinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExecutedPipelinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExecutedPipelinesInput, UserUncheckedUpdateWithoutExecutedPipelinesInput>
  }

  export type UserUpdateWithoutExecutedPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutExecutedPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutDependenciesInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDependenciesInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDependenciesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDependenciesInput, ProjectUncheckedCreateWithoutDependenciesInput>
  }

  export type UserCreateWithoutCreatedDependenciesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedDependenciesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedDependenciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedDependenciesInput, UserUncheckedCreateWithoutCreatedDependenciesInput>
  }

  export type ProjectUpsertWithoutDependenciesInput = {
    update: XOR<ProjectUpdateWithoutDependenciesInput, ProjectUncheckedUpdateWithoutDependenciesInput>
    create: XOR<ProjectCreateWithoutDependenciesInput, ProjectUncheckedCreateWithoutDependenciesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDependenciesInput, ProjectUncheckedUpdateWithoutDependenciesInput>
  }

  export type ProjectUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedDependenciesInput = {
    update: XOR<UserUpdateWithoutCreatedDependenciesInput, UserUncheckedUpdateWithoutCreatedDependenciesInput>
    create: XOR<UserCreateWithoutCreatedDependenciesInput, UserUncheckedCreateWithoutCreatedDependenciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedDependenciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedDependenciesInput, UserUncheckedUpdateWithoutCreatedDependenciesInput>
  }

  export type UserUpdateWithoutCreatedDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedDependenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutUpdatePlansInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUpdatePlansInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUpdatePlansInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUpdatePlansInput, ProjectUncheckedCreateWithoutUpdatePlansInput>
  }

  export type UserCreateWithoutCreatedUpdatePlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedUpdatePlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedUpdatePlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUpdatePlansInput, UserUncheckedCreateWithoutCreatedUpdatePlansInput>
  }

  export type UserCreateWithoutExecutedUpdatePlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutExecutedUpdatePlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutExecutedUpdatePlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExecutedUpdatePlansInput, UserUncheckedCreateWithoutExecutedUpdatePlansInput>
  }

  export type ProjectUpsertWithoutUpdatePlansInput = {
    update: XOR<ProjectUpdateWithoutUpdatePlansInput, ProjectUncheckedUpdateWithoutUpdatePlansInput>
    create: XOR<ProjectCreateWithoutUpdatePlansInput, ProjectUncheckedCreateWithoutUpdatePlansInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUpdatePlansInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUpdatePlansInput, ProjectUncheckedUpdateWithoutUpdatePlansInput>
  }

  export type ProjectUpdateWithoutUpdatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUpdatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedUpdatePlansInput = {
    update: XOR<UserUpdateWithoutCreatedUpdatePlansInput, UserUncheckedUpdateWithoutCreatedUpdatePlansInput>
    create: XOR<UserCreateWithoutCreatedUpdatePlansInput, UserUncheckedCreateWithoutCreatedUpdatePlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUpdatePlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUpdatePlansInput, UserUncheckedUpdateWithoutCreatedUpdatePlansInput>
  }

  export type UserUpdateWithoutCreatedUpdatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUpdatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutExecutedUpdatePlansInput = {
    update: XOR<UserUpdateWithoutExecutedUpdatePlansInput, UserUncheckedUpdateWithoutExecutedUpdatePlansInput>
    create: XOR<UserCreateWithoutExecutedUpdatePlansInput, UserUncheckedCreateWithoutExecutedUpdatePlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExecutedUpdatePlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExecutedUpdatePlansInput, UserUncheckedUpdateWithoutExecutedUpdatePlansInput>
  }

  export type UserUpdateWithoutExecutedUpdatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutExecutedUpdatePlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutDeploymentPlansInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDeploymentPlansInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDeploymentPlansInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDeploymentPlansInput, ProjectUncheckedCreateWithoutDeploymentPlansInput>
  }

  export type PromptCreateWithoutDeploymentPlansInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    approvalRequests?: ApprovalRequestCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutDeploymentPlansInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    approvalRequests?: ApprovalRequestUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutDeploymentPlansInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutDeploymentPlansInput, PromptUncheckedCreateWithoutDeploymentPlansInput>
  }

  export type UserCreateWithoutCreatedDeploymentPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedDeploymentPlansInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedDeploymentPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedDeploymentPlansInput, UserUncheckedCreateWithoutCreatedDeploymentPlansInput>
  }

  export type DeploymentExecutionCreateWithoutPlanInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executor: UserCreateNestedOneWithoutExecutedDeploymentsInput
  }

  export type DeploymentExecutionUncheckedCreateWithoutPlanInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executedBy: string
  }

  export type DeploymentExecutionCreateOrConnectWithoutPlanInput = {
    where: DeploymentExecutionWhereUniqueInput
    create: XOR<DeploymentExecutionCreateWithoutPlanInput, DeploymentExecutionUncheckedCreateWithoutPlanInput>
  }

  export type DeploymentExecutionCreateManyPlanInputEnvelope = {
    data: DeploymentExecutionCreateManyPlanInput | DeploymentExecutionCreateManyPlanInput[]
  }

  export type DeploymentApprovalCreateWithoutPlanInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver: UserCreateNestedOneWithoutDeploymentApprovalsInput
  }

  export type DeploymentApprovalUncheckedCreateWithoutPlanInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy: string
  }

  export type DeploymentApprovalCreateOrConnectWithoutPlanInput = {
    where: DeploymentApprovalWhereUniqueInput
    create: XOR<DeploymentApprovalCreateWithoutPlanInput, DeploymentApprovalUncheckedCreateWithoutPlanInput>
  }

  export type DeploymentApprovalCreateManyPlanInputEnvelope = {
    data: DeploymentApprovalCreateManyPlanInput | DeploymentApprovalCreateManyPlanInput[]
  }

  export type ProjectUpsertWithoutDeploymentPlansInput = {
    update: XOR<ProjectUpdateWithoutDeploymentPlansInput, ProjectUncheckedUpdateWithoutDeploymentPlansInput>
    create: XOR<ProjectCreateWithoutDeploymentPlansInput, ProjectUncheckedCreateWithoutDeploymentPlansInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDeploymentPlansInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDeploymentPlansInput, ProjectUncheckedUpdateWithoutDeploymentPlansInput>
  }

  export type ProjectUpdateWithoutDeploymentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDeploymentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PromptUpsertWithoutDeploymentPlansInput = {
    update: XOR<PromptUpdateWithoutDeploymentPlansInput, PromptUncheckedUpdateWithoutDeploymentPlansInput>
    create: XOR<PromptCreateWithoutDeploymentPlansInput, PromptUncheckedCreateWithoutDeploymentPlansInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutDeploymentPlansInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutDeploymentPlansInput, PromptUncheckedUpdateWithoutDeploymentPlansInput>
  }

  export type PromptUpdateWithoutDeploymentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutDeploymentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type UserUpsertWithoutCreatedDeploymentPlansInput = {
    update: XOR<UserUpdateWithoutCreatedDeploymentPlansInput, UserUncheckedUpdateWithoutCreatedDeploymentPlansInput>
    create: XOR<UserCreateWithoutCreatedDeploymentPlansInput, UserUncheckedCreateWithoutCreatedDeploymentPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedDeploymentPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedDeploymentPlansInput, UserUncheckedUpdateWithoutCreatedDeploymentPlansInput>
  }

  export type UserUpdateWithoutCreatedDeploymentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedDeploymentPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DeploymentExecutionUpsertWithWhereUniqueWithoutPlanInput = {
    where: DeploymentExecutionWhereUniqueInput
    update: XOR<DeploymentExecutionUpdateWithoutPlanInput, DeploymentExecutionUncheckedUpdateWithoutPlanInput>
    create: XOR<DeploymentExecutionCreateWithoutPlanInput, DeploymentExecutionUncheckedCreateWithoutPlanInput>
  }

  export type DeploymentExecutionUpdateWithWhereUniqueWithoutPlanInput = {
    where: DeploymentExecutionWhereUniqueInput
    data: XOR<DeploymentExecutionUpdateWithoutPlanInput, DeploymentExecutionUncheckedUpdateWithoutPlanInput>
  }

  export type DeploymentExecutionUpdateManyWithWhereWithoutPlanInput = {
    where: DeploymentExecutionScalarWhereInput
    data: XOR<DeploymentExecutionUpdateManyMutationInput, DeploymentExecutionUncheckedUpdateManyWithoutPlanInput>
  }

  export type DeploymentApprovalUpsertWithWhereUniqueWithoutPlanInput = {
    where: DeploymentApprovalWhereUniqueInput
    update: XOR<DeploymentApprovalUpdateWithoutPlanInput, DeploymentApprovalUncheckedUpdateWithoutPlanInput>
    create: XOR<DeploymentApprovalCreateWithoutPlanInput, DeploymentApprovalUncheckedCreateWithoutPlanInput>
  }

  export type DeploymentApprovalUpdateWithWhereUniqueWithoutPlanInput = {
    where: DeploymentApprovalWhereUniqueInput
    data: XOR<DeploymentApprovalUpdateWithoutPlanInput, DeploymentApprovalUncheckedUpdateWithoutPlanInput>
  }

  export type DeploymentApprovalUpdateManyWithWhereWithoutPlanInput = {
    where: DeploymentApprovalScalarWhereInput
    data: XOR<DeploymentApprovalUpdateManyMutationInput, DeploymentApprovalUncheckedUpdateManyWithoutPlanInput>
  }

  export type DeploymentPlanCreateWithoutExecutionsInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeploymentPlansInput
    prompt: PromptCreateNestedOneWithoutDeploymentPlansInput
    creator: UserCreateNestedOneWithoutCreatedDeploymentPlansInput
    approvals?: DeploymentApprovalCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUncheckedCreateWithoutExecutionsInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    createdBy: string
    approvals?: DeploymentApprovalUncheckedCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanCreateOrConnectWithoutExecutionsInput = {
    where: DeploymentPlanWhereUniqueInput
    create: XOR<DeploymentPlanCreateWithoutExecutionsInput, DeploymentPlanUncheckedCreateWithoutExecutionsInput>
  }

  export type UserCreateWithoutExecutedDeploymentsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutExecutedDeploymentsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutExecutedDeploymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExecutedDeploymentsInput, UserUncheckedCreateWithoutExecutedDeploymentsInput>
  }

  export type DeploymentPlanUpsertWithoutExecutionsInput = {
    update: XOR<DeploymentPlanUpdateWithoutExecutionsInput, DeploymentPlanUncheckedUpdateWithoutExecutionsInput>
    create: XOR<DeploymentPlanCreateWithoutExecutionsInput, DeploymentPlanUncheckedCreateWithoutExecutionsInput>
    where?: DeploymentPlanWhereInput
  }

  export type DeploymentPlanUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: DeploymentPlanWhereInput
    data: XOR<DeploymentPlanUpdateWithoutExecutionsInput, DeploymentPlanUncheckedUpdateWithoutExecutionsInput>
  }

  export type DeploymentPlanUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeploymentPlansNestedInput
    prompt?: PromptUpdateOneRequiredWithoutDeploymentPlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDeploymentPlansNestedInput
    approvals?: DeploymentApprovalUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvals?: DeploymentApprovalUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserUpsertWithoutExecutedDeploymentsInput = {
    update: XOR<UserUpdateWithoutExecutedDeploymentsInput, UserUncheckedUpdateWithoutExecutedDeploymentsInput>
    create: XOR<UserCreateWithoutExecutedDeploymentsInput, UserUncheckedCreateWithoutExecutedDeploymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExecutedDeploymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExecutedDeploymentsInput, UserUncheckedUpdateWithoutExecutedDeploymentsInput>
  }

  export type UserUpdateWithoutExecutedDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutExecutedDeploymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DeploymentPlanCreateWithoutApprovalsInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeploymentPlansInput
    prompt: PromptCreateNestedOneWithoutDeploymentPlansInput
    creator: UserCreateNestedOneWithoutCreatedDeploymentPlansInput
    executions?: DeploymentExecutionCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanUncheckedCreateWithoutApprovalsInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    createdBy: string
    executions?: DeploymentExecutionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type DeploymentPlanCreateOrConnectWithoutApprovalsInput = {
    where: DeploymentPlanWhereUniqueInput
    create: XOR<DeploymentPlanCreateWithoutApprovalsInput, DeploymentPlanUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutDeploymentApprovalsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    requestedApprovals?: ApprovalRequestCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDeploymentApprovalsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    requestedApprovals?: ApprovalRequestUncheckedCreateNestedManyWithoutRequesterInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDeploymentApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeploymentApprovalsInput, UserUncheckedCreateWithoutDeploymentApprovalsInput>
  }

  export type DeploymentPlanUpsertWithoutApprovalsInput = {
    update: XOR<DeploymentPlanUpdateWithoutApprovalsInput, DeploymentPlanUncheckedUpdateWithoutApprovalsInput>
    create: XOR<DeploymentPlanCreateWithoutApprovalsInput, DeploymentPlanUncheckedCreateWithoutApprovalsInput>
    where?: DeploymentPlanWhereInput
  }

  export type DeploymentPlanUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: DeploymentPlanWhereInput
    data: XOR<DeploymentPlanUpdateWithoutApprovalsInput, DeploymentPlanUncheckedUpdateWithoutApprovalsInput>
  }

  export type DeploymentPlanUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeploymentPlansNestedInput
    prompt?: PromptUpdateOneRequiredWithoutDeploymentPlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDeploymentPlansNestedInput
    executions?: DeploymentExecutionUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executions?: DeploymentExecutionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserUpsertWithoutDeploymentApprovalsInput = {
    update: XOR<UserUpdateWithoutDeploymentApprovalsInput, UserUncheckedUpdateWithoutDeploymentApprovalsInput>
    create: XOR<UserCreateWithoutDeploymentApprovalsInput, UserUncheckedCreateWithoutDeploymentApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeploymentApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeploymentApprovalsInput, UserUncheckedUpdateWithoutDeploymentApprovalsInput>
  }

  export type UserUpdateWithoutDeploymentApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    requestedApprovals?: ApprovalRequestUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDeploymentApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    requestedApprovals?: ApprovalRequestUncheckedUpdateManyWithoutRequesterNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutApprovalRequestsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    prompts?: PromptCreateNestedManyWithoutProjectInput
    testRuns?: TestRunCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyCreateNestedManyWithoutProjectInput
    environments?: EnvironmentCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineCreateNestedManyWithoutProjectInput
    dependencies?: DependencyCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApprovalRequestsInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    prompts?: PromptUncheckedCreateNestedManyWithoutProjectInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutProjectInput
    ApiKey?: ApiKeyUncheckedCreateNestedManyWithoutProjectInput
    environments?: EnvironmentUncheckedCreateNestedManyWithoutProjectInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutProjectInput
    appIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutProjectInput
    testPipelines?: TestPipelineUncheckedCreateNestedManyWithoutProjectInput
    dependencies?: DependencyUncheckedCreateNestedManyWithoutProjectInput
    updatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutProjectInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutProjectInput
    syncOperations?: SyncOperationUncheckedCreateNestedManyWithoutProjectInput
    webhookDeliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutProjectInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApprovalRequestsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApprovalRequestsInput, ProjectUncheckedCreateWithoutApprovalRequestsInput>
  }

  export type PromptCreateWithoutApprovalRequestsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPromptsInput
    parent?: PromptCreateNestedOneWithoutVersionsInput
    versions?: PromptCreateNestedManyWithoutParentInput
    testRuns?: TestRunCreateNestedManyWithoutPromptInput
    deployments?: DeploymentCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateWithoutApprovalRequestsInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    parentId?: string | null
    versions?: PromptUncheckedCreateNestedManyWithoutParentInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutPromptInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutPromptInput
    impactAnalysis?: ImpactAnalysisUncheckedCreateNestedManyWithoutBaselinePromptInput
    pipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutPromptInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedCreateNestedManyWithoutBaselinePromptInput
    deploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptCreateOrConnectWithoutApprovalRequestsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutApprovalRequestsInput, PromptUncheckedCreateWithoutApprovalRequestsInput>
  }

  export type UserCreateWithoutRequestedApprovalsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunCreateNestedManyWithoutUserInput
    deployments?: DeploymentCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingCreateNestedManyWithoutUserInput
    billing?: UserBillingCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalCreateNestedManyWithoutApproverInput
    initiatedSyncs?: SyncOperationCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRequestedApprovalsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    passwordHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    testRuns?: TestRunUncheckedCreateNestedManyWithoutUserInput
    deployments?: DeploymentUncheckedCreateNestedManyWithoutDeployedByUserInput
    deploymentActions?: DeploymentHistoryUncheckedCreateNestedManyWithoutUserInput
    costTracking?: CostTrackingUncheckedCreateNestedManyWithoutUserInput
    billing?: UserBillingUncheckedCreateNestedOneWithoutUserInput
    createdIntegrations?: AppIntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdPipelines?: TestPipelineUncheckedCreateNestedManyWithoutCreatorInput
    executedPipelines?: PipelineExecutionUncheckedCreateNestedManyWithoutExecutorInput
    createdDependencies?: DependencyUncheckedCreateNestedManyWithoutCreatorInput
    createdUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutCreatorInput
    executedUpdatePlans?: UpdatePlanUncheckedCreateNestedManyWithoutExecutorInput
    createdDeploymentPlans?: DeploymentPlanUncheckedCreateNestedManyWithoutCreatorInput
    executedDeployments?: DeploymentExecutionUncheckedCreateNestedManyWithoutExecutorInput
    deploymentApprovals?: DeploymentApprovalUncheckedCreateNestedManyWithoutApproverInput
    initiatedSyncs?: SyncOperationUncheckedCreateNestedManyWithoutInitiatorInput
    createdWebhooks?: WebhookSubscriptionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRequestedApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestedApprovalsInput, UserUncheckedCreateWithoutRequestedApprovalsInput>
  }

  export type ImpactAnalysisCreateWithoutApprovalRequestsInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deployment: DeploymentCreateNestedOneWithoutImpactAnalysisInput
    baselinePrompt?: PromptCreateNestedOneWithoutImpactAnalysisInput
  }

  export type ImpactAnalysisUncheckedCreateWithoutApprovalRequestsInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deploymentId: string
    baselinePromptId?: string | null
  }

  export type ImpactAnalysisCreateOrConnectWithoutApprovalRequestsInput = {
    where: ImpactAnalysisWhereUniqueInput
    create: XOR<ImpactAnalysisCreateWithoutApprovalRequestsInput, ImpactAnalysisUncheckedCreateWithoutApprovalRequestsInput>
  }

  export type ProjectUpsertWithoutApprovalRequestsInput = {
    update: XOR<ProjectUpdateWithoutApprovalRequestsInput, ProjectUncheckedUpdateWithoutApprovalRequestsInput>
    create: XOR<ProjectCreateWithoutApprovalRequestsInput, ProjectUncheckedCreateWithoutApprovalRequestsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApprovalRequestsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApprovalRequestsInput, ProjectUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type ProjectUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PromptUpsertWithoutApprovalRequestsInput = {
    update: XOR<PromptUpdateWithoutApprovalRequestsInput, PromptUncheckedUpdateWithoutApprovalRequestsInput>
    create: XOR<PromptCreateWithoutApprovalRequestsInput, PromptUncheckedCreateWithoutApprovalRequestsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutApprovalRequestsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutApprovalRequestsInput, PromptUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type PromptUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type UserUpsertWithoutRequestedApprovalsInput = {
    update: XOR<UserUpdateWithoutRequestedApprovalsInput, UserUncheckedUpdateWithoutRequestedApprovalsInput>
    create: XOR<UserCreateWithoutRequestedApprovalsInput, UserUncheckedCreateWithoutRequestedApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequestedApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequestedApprovalsInput, UserUncheckedUpdateWithoutRequestedApprovalsInput>
  }

  export type UserUpdateWithoutRequestedApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUpdateManyWithoutUserNestedInput
    billing?: UserBillingUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUpdateManyWithoutApproverNestedInput
    initiatedSyncs?: SyncOperationUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestedApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutUserNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutDeployedByUserNestedInput
    deploymentActions?: DeploymentHistoryUncheckedUpdateManyWithoutUserNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutUserNestedInput
    billing?: UserBillingUncheckedUpdateOneWithoutUserNestedInput
    createdIntegrations?: AppIntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdPipelines?: TestPipelineUncheckedUpdateManyWithoutCreatorNestedInput
    executedPipelines?: PipelineExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    createdDependencies?: DependencyUncheckedUpdateManyWithoutCreatorNestedInput
    createdUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedUpdatePlans?: UpdatePlanUncheckedUpdateManyWithoutExecutorNestedInput
    createdDeploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutCreatorNestedInput
    executedDeployments?: DeploymentExecutionUncheckedUpdateManyWithoutExecutorNestedInput
    deploymentApprovals?: DeploymentApprovalUncheckedUpdateManyWithoutApproverNestedInput
    initiatedSyncs?: SyncOperationUncheckedUpdateManyWithoutInitiatorNestedInput
    createdWebhooks?: WebhookSubscriptionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ImpactAnalysisUpsertWithoutApprovalRequestsInput = {
    update: XOR<ImpactAnalysisUpdateWithoutApprovalRequestsInput, ImpactAnalysisUncheckedUpdateWithoutApprovalRequestsInput>
    create: XOR<ImpactAnalysisCreateWithoutApprovalRequestsInput, ImpactAnalysisUncheckedCreateWithoutApprovalRequestsInput>
    where?: ImpactAnalysisWhereInput
  }

  export type ImpactAnalysisUpdateToOneWithWhereWithoutApprovalRequestsInput = {
    where?: ImpactAnalysisWhereInput
    data: XOR<ImpactAnalysisUpdateWithoutApprovalRequestsInput, ImpactAnalysisUncheckedUpdateWithoutApprovalRequestsInput>
  }

  export type ImpactAnalysisUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeploymentUpdateOneRequiredWithoutImpactAnalysisNestedInput
    baselinePrompt?: PromptUpdateOneWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisUncheckedUpdateWithoutApprovalRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ProjectCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestRunCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
  }

  export type DeploymentCreateManyDeployedByUserInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    environmentId: string
  }

  export type DeploymentHistoryCreateManyUserInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    deploymentId: string
  }

  export type CostTrackingCreateManyUserInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type AppIntegrationCreateManyCreatorInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type TestPipelineCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type PipelineExecutionCreateManyExecutorInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    promptId: string
    baselinePromptId?: string | null
  }

  export type DependencyCreateManyCreatorInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type UpdatePlanCreateManyCreatorInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    executedBy?: string | null
  }

  export type UpdatePlanCreateManyExecutorInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type DeploymentPlanCreateManyCreatorInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
  }

  export type DeploymentExecutionCreateManyExecutorInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
  }

  export type DeploymentApprovalCreateManyApproverInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planId: string
  }

  export type ApprovalRequestCreateManyRequesterInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    appId: string
    impactAnalysisId?: string | null
  }

  export type SyncOperationCreateManyInitiatorInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    connectionId: string
  }

  export type WebhookSubscriptionCreateManyCreatorInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string | null
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    prompts?: PromptUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    prompts?: PromptUncheckedUpdateManyWithoutProjectNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutProjectNestedInput
    ApiKey?: ApiKeyUncheckedUpdateManyWithoutProjectNestedInput
    environments?: EnvironmentUncheckedUpdateManyWithoutProjectNestedInput
    costTracking?: CostTrackingUncheckedUpdateManyWithoutProjectNestedInput
    appIntegrations?: AppIntegrationUncheckedUpdateManyWithoutProjectNestedInput
    testPipelines?: TestPipelineUncheckedUpdateManyWithoutProjectNestedInput
    dependencies?: DependencyUncheckedUpdateManyWithoutProjectNestedInput
    updatePlans?: UpdatePlanUncheckedUpdateManyWithoutProjectNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutProjectNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutProjectNestedInput
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutProjectNestedInput
    webhookDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutProjectNestedInput
    webhookSubscriptions?: WebhookSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestRunUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestRunsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutTestRunsNestedInput
    responses?: TestResponseUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    responses?: TestResponseUncheckedUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUncheckedUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentUpdateWithoutDeployedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutDeploymentsNestedInput
    environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsNestedInput
    history?: DeploymentHistoryUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutDeployedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
    history?: DeploymentHistoryUncheckedUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateManyWithoutDeployedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    environmentId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeploymentUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type DeploymentHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
  }

  export type CostTrackingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCostTrackingNestedInput
  }

  export type CostTrackingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type CostTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type AppIntegrationUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAppIntegrationsNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutConnectionNestedInput
  }

  export type AppIntegrationUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type AppIntegrationUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type TestPipelineUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestPipelinesNestedInput
    stages?: PipelineStageUpdateManyWithoutPipelineNestedInput
    executions?: PipelineExecutionUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    stages?: PipelineStageUncheckedUpdateManyWithoutPipelineNestedInput
    executions?: PipelineExecutionUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: TestPipelineUpdateOneRequiredWithoutExecutionsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutPipelineExecutionsNestedInput
    baselinePrompt?: PromptUpdateOneWithoutBaselinePipelineExecutionsNestedInput
  }

  export type PipelineExecutionUncheckedUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DependencyUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type DependencyUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type UpdatePlanUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatePlansNestedInput
    executor?: UserUpdateOneWithoutExecutedUpdatePlansNestedInput
  }

  export type UpdatePlanUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdatePlanUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdatePlanUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatePlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedUpdatePlansNestedInput
  }

  export type UpdatePlanUncheckedUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UpdatePlanUncheckedUpdateManyWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentPlanUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeploymentPlansNestedInput
    prompt?: PromptUpdateOneRequiredWithoutDeploymentPlansNestedInput
    executions?: DeploymentExecutionUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    executions?: DeploymentExecutionUncheckedUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentExecutionUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: DeploymentPlanUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type DeploymentExecutionUncheckedUpdateWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentExecutionUncheckedUpdateManyWithoutExecutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: DeploymentPlanUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type DeploymentApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planId?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appId?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutApprovalRequestsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutApprovalRequestsNestedInput
    impactAnalysis?: ImpactAnalysisUpdateOneWithoutApprovalRequestsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncOperationUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSyncOperationsNestedInput
    connection?: AppIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInput
  }

  export type SyncOperationUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
  }

  export type SyncOperationUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    connectionId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookSubscriptionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutWebhookSubscriptionsNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
    failedDeliveries?: WebhookDeliveryUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
    failedDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type PromptCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type TestRunCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    promptId: string
  }

  export type ApiKeyCreateManyProjectInput = {
    id?: string
    name: string
    provider: string
    keyHash: string
    isActive?: boolean
    lastUsed?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnvironmentCreateManyProjectInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    config?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostTrackingCreateManyProjectInput = {
    id?: string
    period: string
    totalCost: number
    tokenUsage: number
    requestCount: number
    breakdown: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type AppIntegrationCreateManyProjectInput = {
    id?: string
    name: string
    type: string
    baseUrl: string
    apiKeyHash: string
    syncConfig: string
    isActive?: boolean
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type TestPipelineCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    config: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type DependencyCreateManyProjectInput = {
    id?: string
    name: string
    type: string
    provider: string
    config: string
    status?: string
    version?: string | null
    healthScore?: number
    lastCheck?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type UpdatePlanCreateManyProjectInput = {
    id?: string
    planData: string
    status?: string
    executionResult?: string | null
    executedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    executedBy?: string | null
  }

  export type DeploymentPlanCreateManyProjectInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    createdBy: string
  }

  export type ApprovalRequestCreateManyProjectInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    appId: string
    requestedBy: string
    impactAnalysisId?: string | null
  }

  export type SyncOperationCreateManyProjectInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    connectionId: string
    initiatedBy: string
  }

  export type WebhookDeliveryCreateManyProjectInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    webhookId?: string | null
    failedWebhookId?: string | null
  }

  export type WebhookSubscriptionCreateManyProjectInput = {
    id?: string
    url: string
    events: string
    headers?: string
    secret?: string | null
    enabled?: boolean
    retryAttempts?: number
    lastDelivery?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PromptUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PromptUpdateOneWithoutVersionsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestRunUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestRunsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutTestRunsNestedInput
    responses?: TestResponseUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    responses?: TestResponseUncheckedUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUncheckedUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
  }

  export type ApiKeyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnvironmentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployments?: DeploymentUncheckedUpdateManyWithoutEnvironmentNestedInput
  }

  export type EnvironmentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostTrackingUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCostTrackingNestedInput
  }

  export type CostTrackingUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostTrackingUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    tokenUsage?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppIntegrationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
    syncOperations?: SyncOperationUpdateManyWithoutConnectionNestedInput
  }

  export type AppIntegrationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    syncOperations?: SyncOperationUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type AppIntegrationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    baseUrl?: StringFieldUpdateOperationsInput | string
    apiKeyHash?: StringFieldUpdateOperationsInput | string
    syncConfig?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type TestPipelineUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedPipelinesNestedInput
    stages?: PipelineStageUpdateManyWithoutPipelineNestedInput
    executions?: PipelineExecutionUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    stages?: PipelineStageUncheckedUpdateManyWithoutPipelineNestedInput
    executions?: PipelineExecutionUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type TestPipelineUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedDependenciesNestedInput
  }

  export type DependencyUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    lastCheck?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UpdatePlanUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedUpdatePlansNestedInput
    executor?: UserUpdateOneWithoutExecutedUpdatePlansNestedInput
  }

  export type UpdatePlanUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdatePlanUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    executionResult?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeploymentPlanUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutDeploymentPlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDeploymentPlansNestedInput
    executions?: DeploymentExecutionUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executions?: DeploymentExecutionUncheckedUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalRequestUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appId?: StringFieldUpdateOperationsInput | string
    prompt?: PromptUpdateOneRequiredWithoutApprovalRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutRequestedApprovalsNestedInput
    impactAnalysis?: ImpactAnalysisUpdateOneWithoutApprovalRequestsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncOperationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connection?: AppIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedSyncsNestedInput
  }

  export type SyncOperationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectionId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SyncOperationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectionId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookDeliveryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    webhook?: WebhookSubscriptionUpdateOneWithoutDeliveriesNestedInput
    failedWebhook?: WebhookSubscriptionUpdateOneWithoutFailedDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    webhookId?: NullableStringFieldUpdateOperationsInput | string | null
    failedWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    webhookId?: NullableStringFieldUpdateOperationsInput | string | null
    failedWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookSubscriptionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedWebhooksNestedInput
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
    failedDeliveries?: WebhookDeliveryUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
    failedDeliveries?: WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookNestedInput
  }

  export type WebhookSubscriptionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: StringFieldUpdateOperationsInput | string
    headers?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    retryAttempts?: IntFieldUpdateOperationsInput | number
    lastDelivery?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type PromptCreateManyParentInput = {
    id?: string
    name: string
    description?: string | null
    content: string
    version?: number
    isArchived?: boolean
    tags: string
    metadata?: string | null
    outputSchema?: string | null
    outputFormat?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type TestRunCreateManyPromptInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    config: string
    metadata?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    userId: string
  }

  export type DeploymentCreateManyPromptInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    environmentId: string
    deployedBy: string
  }

  export type ImpactAnalysisCreateManyBaselinePromptInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    deploymentId: string
  }

  export type PipelineExecutionCreateManyPromptInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    baselinePromptId?: string | null
    executedBy: string
  }

  export type PipelineExecutionCreateManyBaselinePromptInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    promptId: string
    executedBy: string
  }

  export type DeploymentPlanCreateManyPromptInput = {
    id?: string
    planData: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    createdBy: string
  }

  export type ApprovalRequestCreateManyPromptInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    appId: string
    requestedBy: string
    impactAnalysisId?: string | null
  }

  export type PromptUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPromptsNestedInput
    versions?: PromptUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    versions?: PromptUncheckedUpdateManyWithoutParentNestedInput
    testRuns?: TestRunUncheckedUpdateManyWithoutPromptNestedInput
    deployments?: DeploymentUncheckedUpdateManyWithoutPromptNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptNestedInput
    pipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutPromptNestedInput
    baselinePipelineExecutions?: PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptNestedInput
    deploymentPlans?: DeploymentPlanUncheckedUpdateManyWithoutPromptNestedInput
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    tags?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    outputSchema?: NullableStringFieldUpdateOperationsInput | string | null
    outputFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type TestRunUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTestRunsNestedInput
    user?: UserUpdateOneRequiredWithoutTestRunsNestedInput
    responses?: TestResponseUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    responses?: TestResponseUncheckedUpdateManyWithoutTestRunNestedInput
    metrics?: TestMetricUncheckedUpdateManyWithoutTestRunNestedInput
  }

  export type TestRunUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environment?: EnvironmentUpdateOneRequiredWithoutDeploymentsNestedInput
    deployedByUser?: UserUpdateOneRequiredWithoutDeploymentsNestedInput
    history?: DeploymentHistoryUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environmentId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
    history?: DeploymentHistoryUncheckedUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environmentId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ImpactAnalysisUpdateWithoutBaselinePromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeploymentUpdateOneRequiredWithoutImpactAnalysisNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisUncheckedUpdateWithoutBaselinePromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisUncheckedUpdateManyWithoutBaselinePromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deploymentId?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: TestPipelineUpdateOneRequiredWithoutExecutionsNestedInput
    baselinePrompt?: PromptUpdateOneWithoutBaselinePipelineExecutionsNestedInput
    executor?: UserUpdateOneRequiredWithoutExecutedPipelinesNestedInput
  }

  export type PipelineExecutionUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionUpdateWithoutBaselinePromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: TestPipelineUpdateOneRequiredWithoutExecutionsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutPipelineExecutionsNestedInput
    executor?: UserUpdateOneRequiredWithoutExecutedPipelinesNestedInput
  }

  export type PipelineExecutionUncheckedUpdateWithoutBaselinePromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutBaselinePromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentPlanUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeploymentPlansNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedDeploymentPlansNestedInput
    executions?: DeploymentExecutionUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    executions?: DeploymentExecutionUncheckedUpdateManyWithoutPlanNestedInput
    approvals?: DeploymentApprovalUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type DeploymentPlanUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    planData?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalRequestUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appId?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutApprovalRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutRequestedApprovalsNestedInput
    impactAnalysis?: ImpactAnalysisUpdateOneWithoutApprovalRequestsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    impactAnalysisId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestResponseCreateManyTestRunInput = {
    id?: string
    modelProvider: string
    modelName: string
    input: string
    output: string
    parsedOutput?: string | null
    outputStructure?: string | null
    tokenUsage?: string | null
    latencyMs?: number | null
    cost?: number | null
    error?: string | null
    rawResponse?: string | null
    evaluationData?: string | null
    createdAt?: Date | string
  }

  export type TestMetricCreateManyTestRunInput = {
    id?: string
    name: string
    value: number
    unit?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type TestResponseUpdateWithoutTestRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResponseUncheckedUpdateWithoutTestRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResponseUncheckedUpdateManyWithoutTestRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelProvider?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    input?: StringFieldUpdateOperationsInput | string
    output?: StringFieldUpdateOperationsInput | string
    parsedOutput?: NullableStringFieldUpdateOperationsInput | string | null
    outputStructure?: NullableStringFieldUpdateOperationsInput | string | null
    tokenUsage?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    rawResponse?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestMetricUpdateWithoutTestRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestMetricUncheckedUpdateWithoutTestRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestMetricUncheckedUpdateManyWithoutTestRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    projectId?: string | null
    failedWebhookId?: string | null
  }

  export type WebhookDeliveryCreateManyFailedWebhookInput = {
    id?: string
    url: string
    payload: string
    headers?: string | null
    status?: string
    attempts?: number
    maxAttempts?: number
    response?: string | null
    error?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType: string
    projectId?: string | null
    webhookId?: string | null
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutWebhookDeliveriesNestedInput
    failedWebhook?: WebhookSubscriptionUpdateOneWithoutFailedDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    failedWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    failedWebhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookDeliveryUpdateWithoutFailedWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneWithoutWebhookDeliveriesNestedInput
    webhook?: WebhookSubscriptionUpdateOneWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateWithoutFailedWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutFailedWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    headers?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeploymentCreateManyEnvironmentInput = {
    id?: string
    version: string
    status?: string
    deployedUrl?: string | null
    config?: string | null
    metadata?: string | null
    deployedAt?: Date | string | null
    rollbackAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    deployedBy: string
  }

  export type DeploymentUpdateWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutDeploymentsNestedInput
    deployedByUser?: UserUpdateOneRequiredWithoutDeploymentsNestedInput
    history?: DeploymentHistoryUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
    history?: DeploymentHistoryUncheckedUpdateManyWithoutDeploymentNestedInput
    impactAnalysis?: ImpactAnalysisUncheckedUpdateManyWithoutDeploymentNestedInput
  }

  export type DeploymentUncheckedUpdateManyWithoutEnvironmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    deployedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    deployedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rollbackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    deployedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentHistoryCreateManyDeploymentInput = {
    id?: string
    action: string
    status: string
    metadata?: string | null
    timestamp?: Date | string
    performedBy: string
  }

  export type ImpactAnalysisCreateManyDeploymentInput = {
    id?: string
    impactPercentage: number
    diffAnalysis: string
    sampleComparisons: string
    createdAt?: Date | string
    baselinePromptId?: string | null
  }

  export type DeploymentHistoryUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeploymentActionsNestedInput
  }

  export type DeploymentHistoryUncheckedUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    performedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentHistoryUncheckedUpdateManyWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    performedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ImpactAnalysisUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselinePrompt?: PromptUpdateOneWithoutImpactAnalysisNestedInput
    approvalRequests?: ApprovalRequestUpdateManyWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisUncheckedUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequests?: ApprovalRequestUncheckedUpdateManyWithoutImpactAnalysisNestedInput
  }

  export type ImpactAnalysisUncheckedUpdateManyWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    impactPercentage?: FloatFieldUpdateOperationsInput | number
    diffAnalysis?: StringFieldUpdateOperationsInput | string
    sampleComparisons?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApprovalRequestCreateManyImpactAnalysisInput = {
    id?: string
    status?: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    promptId: string
    appId: string
    requestedBy: string
  }

  export type ApprovalRequestUpdateWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appId?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutApprovalRequestsNestedInput
    prompt?: PromptUpdateOneRequiredWithoutApprovalRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutRequestedApprovalsNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutImpactAnalysisInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    appId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SyncOperationCreateManyConnectionInput = {
    id?: string
    direction: string
    strategy: string
    status?: string
    progress: string
    result?: string | null
    error?: string | null
    config: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    initiatedBy: string
  }

  export type SyncOperationUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSyncOperationsNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedSyncsNestedInput
  }

  export type SyncOperationUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SyncOperationUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    strategy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    config?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineStageCreateManyPipelineInput = {
    id?: string
    name: string
    type: string
    config: string
    order: number
    status?: string
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineExecutionCreateManyPipelineInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    result?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promptId: string
    baselinePromptId?: string | null
    executedBy: string
  }

  export type PipelineStageUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineStageUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineStageUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    config?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineExecutionUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneRequiredWithoutPipelineExecutionsNestedInput
    baselinePrompt?: PromptUpdateOneWithoutBaselinePipelineExecutionsNestedInput
    executor?: UserUpdateOneRequiredWithoutExecutedPipelinesNestedInput
  }

  export type PipelineExecutionUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PipelineExecutionUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: StringFieldUpdateOperationsInput | string
    baselinePromptId?: NullableStringFieldUpdateOperationsInput | string | null
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentExecutionCreateManyPlanInput = {
    id?: string
    status?: string
    currentStage?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    metrics?: string | null
    error?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    executedBy: string
  }

  export type DeploymentApprovalCreateManyPlanInput = {
    id?: string
    status?: string
    comments?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy: string
  }

  export type DeploymentExecutionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executor?: UserUpdateOneRequiredWithoutExecutedDeploymentsNestedInput
  }

  export type DeploymentExecutionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentExecutionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentStage?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metrics?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentApprovalUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneRequiredWithoutDeploymentApprovalsNestedInput
  }

  export type DeploymentApprovalUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StringFieldUpdateOperationsInput | string
  }

  export type DeploymentApprovalUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptCountOutputTypeDefaultArgs instead
     */
    export type PromptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestRunCountOutputTypeDefaultArgs instead
     */
    export type TestRunCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestRunCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookSubscriptionCountOutputTypeDefaultArgs instead
     */
    export type WebhookSubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookSubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnvironmentCountOutputTypeDefaultArgs instead
     */
    export type EnvironmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnvironmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentCountOutputTypeDefaultArgs instead
     */
    export type DeploymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImpactAnalysisCountOutputTypeDefaultArgs instead
     */
    export type ImpactAnalysisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImpactAnalysisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppIntegrationCountOutputTypeDefaultArgs instead
     */
    export type AppIntegrationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppIntegrationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestPipelineCountOutputTypeDefaultArgs instead
     */
    export type TestPipelineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestPipelineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentPlanCountOutputTypeDefaultArgs instead
     */
    export type DeploymentPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectMemberDefaultArgs instead
     */
    export type ProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptDefaultArgs instead
     */
    export type PromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestRunDefaultArgs instead
     */
    export type TestRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestRunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestResponseDefaultArgs instead
     */
    export type TestResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestMetricDefaultArgs instead
     */
    export type TestMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationPluginDefaultArgs instead
     */
    export type EvaluationPluginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationPluginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QueueJobDefaultArgs instead
     */
    export type QueueJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QueueJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecurringJobDefaultArgs instead
     */
    export type RecurringJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecurringJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncOperationDefaultArgs instead
     */
    export type SyncOperationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncOperationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookSubscriptionDefaultArgs instead
     */
    export type WebhookSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDeliveryDefaultArgs instead
     */
    export type WebhookDeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnvironmentDefaultArgs instead
     */
    export type EnvironmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnvironmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentDefaultArgs instead
     */
    export type DeploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentHistoryDefaultArgs instead
     */
    export type DeploymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImpactAnalysisDefaultArgs instead
     */
    export type ImpactAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImpactAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostTrackingDefaultArgs instead
     */
    export type CostTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBillingDefaultArgs instead
     */
    export type UserBillingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBillingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppIntegrationDefaultArgs instead
     */
    export type AppIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppIntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestPipelineDefaultArgs instead
     */
    export type TestPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestPipelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PipelineStageDefaultArgs instead
     */
    export type PipelineStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PipelineStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PipelineExecutionDefaultArgs instead
     */
    export type PipelineExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PipelineExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DependencyDefaultArgs instead
     */
    export type DependencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DependencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UpdatePlanDefaultArgs instead
     */
    export type UpdatePlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UpdatePlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentPlanDefaultArgs instead
     */
    export type DeploymentPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentExecutionDefaultArgs instead
     */
    export type DeploymentExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentExecutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeploymentApprovalDefaultArgs instead
     */
    export type DeploymentApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeploymentApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalRequestDefaultArgs instead
     */
    export type ApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalRequestDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}